###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.4.261/W32 for ARM         10/Jan/2021  16:10:21
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Source\System\uCOS-III\Source\os_sem.c
#    Command line      =
#        -f C:\Users\macanlin\AppData\Local\Temp\EWEC4E.tmp
#        ("C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Source\System\uCOS-III\Source\os_sem.c" -D USE_STDPERIPH_DRIVER
#        -D STM32F072 -lC
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\List" -o
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        C:\rj\IAR\arm\inc\c\DLib_Config_Normal.h -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\BSP\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\FWLib\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\CMSIS\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\OS_Cfg\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-CPU\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-LIB\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uCOS-III\Ports\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uCOS-III\Source\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\APP\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\FWLib\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-LIB\\" -Ol -I
#        C:\rj\IAR\arm\CMSIS\Core\Include\\ -I
#        C:\rj\IAR\arm\CMSIS\DSP\Include\\)
#    Locale            =  C
#    List file         =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\List\os_sem.lst
#    Object file       =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\Obj\os_sem.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#
###############################################################################

C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345 -1-9\Source\System\uCOS-III\Source\os_sem.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                 SEMAPHORE MANAGEMENT
     10          *
     11          * File    : OS_SEM.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define  MICRIUM_SOURCE
     34          #include <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_sem__c = "$Id: $";
     38          #endif
     39          
     40          
     41          #if OS_CFG_SEM_EN > 0u
     42          /*
     43          ************************************************************************************************************************
     44          *                                                  CREATE A SEMAPHORE
     45          *
     46          * Description: This function creates a semaphore.
     47          *
     48          * Arguments  : p_sem         is a pointer to the semaphore to initialize.  Your application is responsible for
     49          *                            allocating storage for the semaphore.
     50          *
     51          *              p_name        is a pointer to the name you would like to give the semaphore.
     52          *
     53          *              cnt           is the initial value for the semaphore.
     54          *                            If used to share resources, you should initialize to the number of resources available.
     55          *                            If used to signal the occurrence of event(s) then you should initialize to 0.
     56          *
     57          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
     58          *
     59          *                                OS_ERR_NONE                    if the call was successful
     60          *                                OS_ERR_CREATE_ISR              if you called this function from an ISR
     61          *                                OS_ERR_ILLEGAL_CREATE_RUN_TIME if you are trying to create the semaphore after you
     62          *                                                                 called OSSafetyCriticalStart().
     63          *                                OS_ERR_NAME                    if 'p_name' is a NULL pointer
     64          *                                OS_ERR_OBJ_CREATED             if the semaphore has already been created
     65          *                                OS_ERR_OBJ_PTR_NULL            if 'p_sem'  is a NULL pointer
     66          *                                OS_ERR_OBJ_TYPE                if 'p_sem' has already been initialized to a different
     67          *                                                               object type
     68          *
     69          * Returns    : none
     70          ************************************************************************************************************************
     71          */
     72          

   \                                 In section .text, align 2, keep-with-next
     73          void  OSSemCreate (OS_SEM      *p_sem,
     74                             CPU_CHAR    *p_name,
     75                             OS_SEM_CTR   cnt,
     76                             OS_ERR      *p_err)
     77          {
   \                     OSSemCreate: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x001F             MOVS     R7,R3
     78              CPU_SR_ALLOC();
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x0023             MOVS     R3,R4
     79          
     80          
     81          
     82          #ifdef OS_SAFETY_CRITICAL
     83              if (p_err == (OS_ERR *)0) {
     84                  OS_SAFETY_CRITICAL_EXCEPTION();
     85                  return;
     86              }
     87          #endif
     88          
     89          #ifdef OS_SAFETY_CRITICAL_IEC61508
     90              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
     91                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
     92                  return;
     93              }
     94          #endif
     95          
     96          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
     97              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to be called from an ISR                   */
   \        0x8   0x....             LDR      R3,??DataTable1
   \        0xA   0x781B             LDRB     R3,[R3, #+0]
   \        0xC   0x2B00             CMP      R3,#+0
   \        0xE   0xD002             BEQ      ??OSSemCreate_0
     98                 *p_err = OS_ERR_CREATE_ISR;
   \       0x10   0x....             LDR      R0,??DataTable2  ;; 0x2ee1
   \       0x12   0x8038             STRH     R0,[R7, #+0]
     99                  return;
   \       0x14   0xE029             B        ??OSSemCreate_1
    100              }
   \                     ??OSSemCreate_0: (+1)
   \       0x16   0x0005             MOVS     R5,R0
    101          #endif
    102          
    103          #if OS_CFG_ARG_CHK_EN > 0u
    104              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \       0x18   0x2D00             CMP      R5,#+0
   \       0x1A   0xD102             BNE      ??OSSemCreate_2
    105                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \       0x1C   0x....             LDR      R0,??DataTable2_1  ;; 0x5dc3
   \       0x1E   0x8038             STRH     R0,[R7, #+0]
    106                  return;
   \       0x20   0xE023             B        ??OSSemCreate_1
    107              }
   \                     ??OSSemCreate_2: (+1)
   \       0x22   0x9200             STR      R2,[SP, #+0]
   \       0x24   0x9101             STR      R1,[SP, #+4]
    108          #endif
    109          
    110              OS_CRITICAL_ENTER();
   \       0x26   0x....'....        BL       CPU_SR_Save
   \       0x2A   0x....             LDR      R6,??DataTable2_2
   \       0x2C   0x7831             LDRB     R1,[R6, #+0]
   \       0x2E   0x1C49             ADDS     R1,R1,#+1
   \       0x30   0x7031             STRB     R1,[R6, #+0]
   \       0x32   0x....'....        BL       CPU_SR_Restore
    111              p_sem->Type    = OS_OBJ_TYPE_SEM;                       /* Mark the data structure as a semaphore                 */
   \       0x36   0x....             LDR      R0,??DataTable2_3  ;; 0x414d4553
   \       0x38   0x6028             STR      R0,[R5, #+0]
    112              p_sem->Ctr     = cnt;                                   /* Set semaphore value                                    */
   \       0x3A   0x9800             LDR      R0,[SP, #+0]
   \       0x3C   0x6228             STR      R0,[R5, #+32]
    113              p_sem->TS      = (CPU_TS)0;
   \       0x3E   0x626C             STR      R4,[R5, #+36]
    114              p_sem->NamePtr = p_name;                                /* Save the name of the semaphore                         */
   \       0x40   0x9801             LDR      R0,[SP, #+4]
   \       0x42   0x6068             STR      R0,[R5, #+4]
    115              OS_PendListInit(&p_sem->PendList);                      /* Initialize the waiting list                            */
   \       0x44   0x0028             MOVS     R0,R5
   \       0x46   0x3008             ADDS     R0,R0,#+8
   \       0x48   0x....'....        BL       OS_PendListInit
    116          
    117          #if OS_CFG_DBG_EN > 0u
    118              OS_SemDbgListAdd(p_sem);
   \       0x4C   0x0028             MOVS     R0,R5
   \       0x4E   0x....'....        BL       OS_SemDbgListAdd
    119          #endif
    120              OSSemQty++;
   \       0x52   0x....             LDR      R0,??DataTable3
   \       0x54   0x8801             LDRH     R1,[R0, #+0]
   \       0x56   0x1C49             ADDS     R1,R1,#+1
   \       0x58   0x8001             STRH     R1,[R0, #+0]
    121          
    122              OS_CRITICAL_EXIT_NO_SCHED();
   \       0x5A   0x....'....        BL       CPU_SR_Save
   \       0x5E   0x7831             LDRB     R1,[R6, #+0]
   \       0x60   0x1E49             SUBS     R1,R1,#+1
   \       0x62   0x7031             STRB     R1,[R6, #+0]
   \       0x64   0x....'....        BL       CPU_SR_Restore
    123             *p_err = OS_ERR_NONE;
   \       0x68   0x803C             STRH     R4,[R7, #+0]
    124          }
   \                     ??OSSemCreate_1: (+1)
   \       0x6A   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    125          
    126          /*$PAGE*/
    127          /*
    128          ************************************************************************************************************************
    129          *                                                  DELETE A SEMAPHORE
    130          *
    131          * Description: This function deletes a semaphore.
    132          *
    133          * Arguments  : p_sem         is a pointer to the semaphore to delete
    134          *
    135          *              opt           determines delete options as follows:
    136          *
    137          *                                OS_OPT_DEL_NO_PEND          Delete semaphore ONLY if no task pending
    138          *                                OS_OPT_DEL_ALWAYS           Deletes the semaphore even if tasks are waiting.
    139          *                                                            In this case, all the tasks pending will be readied.
    140          *
    141          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    142          *
    143          *                                OS_ERR_NONE                 The call was successful and the semaphore was deleted
    144          *                                OS_ERR_DEL_ISR              If you attempted to delete the semaphore from an ISR
    145          *                                OS_ERR_OBJ_PTR_NULL         If 'p_sem' is a NULL pointer.
    146          *                                OS_ERR_OBJ_TYPE             If 'p_sem' is not pointing at a semaphore
    147          *                                OS_ERR_OPT_INVALID          An invalid option was specified
    148          *                                OS_ERR_TASK_WAITING         One or more tasks were waiting on the semaphore
    149          *
    150          * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
    151          *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
    152          *
    153          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of the semaphore
    154          *                 MUST check the return code of OSSemPend().
    155          *              2) OSSemAccept() callers will not know that the intended semaphore has been deleted.
    156          *              3) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in applications where
    157          *                 the semaphore is used for mutual exclusion because the resource(s) will no longer be guarded by the
    158          *                 semaphore.
    159          ************************************************************************************************************************
    160          */
    161          
    162          #if OS_CFG_SEM_DEL_EN > 0u
    163          OS_OBJ_QTY  OSSemDel (OS_SEM  *p_sem,
    164                                OS_OPT   opt,
    165                                OS_ERR  *p_err)
    166          {
    167              OS_OBJ_QTY     cnt;
    168              OS_OBJ_QTY     nbr_tasks;
    169              OS_PEND_DATA  *p_pend_data;
    170              OS_PEND_LIST  *p_pend_list;
    171              OS_TCB        *p_tcb;
    172              CPU_TS         ts;
    173              CPU_SR_ALLOC();
    174          
    175          
    176          
    177          #ifdef OS_SAFETY_CRITICAL
    178              if (p_err == (OS_ERR *)0) {
    179                  OS_SAFETY_CRITICAL_EXCEPTION();
    180                  return ((OS_OBJ_QTY)0);
    181              }
    182          #endif
    183          
    184          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    185              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to delete a semaphore from an ISR          */
    186                 *p_err = OS_ERR_DEL_ISR;
    187                  return ((OS_OBJ_QTY)0);
    188              }
    189          #endif
    190          
    191          #if OS_CFG_ARG_CHK_EN > 0u
    192              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
    193                 *p_err = OS_ERR_OBJ_PTR_NULL;
    194                  return ((OS_OBJ_QTY)0);
    195              }
    196              switch (opt) {                                          /* Validate 'opt'                                         */
    197                  case OS_OPT_DEL_NO_PEND:
    198                  case OS_OPT_DEL_ALWAYS:
    199                       break;
    200          
    201                  default:
    202                      *p_err = OS_ERR_OPT_INVALID;
    203                       return ((OS_OBJ_QTY)0);
    204              }
    205          #endif
    206          
    207          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    208              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
    209                 *p_err = OS_ERR_OBJ_TYPE;
    210                  return ((OS_OBJ_QTY)0);
    211              }
    212          #endif
    213          
    214              CPU_CRITICAL_ENTER();
    215              p_pend_list = &p_sem->PendList;
    216              cnt         = p_pend_list->NbrEntries;
    217              nbr_tasks   = cnt;
    218              switch (opt) {
    219                  case OS_OPT_DEL_NO_PEND:                            /* Delete semaphore only if no task waiting               */
    220                       if (nbr_tasks == (OS_OBJ_QTY)0) {
    221          #if OS_CFG_DBG_EN > 0u
    222                           OS_SemDbgListRemove(p_sem);
    223          #endif
    224                           OSSemQty--;
    225                           OS_SemClr(p_sem);
    226                           CPU_CRITICAL_EXIT();
    227                          *p_err = OS_ERR_NONE;
    228                       } else {
    229                           CPU_CRITICAL_EXIT();
    230                          *p_err = OS_ERR_TASK_WAITING;
    231                       }
    232                       break;
    233          
    234                  case OS_OPT_DEL_ALWAYS:                             /* Always delete the semaphore                            */
    235                       OS_CRITICAL_ENTER_CPU_EXIT();
    236                       ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
    237                       while (cnt > 0u) {                             /* Remove all tasks on the pend list                      */
    238                           p_pend_data = p_pend_list->HeadPtr;
    239                           p_tcb       = p_pend_data->TCBPtr;
    240                           OS_PendObjDel((OS_PEND_OBJ *)((void *)p_sem),
    241                                         p_tcb,
    242                                         ts);
    243                           cnt--;
    244                       }
    245          #if OS_CFG_DBG_EN > 0u
    246                       OS_SemDbgListRemove(p_sem);
    247          #endif
    248                       OSSemQty--;
    249                       OS_SemClr(p_sem);
    250                       OS_CRITICAL_EXIT_NO_SCHED();
    251                       OSSched();                                     /* Find highest priority task ready to run                */
    252                      *p_err = OS_ERR_NONE;
    253                       break;
    254          
    255                  default:
    256                       CPU_CRITICAL_EXIT();
    257                      *p_err = OS_ERR_OPT_INVALID;
    258                       break;
    259              }
    260              return ((OS_OBJ_QTY)nbr_tasks);
    261          }
    262          #endif
    263          
    264          /*$PAGE*/
    265          /*
    266          ************************************************************************************************************************
    267          *                                                  PEND ON SEMAPHORE
    268          *
    269          * Description: This function waits for a semaphore.
    270          *
    271          * Arguments  : p_sem         is a pointer to the semaphore
    272          *
    273          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait for the
    274          *                            resource up to the amount of time (in 'ticks') specified by this argument.  If you specify
    275          *                            0, however, your task will wait forever at the specified semaphore or, until the resource
    276          *                            becomes available (or the event occurs).
    277          *
    278          *              opt           determines whether the user wants to block if the semaphore is not available or not:
    279          *
    280          *                                OS_OPT_PEND_BLOCKING
    281          *                                OS_OPT_PEND_NON_BLOCKING
    282          *
    283          *              p_ts          is a pointer to a variable that will receive the timestamp of when the semaphore was posted
    284          *                            or pend aborted or the semaphore deleted.  If you pass a NULL pointer (i.e. (CPU_TS*)0)
    285          *                            then you will not get the timestamp.  In other words, passing a NULL pointer is valid
    286          *                            and indicates that you don't need the timestamp.
    287          *
    288          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    289          *
    290          *                                OS_ERR_NONE               The call was successful and your task owns the resource
    291          *                                                          or, the event you are waiting for occurred.
    292          *                                OS_ERR_OBJ_DEL            If 'p_sem' was deleted
    293          *                                OS_ERR_OBJ_PTR_NULL       If 'p_sem' is a NULL pointer.
    294          *                                OS_ERR_OBJ_TYPE           If 'p_sem' is not pointing at a semaphore
    295          *                                OS_ERR_OPT_INVALID        If you specified an invalid value for 'opt'
    296          *                                OS_ERR_PEND_ABORT         If the pend was aborted by another task
    297          *                                OS_ERR_PEND_ISR           If you called this function from an ISR and the result
    298          *                                                          would lead to a suspension.
    299          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but the semaphore was not
    300          *                                                          available.
    301          *                                OS_ERR_SCHED_LOCKED       If you called this function when the scheduler is locked
    302          *                                OS_ERR_STATUS_INVALID     Pend status is invalid
    303          *                                OS_ERR_TIMEOUT            The semaphore was not received within the specified
    304          *                                                          timeout.
    305          *
    306          *
    307          * Returns    : The current value of the semaphore counter or 0 if not available.
    308          ************************************************************************************************************************
    309          */
    310          

   \                                 In section .text, align 2, keep-with-next
    311          OS_SEM_CTR  OSSemPend (OS_SEM   *p_sem,
    312                                 OS_TICK   timeout,
    313                                 OS_OPT    opt,
    314                                 CPU_TS   *p_ts,
    315                                 OS_ERR   *p_err)
    316          {
   \                     OSSemPend: (+1)
   \        0x0   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   \        0x4   0x9C10             LDR      R4,[SP, #+64]
    317              OS_SEM_CTR    ctr;
    318              OS_PEND_DATA  pend_data;
    319              CPU_SR_ALLOC();
   \        0x6   0x2500             MOVS     R5,#+0
   \        0x8   0x0029             MOVS     R1,R5
    320          
    321          
    322          
    323          #ifdef OS_SAFETY_CRITICAL
    324              if (p_err == (OS_ERR *)0) {
    325                  OS_SAFETY_CRITICAL_EXCEPTION();
    326                  return ((OS_SEM_CTR)0);
    327              }
    328          #endif
    329          
    330          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    331              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   \        0xA   0x....             LDR      R1,??DataTable1
   \        0xC   0x7809             LDRB     R1,[R1, #+0]
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD003             BEQ      ??OSSemPend_0
    332                 *p_err = OS_ERR_PEND_ISR;
   \       0x12   0x....             LDR      R0,??DataTable2_4  ;; 0x61ae
   \       0x14   0x8020             STRH     R0,[R4, #+0]
    333                  return ((OS_SEM_CTR)0);
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE076             B        ??OSSemPend_1
    334              }
   \                     ??OSSemPend_0: (+1)
   \       0x1A   0x0006             MOVS     R6,R0
    335          #endif
    336          
    337          #if OS_CFG_ARG_CHK_EN > 0u
    338              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \       0x1C   0x2E00             CMP      R6,#+0
   \       0x1E   0xD103             BNE      ??OSSemPend_2
    339                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \       0x20   0x....             LDR      R0,??DataTable2_1  ;; 0x5dc3
   \       0x22   0x8020             STRH     R0,[R4, #+0]
    340                  return ((OS_SEM_CTR)0);
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xE06F             B        ??OSSemPend_1
    341              }
   \                     ??OSSemPend_2: (+1)
   \       0x28   0x0017             MOVS     R7,R2
    342              switch (opt) {                                          /* Validate 'opt'                                         */
   \       0x2A   0x0038             MOVS     R0,R7
   \       0x2C   0xB280             UXTH     R0,R0
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD003             BEQ      ??OSSemPend_3
   \       0x32   0x2180             MOVS     R1,#+128
   \       0x34   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \       0x36   0x4288             CMP      R0,R1
   \       0x38   0xD11D             BNE      ??OSSemPend_4
    343                  case OS_OPT_PEND_BLOCKING:
    344                  case OS_OPT_PEND_NON_BLOCKING:
    345                       break;
    346          
    347                  default:
    348                      *p_err = OS_ERR_OPT_INVALID;
    349                       return ((OS_SEM_CTR)0);
    350              }
    351          #endif
    352          
    353          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    354              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
   \                     ??OSSemPend_3: (+1)
   \       0x3A   0x6830             LDR      R0,[R6, #+0]
   \       0x3C   0x....             LDR      R1,??DataTable2_3  ;; 0x414d4553
   \       0x3E   0x4288             CMP      R0,R1
   \       0x40   0xD11D             BNE      ??OSSemPend_5
   \       0x42   0x9300             STR      R3,[SP, #+0]
    355                 *p_err = OS_ERR_OBJ_TYPE;
    356                  return ((OS_SEM_CTR)0);
    357              }
    358          #endif
    359          
    360              if (p_ts != (CPU_TS *)0) {
   \       0x44   0x9800             LDR      R0,[SP, #+0]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD001             BEQ      ??OSSemPend_6
    361                 *p_ts  = (CPU_TS)0;                                  /* Initialize the returned timestamp                      */
   \       0x4A   0x9800             LDR      R0,[SP, #+0]
   \       0x4C   0x6005             STR      R5,[R0, #+0]
    362              }
    363              CPU_CRITICAL_ENTER();
   \                     ??OSSemPend_6: (+1)
   \       0x4E   0x....'....        BL       CPU_SR_Save
    364              if (p_sem->Ctr > (OS_SEM_CTR)0) {                       /* Resource available?                                    */
   \       0x52   0x6A31             LDR      R1,[R6, #+32]
   \       0x54   0x2900             CMP      R1,#+0
   \       0x56   0xD016             BEQ      ??OSSemPend_7
    365                  p_sem->Ctr--;                                       /* Yes, caller may proceed                                */
   \       0x58   0x6A31             LDR      R1,[R6, #+32]
   \       0x5A   0x1E49             SUBS     R1,R1,#+1
   \       0x5C   0x6231             STR      R1,[R6, #+32]
    366                  if (p_ts != (CPU_TS *)0) {
   \       0x5E   0x9900             LDR      R1,[SP, #+0]
   \       0x60   0x2900             CMP      R1,#+0
   \       0x62   0xD002             BEQ      ??OSSemPend_8
    367                     *p_ts  = p_sem->TS;                              /*      get timestamp of last post                        */
   \       0x64   0x6A71             LDR      R1,[R6, #+36]
   \       0x66   0x9A00             LDR      R2,[SP, #+0]
   \       0x68   0x6011             STR      R1,[R2, #+0]
    368                  }
    369                  ctr   = p_sem->Ctr;
   \                     ??OSSemPend_8: (+1)
   \       0x6A   0x6A36             LDR      R6,[R6, #+32]
    370                  CPU_CRITICAL_EXIT();
   \       0x6C   0x....'....        BL       CPU_SR_Restore
    371                 *p_err = OS_ERR_NONE;
   \       0x70   0x8025             STRH     R5,[R4, #+0]
    372                  return (ctr);
   \       0x72   0x0030             MOVS     R0,R6
   \       0x74   0xE048             B        ??OSSemPend_1
    373              }
   \                     ??OSSemPend_4: (+1)
   \       0x76   0x....             LDR      R0,??DataTable3_1  ;; 0x5e25
   \       0x78   0x8020             STRH     R0,[R4, #+0]
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0xE044             B        ??OSSemPend_1
   \                     ??OSSemPend_5: (+1)
   \       0x7E   0x....             LDR      R0,??DataTable3_2  ;; 0x5dc4
   \       0x80   0x8020             STRH     R0,[R4, #+0]
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0xE040             B        ??OSSemPend_1
    374          
    375              if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
   \                     ??OSSemPend_7: (+1)
   \       0x86   0x0439             LSLS     R1,R7,#+16
   \       0x88   0xD506             BPL      ??OSSemPend_9
    376                  ctr   = p_sem->Ctr;                                 /* No                                                     */
   \       0x8A   0x6A35             LDR      R5,[R6, #+32]
    377                  CPU_CRITICAL_EXIT();
   \       0x8C   0x....'....        BL       CPU_SR_Restore
    378                 *p_err = OS_ERR_PEND_WOULD_BLOCK;
   \       0x90   0x....             LDR      R0,??DataTable3_3  ;; 0x61b0
   \       0x92   0x8020             STRH     R0,[R4, #+0]
    379                  return (ctr);
   \       0x94   0x0028             MOVS     R0,R5
   \       0x96   0xE037             B        ??OSSemPend_1
    380              } else {                                                /* Yes                                                    */
    381                  if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
   \                     ??OSSemPend_9: (+1)
   \       0x98   0x....             LDR      R7,??DataTable2_2
   \       0x9A   0x7839             LDRB     R1,[R7, #+0]
   \       0x9C   0x2900             CMP      R1,#+0
   \       0x9E   0xD005             BEQ      ??OSSemPend_10
    382                      CPU_CRITICAL_EXIT();
   \       0xA0   0x....'....        BL       CPU_SR_Restore
    383                     *p_err = OS_ERR_SCHED_LOCKED;
   \       0xA4   0x....             LDR      R0,??DataTable4  ;; 0x6d63
   \       0xA6   0x8020             STRH     R0,[R4, #+0]
    384                      return ((OS_SEM_CTR)0);
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0xE02D             B        ??OSSemPend_1
    385                  }
    386              }
    387                                                                      /* Lock the scheduler/re-enable interrupts                */
    388              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSSemPend_10: (+1)
   \       0xAC   0x7839             LDRB     R1,[R7, #+0]
   \       0xAE   0x1C49             ADDS     R1,R1,#+1
   \       0xB0   0x7039             STRB     R1,[R7, #+0]
   \       0xB2   0x....'....        BL       CPU_SR_Restore
    389              OS_Pend(&pend_data,                                     /* Block task pending on Semaphore                        */
    390                      (OS_PEND_OBJ *)((void *)p_sem),
    391                      OS_TASK_PEND_ON_SEM,
    392                      timeout);
   \       0xB6   0x9B0A             LDR      R3,[SP, #+40]
   \       0xB8   0x2206             MOVS     R2,#+6
   \       0xBA   0x0031             MOVS     R1,R6
   \       0xBC   0xA801             ADD      R0,SP,#+4
   \       0xBE   0x....'....        BL       OS_Pend
    393          
    394              OS_CRITICAL_EXIT_NO_SCHED();
   \       0xC2   0x....'....        BL       CPU_SR_Save
   \       0xC6   0x7839             LDRB     R1,[R7, #+0]
   \       0xC8   0x1E49             SUBS     R1,R1,#+1
   \       0xCA   0x7039             STRB     R1,[R7, #+0]
   \       0xCC   0x....'....        BL       CPU_SR_Restore
    395          
    396              OSSched();                                              /* Find the next highest priority task ready to run       */
   \       0xD0   0x....'....        BL       OSSched
    397          
    398              CPU_CRITICAL_ENTER();
   \       0xD4   0x....'....        BL       CPU_SR_Save
    399              switch (OSTCBCurPtr->PendStatus) {
   \       0xD8   0x....             LDR      R1,??DataTable5
   \       0xDA   0x680A             LDR      R2,[R1, #+0]
   \       0xDC   0x2335             MOVS     R3,#+53
   \       0xDE   0x5CD2             LDRB     R2,[R2, R3]
   \       0xE0   0x2A00             CMP      R2,#+0
   \       0xE2   0xD005             BEQ      ??OSSemPend_11
   \       0xE4   0x2A02             CMP      R2,#+2
   \       0xE6   0xD023             BEQ      ??OSSemPend_12
   \       0xE8   0xD310             BCC      ??OSSemPend_13
   \       0xEA   0x2A03             CMP      R2,#+3
   \       0xEC   0xD018             BEQ      ??OSSemPend_14
   \       0xEE   0xE029             B        ??OSSemPend_15
    400                  case OS_STATUS_PEND_OK:                             /* We got the semaphore                                   */
    401                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSSemPend_11: (+1)
   \       0xF0   0x9A00             LDR      R2,[SP, #+0]
   \       0xF2   0x2A00             CMP      R2,#+0
   \       0xF4   0xD003             BEQ      ??OSSemPend_16
    402                          *p_ts  =  OSTCBCurPtr->TS;
   \       0xF6   0x6809             LDR      R1,[R1, #+0]
   \       0xF8   0x6C09             LDR      R1,[R1, #+64]
   \       0xFA   0x9A00             LDR      R2,[SP, #+0]
   \       0xFC   0x6011             STR      R1,[R2, #+0]
    403                       }
    404                      *p_err = OS_ERR_NONE;
   \                     ??OSSemPend_16: (+1)
   \       0xFE   0x8025             STRH     R5,[R4, #+0]
    405                       break;
    406          
    407                  case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
    408                       if (p_ts != (CPU_TS *)0) {
    409                          *p_ts  =  OSTCBCurPtr->TS;
    410                       }
    411                      *p_err = OS_ERR_PEND_ABORT;
    412                       break;
    413          
    414                  case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get semaphore within timeout   */
    415                       if (p_ts != (CPU_TS *)0) {
    416                          *p_ts  = (CPU_TS  )0;
    417                       }
    418                      *p_err = OS_ERR_TIMEOUT;
    419                       break;
    420          
    421                  case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
    422                       if (p_ts != (CPU_TS *)0) {
    423                          *p_ts  =  OSTCBCurPtr->TS;
    424                       }
    425                      *p_err = OS_ERR_OBJ_DEL;
    426                       break;
    427          
    428                  default:
    429                      *p_err = OS_ERR_STATUS_INVALID;
    430                       CPU_CRITICAL_EXIT();
    431                       return ((OS_SEM_CTR)0);
    432              }
    433              ctr = p_sem->Ctr;
   \                     ??OSSemPend_17: (+1)
   \      0x100   0x6A34             LDR      R4,[R6, #+32]
    434              CPU_CRITICAL_EXIT();
   \      0x102   0x....'....        BL       CPU_SR_Restore
    435              return (ctr);
   \      0x106   0x0020             MOVS     R0,R4
   \                     ??OSSemPend_1: (+1)
   \      0x108   0xB00B             ADD      SP,SP,#+44
   \      0x10A   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??OSSemPend_13: (+1)
   \      0x10C   0x9A00             LDR      R2,[SP, #+0]
   \      0x10E   0x2A00             CMP      R2,#+0
   \      0x110   0xD003             BEQ      ??OSSemPend_18
   \      0x112   0x6809             LDR      R1,[R1, #+0]
   \      0x114   0x6C09             LDR      R1,[R1, #+64]
   \      0x116   0x9A00             LDR      R2,[SP, #+0]
   \      0x118   0x6011             STR      R1,[R2, #+0]
   \                     ??OSSemPend_18: (+1)
   \      0x11A   0x....             LDR      R1,??DataTable7  ;; 0x61a9
   \      0x11C   0x8021             STRH     R1,[R4, #+0]
   \      0x11E   0xE7EF             B        ??OSSemPend_17
   \                     ??OSSemPend_14: (+1)
   \      0x120   0x9900             LDR      R1,[SP, #+0]
   \      0x122   0x2900             CMP      R1,#+0
   \      0x124   0xD001             BEQ      ??OSSemPend_19
   \      0x126   0x9900             LDR      R1,[SP, #+0]
   \      0x128   0x600D             STR      R5,[R1, #+0]
   \                     ??OSSemPend_19: (+1)
   \      0x12A   0x....             LDR      R1,??DataTable7_1  ;; 0x72d9
   \      0x12C   0x8021             STRH     R1,[R4, #+0]
   \      0x12E   0xE7E7             B        ??OSSemPend_17
   \                     ??OSSemPend_12: (+1)
   \      0x130   0x9A00             LDR      R2,[SP, #+0]
   \      0x132   0x2A00             CMP      R2,#+0
   \      0x134   0xD003             BEQ      ??OSSemPend_20
   \      0x136   0x6809             LDR      R1,[R1, #+0]
   \      0x138   0x6C09             LDR      R1,[R1, #+64]
   \      0x13A   0x9A00             LDR      R2,[SP, #+0]
   \      0x13C   0x6011             STR      R1,[R2, #+0]
   \                     ??OSSemPend_20: (+1)
   \      0x13E   0x....             LDR      R1,??DataTable8  ;; 0x5dc2
   \      0x140   0x8021             STRH     R1,[R4, #+0]
   \      0x142   0xE7DD             B        ??OSSemPend_17
   \                     ??OSSemPend_15: (+1)
   \      0x144   0x....             LDR      R1,??DataTable8_1  ;; 0x6e2e
   \      0x146   0x8021             STRH     R1,[R4, #+0]
   \      0x148   0x....'....        BL       CPU_SR_Restore
   \      0x14C   0x2000             MOVS     R0,#+0
   \      0x14E   0xE7DB             B        ??OSSemPend_1
    436          }
    437          
    438          /*$PAGE*/
    439          /*
    440          ************************************************************************************************************************
    441          *                                             ABORT WAITING ON A SEMAPHORE
    442          *
    443          * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function should be used
    444          *              to fault-abort the wait on the semaphore, rather than to normally signal the semaphore via OSSemPost().
    445          *
    446          * Arguments  : p_sem     is a pointer to the semaphore
    447          *
    448          *              opt       determines the type of ABORT performed:
    449          *
    450          *                            OS_OPT_PEND_ABORT_1          ABORT wait for a single task (HPT) waiting on the semaphore
    451          *                            OS_OPT_PEND_ABORT_ALL        ABORT wait for ALL tasks that are  waiting on the semaphore
    452          *                            OS_OPT_POST_NO_SCHED         Do not call the scheduler
    453          *
    454          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    455          *
    456          *                            OS_ERR_NONE                  At least one task waiting on the semaphore was readied and
    457          *                                                         informed of the aborted wait; check return value for the
    458          *                                                         number of tasks whose wait on the semaphore was aborted.
    459          *                            OS_ERR_OBJ_PTR_NULL          If 'p_sem' is a NULL pointer.
    460          *                            OS_ERR_OBJ_TYPE              If 'p_sem' is not pointing at a semaphore
    461          *                            OS_ERR_OPT_INVALID           If you specified an invalid option
    462          *                            OS_ERR_PEND_ABORT_ISR        If you called this function from an ISR
    463          *                            OS_ERR_PEND_ABORT_NONE       No task were pending
    464          *
    465          * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
    466          *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
    467          ************************************************************************************************************************
    468          */
    469          
    470          #if OS_CFG_SEM_PEND_ABORT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    471          OS_OBJ_QTY  OSSemPendAbort (OS_SEM  *p_sem,
    472                                      OS_OPT   opt,
    473                                      OS_ERR  *p_err)
    474          {
   \                     OSSemPendAbort: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0016             MOVS     R6,R2
    475              OS_PEND_LIST  *p_pend_list;
    476              OS_TCB        *p_tcb;
    477              CPU_TS         ts;
    478              OS_OBJ_QTY     nbr_tasks;
    479              CPU_SR_ALLOC();
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0x002A             MOVS     R2,R5
    480          
    481          
    482          
    483          #ifdef OS_SAFETY_CRITICAL
    484              if (p_err == (OS_ERR *)0) {
    485                  OS_SAFETY_CRITICAL_EXCEPTION();
    486                  return ((OS_OBJ_QTY)0u);
    487              }
    488          #endif
    489          
    490          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    491              if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to Pend Abort from an ISR                  */
   \        0x8   0x....             LDR      R2,??DataTable8_2
   \        0xA   0x7812             LDRB     R2,[R2, #+0]
   \        0xC   0x2A00             CMP      R2,#+0
   \        0xE   0xD003             BEQ      ??OSSemPendAbort_0
    492                 *p_err =  OS_ERR_PEND_ABORT_ISR;
   \       0x10   0x....             LDR      R0,??DataTable8_3  ;; 0x61aa
   \       0x12   0x8030             STRH     R0,[R6, #+0]
    493                  return ((OS_OBJ_QTY)0u);
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xE05E             B        ??OSSemPendAbort_1
    494              }
   \                     ??OSSemPendAbort_0: (+1)
   \       0x18   0x9000             STR      R0,[SP, #+0]
    495          #endif
    496          
    497          #if OS_CFG_ARG_CHK_EN > 0u
    498              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \       0x1A   0x9800             LDR      R0,[SP, #+0]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD103             BNE      ??OSSemPendAbort_2
    499                 *p_err =  OS_ERR_OBJ_PTR_NULL;
   \       0x20   0x....             LDR      R0,??DataTable2_1  ;; 0x5dc3
   \       0x22   0x8030             STRH     R0,[R6, #+0]
    500                  return ((OS_OBJ_QTY)0u);
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xE056             B        ??OSSemPendAbort_1
    501              }
   \                     ??OSSemPendAbort_2: (+1)
   \       0x28   0x000F             MOVS     R7,R1
    502              switch (opt) {                                          /* Validate 'opt'                                         */
   \       0x2A   0x0038             MOVS     R0,R7
   \       0x2C   0xB280             UXTH     R0,R0
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD00B             BEQ      ??OSSemPendAbort_3
   \       0x32   0x2180             MOVS     R1,#+128
   \       0x34   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \       0x36   0x4288             CMP      R0,R1
   \       0x38   0xD007             BEQ      ??OSSemPendAbort_3
   \       0x3A   0x2180             MOVS     R1,#+128
   \       0x3C   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \       0x3E   0x4288             CMP      R0,R1
   \       0x40   0xD003             BEQ      ??OSSemPendAbort_3
   \       0x42   0x2181             MOVS     R1,#+129
   \       0x44   0x0209             LSLS     R1,R1,#+8        ;; #+33024
   \       0x46   0x4288             CMP      R0,R1
   \       0x48   0xD113             BNE      ??OSSemPendAbort_4
    503                  case OS_OPT_PEND_ABORT_1:
    504                  case OS_OPT_PEND_ABORT_ALL:
    505                  case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
    506                  case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
    507                       break;
    508          
    509                  default:
    510                      *p_err =  OS_ERR_OPT_INVALID;
    511                       return ((OS_OBJ_QTY)0u);
    512              }
    513          #endif
    514          
    515          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    516              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
   \                     ??OSSemPendAbort_3: (+1)
   \       0x4A   0x9800             LDR      R0,[SP, #+0]
   \       0x4C   0x6800             LDR      R0,[R0, #+0]
   \       0x4E   0x....             LDR      R1,??DataTable2_3  ;; 0x414d4553
   \       0x50   0x4288             CMP      R0,R1
   \       0x52   0xD112             BNE      ??OSSemPendAbort_5
    517                 *p_err =  OS_ERR_OBJ_TYPE;
    518                  return ((OS_OBJ_QTY)0u);
    519              }
    520          #endif
    521          
    522              CPU_CRITICAL_ENTER();
   \       0x54   0x....'....        BL       CPU_SR_Save
    523              p_pend_list = &p_sem->PendList;
   \       0x58   0x9900             LDR      R1,[SP, #+0]
   \       0x5A   0x3108             ADDS     R1,R1,#+8
   \       0x5C   0x9101             STR      R1,[SP, #+4]
    524              if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0u) {        /* Any task waiting on semaphore?                         */
   \       0x5E   0x9901             LDR      R1,[SP, #+4]
   \       0x60   0x8909             LDRH     R1,[R1, #+8]
   \       0x62   0x2900             CMP      R1,#+0
   \       0x64   0xD10D             BNE      ??OSSemPendAbort_6
    525                  CPU_CRITICAL_EXIT();                                /* No                                                     */
   \       0x66   0x....'....        BL       CPU_SR_Restore
    526                 *p_err =  OS_ERR_PEND_ABORT_NONE;
   \       0x6A   0x....             LDR      R0,??DataTable8_4  ;; 0x61ab
   \       0x6C   0x8030             STRH     R0,[R6, #+0]
    527                  return ((OS_OBJ_QTY)0u);
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xE031             B        ??OSSemPendAbort_1
    528              }
   \                     ??OSSemPendAbort_4: (+1)
   \       0x72   0x....             LDR      R0,??DataTable3_1  ;; 0x5e25
   \       0x74   0x8030             STRH     R0,[R6, #+0]
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0xE02D             B        ??OSSemPendAbort_1
   \                     ??OSSemPendAbort_5: (+1)
   \       0x7A   0x....             LDR      R0,??DataTable3_2  ;; 0x5dc4
   \       0x7C   0x8030             STRH     R0,[R6, #+0]
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0xE029             B        ??OSSemPendAbort_1
    529          
    530              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSSemPendAbort_6: (+1)
   \       0x82   0x....             LDR      R1,??DataTable2_2
   \       0x84   0x7809             LDRB     R1,[R1, #+0]
   \       0x86   0x1C49             ADDS     R1,R1,#+1
   \       0x88   0x....             LDR      R2,??DataTable2_2
   \       0x8A   0x7011             STRB     R1,[R2, #+0]
   \       0x8C   0x....'....        BL       CPU_SR_Restore
    531              nbr_tasks = 0u;
   \       0x90   0x002C             MOVS     R4,R5
    532              ts        = OS_TS_GET();                                /* Get local time stamp so all tasks get the same time    */
   \       0x92   0x9502             STR      R5,[SP, #+8]
    533              while (p_pend_list->NbrEntries > (OS_OBJ_QTY)0u) {
   \                     ??OSSemPendAbort_7: (+1)
   \       0x94   0x9801             LDR      R0,[SP, #+4]
   \       0x96   0x8900             LDRH     R0,[R0, #+8]
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD00D             BEQ      ??OSSemPendAbort_8
    534                  p_tcb = p_pend_list->HeadPtr->TCBPtr;
   \       0x9C   0x9801             LDR      R0,[SP, #+4]
   \       0x9E   0x6800             LDR      R0,[R0, #+0]
   \       0xA0   0x6881             LDR      R1,[R0, #+8]
    535                  OS_PendAbort((OS_PEND_OBJ *)((void *)p_sem),
    536                               p_tcb,
    537                               ts);
   \       0xA2   0x9A02             LDR      R2,[SP, #+8]
   \       0xA4   0x9800             LDR      R0,[SP, #+0]
   \       0xA6   0x....'....        BL       OS_PendAbort
    538                  nbr_tasks++;
   \       0xAA   0x1C64             ADDS     R4,R4,#+1
    539                  if (opt != OS_OPT_PEND_ABORT_ALL) {                 /* Pend abort all tasks waiting?                          */
   \       0xAC   0x0038             MOVS     R0,R7
   \       0xAE   0xB280             UXTH     R0,R0
   \       0xB0   0x2180             MOVS     R1,#+128
   \       0xB2   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \       0xB4   0x4288             CMP      R0,R1
   \       0xB6   0xD0ED             BEQ      ??OSSemPendAbort_7
    540                      break;                                          /* No                                                     */
    541                  }
    542              }
    543              OS_CRITICAL_EXIT_NO_SCHED();
   \                     ??OSSemPendAbort_8: (+1)
   \       0xB8   0x....'....        BL       CPU_SR_Save
   \       0xBC   0x....             LDR      R1,??DataTable2_2
   \       0xBE   0x780A             LDRB     R2,[R1, #+0]
   \       0xC0   0x1E52             SUBS     R2,R2,#+1
   \       0xC2   0x700A             STRB     R2,[R1, #+0]
   \       0xC4   0x....'....        BL       CPU_SR_Restore
    544          
    545              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
   \       0xC8   0x0438             LSLS     R0,R7,#+16
   \       0xCA   0xD401             BMI      ??OSSemPendAbort_9
    546                  OSSched();                                          /* Run the scheduler                                      */
   \       0xCC   0x....'....        BL       OSSched
    547              }
    548          
    549             *p_err = OS_ERR_NONE;
   \                     ??OSSemPendAbort_9: (+1)
   \       0xD0   0x8035             STRH     R5,[R6, #+0]
    550              return (nbr_tasks);
   \       0xD2   0x0020             MOVS     R0,R4
   \       0xD4   0xB280             UXTH     R0,R0
   \                     ??OSSemPendAbort_1: (+1)
   \       0xD6   0xBDFE             POP      {R1-R7,PC}       ;; return
    551          }
    552          #endif
    553          
    554          /*$PAGE*/
    555          /*
    556          ************************************************************************************************************************
    557          *                                                 POST TO A SEMAPHORE
    558          *
    559          * Description: This function signals a semaphore
    560          *
    561          * Arguments  : p_sem    is a pointer to the semaphore
    562          *
    563          *              opt      determines the type of POST performed:
    564          *
    565          *                           OS_OPT_POST_1            POST and ready only the highest priority task waiting on semaphore
    566          *                                                    (if tasks are waiting).
    567          *                           OS_OPT_POST_ALL          POST to ALL tasks that are waiting on the semaphore
    568          *
    569          *                           OS_OPT_POST_NO_SCHED     Do not call the scheduler
    570          *
    571          *                           Note(s): 1) OS_OPT_POST_NO_SCHED can be added with one of the other options.
    572          *
    573          *              p_err    is a pointer to a variable that will contain an error code returned by this function.
    574          *
    575          *                           OS_ERR_NONE          The call was successful and the semaphore was signaled.
    576          *                           OS_ERR_OBJ_PTR_NULL  If 'p_sem' is a NULL pointer.
    577          *                           OS_ERR_OBJ_TYPE      If 'p_sem' is not pointing at a semaphore
    578          *                           OS_ERR_SEM_OVF       If the post would cause the semaphore count to overflow.
    579          *
    580          * Returns    : The current value of the semaphore counter or 0 upon error.
    581          ************************************************************************************************************************
    582          */
    583          

   \                                 In section .text, align 2, keep-with-next
    584          OS_SEM_CTR  OSSemPost (OS_SEM  *p_sem,
    585                                 OS_OPT   opt,
    586                                 OS_ERR  *p_err)
    587          {
   \                     OSSemPost: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0013             MOVS     R3,R2
    588              OS_SEM_CTR  ctr;
    589              CPU_TS      ts;
    590          
    591          
    592          
    593          #ifdef OS_SAFETY_CRITICAL
    594              if (p_err == (OS_ERR *)0) {
    595                  OS_SAFETY_CRITICAL_EXCEPTION();
    596                  return ((OS_SEM_CTR)0);
    597              }
    598          #endif
    599          
    600          #if OS_CFG_ARG_CHK_EN > 0u
    601              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD103             BNE      ??OSSemPost_0
    602                 *p_err  = OS_ERR_OBJ_PTR_NULL;
   \        0xA   0x....             LDR      R0,??DataTable9  ;; 0x5dc3
   \        0xC   0x8018             STRH     R0,[R3, #+0]
    603                  return ((OS_SEM_CTR)0);
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xE031             B        ??OSSemPost_1
    604              }
    605              switch (opt) {                                          /* Validate 'opt'                                         */
   \                     ??OSSemPost_0: (+1)
   \       0x12   0x000A             MOVS     R2,R1
   \       0x14   0xB292             UXTH     R2,R2
   \       0x16   0x2A00             CMP      R2,#+0
   \       0x18   0xD00B             BEQ      ??OSSemPost_2
   \       0x1A   0x2480             MOVS     R4,#+128
   \       0x1C   0x00A4             LSLS     R4,R4,#+2        ;; #+512
   \       0x1E   0x42A2             CMP      R2,R4
   \       0x20   0xD007             BEQ      ??OSSemPost_2
   \       0x22   0x2480             MOVS     R4,#+128
   \       0x24   0x0224             LSLS     R4,R4,#+8        ;; #+32768
   \       0x26   0x42A2             CMP      R2,R4
   \       0x28   0xD003             BEQ      ??OSSemPost_2
   \       0x2A   0x2482             MOVS     R4,#+130
   \       0x2C   0x0224             LSLS     R4,R4,#+8        ;; #+33280
   \       0x2E   0x42A2             CMP      R2,R4
   \       0x30   0xD116             BNE      ??OSSemPost_3
    606                  case OS_OPT_POST_1:
    607                  case OS_OPT_POST_ALL:
    608                  case OS_OPT_POST_1   | OS_OPT_POST_NO_SCHED:
    609                  case OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
    610                       break;
    611          
    612                  default:
    613                      *p_err =  OS_ERR_OPT_INVALID;
    614                       return ((OS_SEM_CTR)0u);
    615              }
    616          #endif
    617          
    618          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    619              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
   \                     ??OSSemPost_2: (+1)
   \       0x32   0x....             LDR      R4,??DataTable9_1  ;; 0x414d4553
   \       0x34   0x6802             LDR      R2,[R0, #+0]
   \       0x36   0x42A2             CMP      R2,R4
   \       0x38   0xD116             BNE      ??OSSemPost_4
    620                 *p_err = OS_ERR_OBJ_TYPE;
    621                  return ((OS_SEM_CTR)0);
    622              }
    623          #endif
    624          
    625              ts = OS_TS_GET();                                       /* Get timestamp                                          */
   \       0x3A   0x2200             MOVS     R2,#+0
    626          
    627          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    628              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
   \       0x3C   0x....             LDR      R5,??DataTable8_2
   \       0x3E   0x782D             LDRB     R5,[R5, #+0]
   \       0x40   0x2D00             CMP      R5,#+0
   \       0x42   0xD015             BEQ      ??OSSemPost_5
    629                  OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_SEM,           /* Post to ISR queue                                      */
    630                              (void      *)p_sem,
    631                              (void      *)0,
    632                              (OS_MSG_SIZE)0,
    633                              (OS_FLAGS   )0,
    634                              (OS_OPT     )opt,
    635                              (CPU_TS     )ts,
    636                              (OS_ERR    *)p_err);
   \       0x44   0x9303             STR      R3,[SP, #+12]
   \       0x46   0x9202             STR      R2,[SP, #+8]
   \       0x48   0xB289             UXTH     R1,R1
   \       0x4A   0x9101             STR      R1,[SP, #+4]
   \       0x4C   0x2100             MOVS     R1,#+0
   \       0x4E   0x9100             STR      R1,[SP, #+0]
   \       0x50   0x2300             MOVS     R3,#+0
   \       0x52   0x2200             MOVS     R2,#+0
   \       0x54   0x0001             MOVS     R1,R0
   \       0x56   0x0020             MOVS     R0,R4
   \       0x58   0x....'....        BL       OS_IntQPost
    637                  return ((OS_SEM_CTR)0);
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0xE00A             B        ??OSSemPost_1
    638              }
   \                     ??OSSemPost_3: (+1)
   \       0x60   0x....             LDR      R0,??DataTable3_1  ;; 0x5e25
   \       0x62   0x8018             STRH     R0,[R3, #+0]
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xE006             B        ??OSSemPost_1
   \                     ??OSSemPost_4: (+1)
   \       0x68   0x....             LDR      R0,??DataTable9_2  ;; 0x5dc4
   \       0x6A   0x8018             STRH     R0,[R3, #+0]
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0xE002             B        ??OSSemPost_1
    639          #endif
    640          
    641              ctr = OS_SemPost(p_sem,                                 /* Post to semaphore                                      */
    642                               opt,
    643                               ts,
    644                               p_err);
   \                     ??OSSemPost_5: (+1)
   \       0x70   0xB289             UXTH     R1,R1
   \       0x72   0x....'....        BL       OS_SemPost
    645          
    646              return (ctr);
   \                     ??OSSemPost_1: (+1)
   \       0x76   0xB005             ADD      SP,SP,#+20
   \       0x78   0xBD30             POP      {R4,R5,PC}       ;; return
    647          }
    648          
    649          /*$PAGE*/
    650          /*
    651          ************************************************************************************************************************
    652          *                                                    SET SEMAPHORE
    653          *
    654          * Description: This function sets the semaphore count to the value specified as an argument.  Typically, this value
    655          *              would be 0 but of course, we can set the semaphore to any value.
    656          *
    657          *              You would typically use this function when a semaphore is used as a signaling mechanism
    658          *              and, you want to reset the count value.
    659          *
    660          * Arguments  : p_sem     is a pointer to the semaphore
    661          *
    662          *              cnt       is the new value for the semaphore count.  You would pass 0 to reset the semaphore count.
    663          *
    664          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    665          *
    666          *                            OS_ERR_NONE           The call was successful and the semaphore value was set.
    667          *                            OS_ERR_OBJ_PTR_NULL   If 'p_sem' is a NULL pointer.
    668          *                            OS_ERR_OBJ_TYPE       If 'p_sem' is not pointing to a semaphore.
    669          *                            OS_ERR_TASK_WAITING   If tasks are waiting on the semaphore.
    670          *
    671          * Returns    : None
    672          ************************************************************************************************************************
    673          */
    674          
    675          #if OS_CFG_SEM_SET_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    676          void  OSSemSet (OS_SEM      *p_sem,
    677                          OS_SEM_CTR   cnt,
    678                          OS_ERR      *p_err)
    679          {
   \                     OSSemSet: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x000C             MOVS     R4,R1
   \        0x4   0x0015             MOVS     R5,R2
    680              OS_PEND_LIST  *p_pend_list;
    681              CPU_SR_ALLOC();
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x000A             MOVS     R2,R1
    682          
    683          
    684          
    685          #ifdef OS_SAFETY_CRITICAL
    686              if (p_err == (OS_ERR *)0) {
    687                  OS_SAFETY_CRITICAL_EXCEPTION();
    688                  return;
    689              }
    690          #endif
    691          
    692          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    693              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
   \        0xA   0x....             LDR      R2,??DataTable8_2
   \        0xC   0x7812             LDRB     R2,[R2, #+0]
   \        0xE   0x2A00             CMP      R2,#+0
   \       0x10   0xD002             BEQ      ??OSSemSet_0
    694                 *p_err = OS_ERR_SET_ISR;
   \       0x12   0x....             LDR      R0,??DataTable9_3  ;; 0x6dc6
   \       0x14   0x8028             STRH     R0,[R5, #+0]
    695                  return;
   \       0x16   0xE01F             B        ??OSSemSet_1
    696              }
   \                     ??OSSemSet_0: (+1)
   \       0x18   0x0006             MOVS     R6,R0
    697          #endif
    698          
    699          #if OS_CFG_ARG_CHK_EN > 0u
    700              if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
   \       0x1A   0x2E00             CMP      R6,#+0
   \       0x1C   0xD102             BNE      ??OSSemSet_2
    701                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \       0x1E   0x....             LDR      R0,??DataTable9  ;; 0x5dc3
   \       0x20   0x8028             STRH     R0,[R5, #+0]
    702                  return;
   \       0x22   0xE019             B        ??OSSemSet_1
    703              }
    704          #endif
    705          
    706          #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    707              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
   \                     ??OSSemSet_2: (+1)
   \       0x24   0x6830             LDR      R0,[R6, #+0]
   \       0x26   0x....             LDR      R2,??DataTable9_1  ;; 0x414d4553
   \       0x28   0x4290             CMP      R0,R2
   \       0x2A   0xD002             BEQ      ??OSSemSet_3
    708                 *p_err = OS_ERR_OBJ_TYPE;
   \       0x2C   0x....             LDR      R0,??DataTable9_2  ;; 0x5dc4
   \       0x2E   0x8028             STRH     R0,[R5, #+0]
    709                  return;
   \       0x30   0xE012             B        ??OSSemSet_1
    710              }
    711          #endif
    712          
    713             *p_err = OS_ERR_NONE;
   \                     ??OSSemSet_3: (+1)
   \       0x32   0x8029             STRH     R1,[R5, #+0]
    714              CPU_CRITICAL_ENTER();
   \       0x34   0x....'....        BL       CPU_SR_Save
    715              if (p_sem->Ctr > (OS_SEM_CTR)0) {                       /* See if semaphore already has a count                   */
   \       0x38   0x6A31             LDR      R1,[R6, #+32]
   \       0x3A   0x2900             CMP      R1,#+0
   \       0x3C   0xD001             BEQ      ??OSSemSet_4
    716                  p_sem->Ctr = cnt;                                   /* Yes, set it to the new value specified.                */
   \       0x3E   0x6234             STR      R4,[R6, #+32]
   \       0x40   0xE008             B        ??OSSemSet_5
    717              } else {
    718                  p_pend_list = &p_sem->PendList;                     /* No                                                     */
   \                     ??OSSemSet_4: (+1)
   \       0x42   0x0031             MOVS     R1,R6
   \       0x44   0x3108             ADDS     R1,R1,#+8
    719                  if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {     /*      See if task(s) waiting?                           */
   \       0x46   0x8909             LDRH     R1,[R1, #+8]
   \       0x48   0x2900             CMP      R1,#+0
   \       0x4A   0xD101             BNE      ??OSSemSet_6
    720                      p_sem->Ctr = cnt;                               /*      No, OK to set the value                           */
   \       0x4C   0x6234             STR      R4,[R6, #+32]
   \       0x4E   0xE001             B        ??OSSemSet_5
    721                  } else {
    722                     *p_err      = OS_ERR_TASK_WAITING;
   \                     ??OSSemSet_6: (+1)
   \       0x50   0x....             LDR      R1,??DataTable9_4  ;; 0x715f
   \       0x52   0x8029             STRH     R1,[R5, #+0]
    723                  }
    724              }
    725              CPU_CRITICAL_EXIT();
   \                     ??OSSemSet_5: (+1)
   \       0x54   0x....'....        BL       CPU_SR_Restore
    726          }
   \                     ??OSSemSet_1: (+1)
   \       0x58   0xBD70             POP      {R4-R6,PC}       ;; return
    727          #endif
    728          
    729          /*$PAGE*/
    730          /*
    731          ************************************************************************************************************************
    732          *                                           CLEAR THE CONTENTS OF A SEMAPHORE
    733          *
    734          * Description: This function is called by OSSemDel() to clear the contents of a semaphore
    735          *
    736          
    737          * Argument(s): p_sem      is a pointer to the semaphore to clear
    738          *              -----
    739          *
    740          * Returns    : none
    741          *
    742          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    743          ************************************************************************************************************************
    744          */
    745          

   \                                 In section .text, align 2, keep-with-next
    746          void  OS_SemClr (OS_SEM  *p_sem)
    747          {
   \                     OS_SemClr: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    748              p_sem->Type    = OS_OBJ_TYPE_NONE;                      /* Mark the data structure as a NONE                      */
   \        0x2   0x....             LDR      R1,??DataTable9_5  ;; 0x454e4f4e
   \        0x4   0x6001             STR      R1,[R0, #+0]
    749              p_sem->Ctr     = (OS_SEM_CTR)0;                         /* Set semaphore value                                    */
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x6201             STR      R1,[R0, #+32]
    750              p_sem->TS      = (CPU_TS    )0;                         /* Clear the time stamp                                   */
   \        0xA   0x6241             STR      R1,[R0, #+36]
    751              p_sem->NamePtr = (CPU_CHAR *)((void *)"?SEM");
   \        0xC   0x....             LDR      R1,??DataTable9_6
   \        0xE   0x6041             STR      R1,[R0, #+4]
    752              OS_PendListInit(&p_sem->PendList);                      /* Initialize the waiting list                            */
   \       0x10   0x3008             ADDS     R0,R0,#+8
   \       0x12   0x....'....        BL       OS_PendListInit
    753          }
   \       0x16   0xBD01             POP      {R0,PC}          ;; return
    754          
    755          /*$PAGE*/
    756          /*
    757          ************************************************************************************************************************
    758          *                                        ADD/REMOVE SEMAPHORE TO/FROM DEBUG LIST
    759          *
    760          * Description: These functions are called by uC/OS-III to add or remove a semaphore to/from the debug list.
    761          *
    762          * Arguments  : p_sem     is a pointer to the semaphore to add/remove
    763          *
    764          * Returns    : none
    765          *
    766          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
    767          ************************************************************************************************************************
    768          */
    769          
    770          
    771          #if OS_CFG_DBG_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    772          void  OS_SemDbgListAdd (OS_SEM  *p_sem)
    773          {
   \                     OS_SemDbgListAdd: (+1)
   \        0x0   0xB500             PUSH     {LR}
    774              p_sem->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
   \        0x2   0x....             ADR      R1,??DataTable9_7  ;; " "
   \        0x4   0x61C1             STR      R1,[R0, #+28]
    775              p_sem->DbgPrevPtr               = (OS_SEM   *)0;
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x6141             STR      R1,[R0, #+20]
    776              if (OSSemDbgListPtr == (OS_SEM *)0) {
   \        0xA   0x....             LDR      R2,??DataTable9_8
   \        0xC   0x6813             LDR      R3,[R2, #+0]
   \        0xE   0x2B00             CMP      R3,#+0
   \       0x10   0xD101             BNE      ??OS_SemDbgListAdd_0
    777                  p_sem->DbgNextPtr           = (OS_SEM   *)0;
   \       0x12   0x6181             STR      R1,[R0, #+24]
   \       0x14   0xE003             B        ??OS_SemDbgListAdd_1
    778              } else {
    779                  p_sem->DbgNextPtr           =  OSSemDbgListPtr;
   \                     ??OS_SemDbgListAdd_0: (+1)
   \       0x16   0x6811             LDR      R1,[R2, #+0]
   \       0x18   0x6181             STR      R1,[R0, #+24]
    780                  OSSemDbgListPtr->DbgPrevPtr =  p_sem;
   \       0x1A   0x6811             LDR      R1,[R2, #+0]
   \       0x1C   0x6148             STR      R0,[R1, #+20]
    781              }
    782              OSSemDbgListPtr                 =  p_sem;
   \                     ??OS_SemDbgListAdd_1: (+1)
   \       0x1E   0x6010             STR      R0,[R2, #+0]
    783          }
   \       0x20   0xBD00             POP      {PC}             ;; return
    784          
    785          
    786          

   \                                 In section .text, align 2, keep-with-next
    787          void  OS_SemDbgListRemove (OS_SEM  *p_sem)
    788          {
   \                     OS_SemDbgListRemove: (+1)
   \        0x0   0xB500             PUSH     {LR}
    789              OS_SEM  *p_sem_next;
    790              OS_SEM  *p_sem_prev;
    791          
    792          
    793              p_sem_prev = p_sem->DbgPrevPtr;
   \        0x2   0x6942             LDR      R2,[R0, #+20]
    794              p_sem_next = p_sem->DbgNextPtr;
   \        0x4   0x6981             LDR      R1,[R0, #+24]
    795          
    796              if (p_sem_prev == (OS_SEM *)0) {
   \        0x6   0x2A00             CMP      R2,#+0
   \        0x8   0xD108             BNE      ??OS_SemDbgListRemove_0
    797                  OSSemDbgListPtr = p_sem_next;
   \        0xA   0x....             LDR      R2,??DataTable9_8
   \        0xC   0x6011             STR      R1,[R2, #+0]
    798                  if (p_sem_next != (OS_SEM *)0) {
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD001             BEQ      ??OS_SemDbgListRemove_1
    799                      p_sem_next->DbgPrevPtr = (OS_SEM *)0;
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0x614A             STR      R2,[R1, #+20]
    800                  }
    801                  p_sem->DbgNextPtr = (OS_SEM *)0;
   \                     ??OS_SemDbgListRemove_1: (+1)
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0x6181             STR      R1,[R0, #+24]
   \       0x1A   0xE00A             B        ??OS_SemDbgListRemove_2
    802          
    803              } else if (p_sem_next == (OS_SEM *)0) {
   \                     ??OS_SemDbgListRemove_0: (+1)
   \       0x1C   0x2900             CMP      R1,#+0
   \       0x1E   0xD103             BNE      ??OS_SemDbgListRemove_3
    804                  p_sem_prev->DbgNextPtr = (OS_SEM *)0;
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x6191             STR      R1,[R2, #+24]
    805                  p_sem->DbgPrevPtr      = (OS_SEM *)0;
   \       0x24   0x6141             STR      R1,[R0, #+20]
   \       0x26   0xE004             B        ??OS_SemDbgListRemove_2
    806          
    807              } else {
    808                  p_sem_prev->DbgNextPtr =  p_sem_next;
   \                     ??OS_SemDbgListRemove_3: (+1)
   \       0x28   0x6191             STR      R1,[R2, #+24]
    809                  p_sem_next->DbgPrevPtr =  p_sem_prev;
   \       0x2A   0x614A             STR      R2,[R1, #+20]
    810                  p_sem->DbgNextPtr      = (OS_SEM *)0;
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x6181             STR      R1,[R0, #+24]
    811                  p_sem->DbgPrevPtr      = (OS_SEM *)0;
   \       0x30   0x6141             STR      R1,[R0, #+20]
    812              }
    813          }
   \                     ??OS_SemDbgListRemove_2: (+1)
   \       0x32   0xBD00             POP      {PC}             ;; return
    814          #endif
    815          
    816          /*$PAGE*/
    817          /*
    818          ************************************************************************************************************************
    819          *                                                SEMAPHORE INITIALIZATION
    820          *
    821          * Description: This function is called by OSInit() to initialize the semaphore management.
    822          *
    823          
    824          * Argument(s): p_err        is a pointer to a variable that will contain an error code returned by this function.
    825          *
    826          *                                OS_ERR_NONE     the call was successful
    827          *
    828          * Returns    : none
    829          *
    830          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    831          ************************************************************************************************************************
    832          */
    833          

   \                                 In section .text, align 2, keep-with-next
    834          void  OS_SemInit (OS_ERR  *p_err)
    835          {
    836          #ifdef OS_SAFETY_CRITICAL
    837              if (p_err == (OS_ERR *)0) {
    838                  OS_SAFETY_CRITICAL_EXCEPTION();
    839                  return;
    840              }
    841          #endif
    842          
    843          #if OS_CFG_DBG_EN > 0u
    844              OSSemDbgListPtr = (OS_SEM *)0;
   \                     OS_SemInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x....             LDR      R2,??DataTable9_8
   \        0x4   0x6011             STR      R1,[R2, #+0]
    845          #endif
    846          
    847              OSSemQty        = (OS_OBJ_QTY)0;
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x....             LDR      R2,??DataTable9_9
   \        0xA   0x8011             STRH     R1,[R2, #+0]
    848             *p_err           = OS_ERR_NONE;
   \        0xC   0x8001             STRH     R1,[R0, #+0]
    849          }
   \        0xE   0x4770             BX       LR               ;; return
    850          
    851          /*$PAGE*/
    852          /*
    853          ************************************************************************************************************************
    854          *                                                 POST TO A SEMAPHORE
    855          *
    856          * Description: This function signals a semaphore
    857          *
    858          * Arguments  : p_sem    is a pointer to the semaphore
    859          *
    860          *              opt      determines the type of POST performed:
    861          *
    862          *                           OS_OPT_POST_1            POST to a single waiting task
    863          *                           OS_OPT_POST_ALL          POST to ALL tasks that are waiting on the semaphore
    864          *
    865          *                           OS_OPT_POST_NO_SCHED     Do not call the scheduler
    866          *
    867          *                           Note(s): 1) OS_OPT_POST_NO_SCHED can be added with one of the other options.
    868          *
    869          *              ts       is a timestamp indicating when the post occurred.
    870          *
    871          *              p_err    is a pointer to a variable that will contain an error code returned by this function.
    872          *
    873          *                           OS_ERR_NONE          The call was successful and the semaphore was signaled.
    874          *                           OS_ERR_OBJ_PTR_NULL  If 'p_sem' is a NULL pointer.
    875          *                           OS_ERR_OBJ_TYPE      If 'p_sem' is not pointing at a semaphore
    876          *                           OS_ERR_SEM_OVF       If the post would cause the semaphore count to overflow.
    877          *
    878          * Returns    : The current value of the semaphore counter or 0 upon error.
    879          *
    880          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    881          ************************************************************************************************************************
    882          */
    883          

   \                                 In section .text, align 2, keep-with-next
    884          OS_SEM_CTR  OS_SemPost (OS_SEM  *p_sem,
    885                                  OS_OPT   opt,
    886                                  CPU_TS   ts,
    887                                  OS_ERR  *p_err)
    888          {
   \                     OS_SemPost: (+1)
   \        0x0   0xB5FC             PUSH     {R2-R7,LR}
   \        0x2   0xB083             SUB      SP,SP,#+12
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0017             MOVS     R7,R2
    889              OS_OBJ_QTY     cnt;
    890              OS_SEM_CTR     ctr;
    891              OS_PEND_LIST  *p_pend_list;
    892              OS_PEND_DATA  *p_pend_data;
    893              OS_PEND_DATA  *p_pend_data_next;
    894              OS_TCB        *p_tcb;
    895              CPU_SR_ALLOC();
   \        0xA   0x2600             MOVS     R6,#+0
   \        0xC   0x0030             MOVS     R0,R6
    896          
    897          
    898          
    899              CPU_CRITICAL_ENTER();
   \        0xE   0x....'....        BL       CPU_SR_Save
    900              p_pend_list = &p_sem->PendList;
   \       0x12   0x0029             MOVS     R1,R5
   \       0x14   0x3108             ADDS     R1,R1,#+8
   \       0x16   0x9100             STR      R1,[SP, #+0]
    901              if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {         /* Any task waiting on semaphore?                         */
   \       0x18   0x9900             LDR      R1,[SP, #+0]
   \       0x1A   0x8909             LDRH     R1,[R1, #+8]
   \       0x1C   0x2900             CMP      R1,#+0
   \       0x1E   0xD116             BNE      ??OS_SemPost_0
    902                  switch (sizeof(OS_SEM_CTR)) {
    903                      case 1u:
    904                           if (p_sem->Ctr == DEF_INT_08U_MAX_VAL) {
    905                               CPU_CRITICAL_EXIT();
    906                              *p_err = OS_ERR_SEM_OVF;
    907                               return ((OS_SEM_CTR)0);
    908                           }
    909                           break;
    910          
    911                      case 2u:
    912                           if (p_sem->Ctr == DEF_INT_16U_MAX_VAL) {
    913                               CPU_CRITICAL_EXIT();
    914                              *p_err = OS_ERR_SEM_OVF;
    915                               return ((OS_SEM_CTR)0);
    916                           }
    917                           break;
    918          
    919                      case 4u:
    920                           if (p_sem->Ctr == DEF_INT_32U_MAX_VAL) {
   \       0x20   0x6A29             LDR      R1,[R5, #+32]
   \       0x22   0x2200             MOVS     R2,#+0
   \       0x24   0x43D2             MVNS     R2,R2            ;; #-1
   \       0x26   0x4291             CMP      R1,R2
   \       0x28   0xD106             BNE      ??OS_SemPost_1
    921                               CPU_CRITICAL_EXIT();
   \       0x2A   0x....'....        BL       CPU_SR_Restore
    922                              *p_err = OS_ERR_SEM_OVF;
   \       0x2E   0x....             LDR      R0,??DataTable9_10  ;; 0x6dc5
   \       0x30   0x9904             LDR      R1,[SP, #+16]
   \       0x32   0x8008             STRH     R0,[R1, #+0]
    923                               return ((OS_SEM_CTR)0);
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xE03F             B        ??OS_SemPost_2
    924                           }
    925                           break;
    926          
    927                      default:
    928                           break;
    929                  }
    930                  p_sem->Ctr++;                                       /* No                                                     */
   \                     ??OS_SemPost_1: (+1)
   \       0x38   0x6A29             LDR      R1,[R5, #+32]
   \       0x3A   0x1C49             ADDS     R1,R1,#+1
   \       0x3C   0x6229             STR      R1,[R5, #+32]
    931                  ctr       = p_sem->Ctr;
   \       0x3E   0x6A2C             LDR      R4,[R5, #+32]
    932                  p_sem->TS = ts;                                     /* Save timestamp in semaphore control block              */
   \       0x40   0x626F             STR      R7,[R5, #+36]
    933                  CPU_CRITICAL_EXIT();
   \       0x42   0x....'....        BL       CPU_SR_Restore
    934                 *p_err     = OS_ERR_NONE;
   \       0x46   0x9804             LDR      R0,[SP, #+16]
   \       0x48   0x8006             STRH     R6,[R0, #+0]
    935                  return (ctr);
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0xE034             B        ??OS_SemPost_2
    936              }
   \                     ??OS_SemPost_0: (+1)
   \       0x4E   0x4669             MOV      R1,SP
   \       0x50   0x808C             STRH     R4,[R1, #+4]
    937          
    938              OS_CRITICAL_ENTER_CPU_EXIT();
   \       0x52   0x....             LDR      R1,??DataTable9_11
   \       0x54   0x7809             LDRB     R1,[R1, #+0]
   \       0x56   0x1C49             ADDS     R1,R1,#+1
   \       0x58   0x....             LDR      R2,??DataTable9_11
   \       0x5A   0x7011             STRB     R1,[R2, #+0]
   \       0x5C   0x....'....        BL       CPU_SR_Restore
    939              if ((opt & OS_OPT_POST_ALL) != (OS_OPT)0) {             /* Post message to all tasks waiting?                     */
   \       0x60   0x4668             MOV      R0,SP
   \       0x62   0x8880             LDRH     R0,[R0, #+4]
   \       0x64   0x0580             LSLS     R0,R0,#+22
   \       0x66   0xD502             BPL      ??OS_SemPost_3
    940                  cnt = p_pend_list->NbrEntries;                      /* Yes                                                    */
   \       0x68   0x9800             LDR      R0,[SP, #+0]
   \       0x6A   0x8904             LDRH     R4,[R0, #+8]
   \       0x6C   0xE000             B        ??OS_SemPost_4
    941              } else {
    942                  cnt = (OS_OBJ_QTY)1;                                /* No                                                     */
   \                     ??OS_SemPost_3: (+1)
   \       0x6E   0x2401             MOVS     R4,#+1
    943              }
    944              p_pend_data = p_pend_list->HeadPtr;
   \                     ??OS_SemPost_4: (+1)
   \       0x70   0x9800             LDR      R0,[SP, #+0]
   \       0x72   0x6800             LDR      R0,[R0, #+0]
   \       0x74   0xE00A             B        ??OS_SemPost_5
    945              while (cnt > 0u) {
    946                  p_tcb            = p_pend_data->TCBPtr;
   \                     ??OS_SemPost_6: (+1)
   \       0x76   0x6881             LDR      R1,[R0, #+8]
    947                  p_pend_data_next = p_pend_data->NextPtr;
   \       0x78   0x6840             LDR      R0,[R0, #+4]
   \       0x7A   0x9002             STR      R0,[SP, #+8]
    948                  OS_Post((OS_PEND_OBJ *)((void *)p_sem),
    949                          p_tcb,
    950                          (void      *)0,
    951                          (OS_MSG_SIZE)0,
    952                          ts);
   \       0x7C   0x9700             STR      R7,[SP, #+0]
   \       0x7E   0x2300             MOVS     R3,#+0
   \       0x80   0x2200             MOVS     R2,#+0
   \       0x82   0x0028             MOVS     R0,R5
   \       0x84   0x....'....        BL       OS_Post
    953                  p_pend_data = p_pend_data_next;
   \       0x88   0x9802             LDR      R0,[SP, #+8]
    954                  cnt--;
   \       0x8A   0x1E64             SUBS     R4,R4,#+1
    955              }
   \                     ??OS_SemPost_5: (+1)
   \       0x8C   0x0021             MOVS     R1,R4
   \       0x8E   0xB289             UXTH     R1,R1
   \       0x90   0x2900             CMP      R1,#+0
   \       0x92   0xD1F0             BNE      ??OS_SemPost_6
    956              ctr = p_sem->Ctr;
   \       0x94   0x6A2C             LDR      R4,[R5, #+32]
    957              OS_CRITICAL_EXIT_NO_SCHED();
   \       0x96   0x....'....        BL       CPU_SR_Save
   \       0x9A   0x....             LDR      R1,??DataTable9_11
   \       0x9C   0x780A             LDRB     R2,[R1, #+0]
   \       0x9E   0x1E52             SUBS     R2,R2,#+1
   \       0xA0   0x700A             STRB     R2,[R1, #+0]
   \       0xA2   0x....'....        BL       CPU_SR_Restore
    958              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
   \       0xA6   0x4668             MOV      R0,SP
   \       0xA8   0x8880             LDRH     R0,[R0, #+4]
   \       0xAA   0x0400             LSLS     R0,R0,#+16
   \       0xAC   0xD401             BMI      ??OS_SemPost_7
    959                  OSSched();                                          /* Run the scheduler                                      */
   \       0xAE   0x....'....        BL       OSSched
    960              }
    961             *p_err = OS_ERR_NONE;
   \                     ??OS_SemPost_7: (+1)
   \       0xB2   0x9804             LDR      R0,[SP, #+16]
   \       0xB4   0x8006             STRH     R6,[R0, #+0]
    962              return (ctr);
   \       0xB6   0x0020             MOVS     R0,R4
   \                     ??OS_SemPost_2: (+1)
   \       0xB8   0xB005             ADD      SP,SP,#+20
   \       0xBA   0xBDF0             POP      {R4-R7,PC}       ;; return
    963          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x....'....        DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x0000'2EE1        DC32     0x2ee1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x0000'5DC3        DC32     0x5dc3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x....'....        DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x414D'4553        DC32     0x414d4553

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \        0x0   0x0000'61AE        DC32     0x61ae

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x....'....        DC32     OSSemQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x0000'5E25        DC32     0x5e25

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x0000'5DC4        DC32     0x5dc4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x0000'61B0        DC32     0x61b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x0000'6D63        DC32     0x6d63

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x....'....        DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x0000'61A9        DC32     0x61a9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x0000'72D9        DC32     0x72d9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x0000'5DC2        DC32     0x5dc2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x0000'6E2E        DC32     0x6e2e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x....'....        DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x0000'61AA        DC32     0x61aa

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x0000'61AB        DC32     0x61ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x0000'5DC3        DC32     0x5dc3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x414D'4553        DC32     0x414d4553

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x0000'5DC4        DC32     0x5dc4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \        0x0   0x0000'6DC6        DC32     0x6dc6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \        0x0   0x0000'715F        DC32     0x715f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \        0x0   0x454E'4F4E        DC32     0x454e4f4e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \        0x0   0x20 0x00          DC8      " ",0x0,0x0

   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \        0x0   0x....'....        DC32     OSSemDbgListPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \        0x0   0x....'....        DC32     OSSemQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \        0x0   0x0000'6DC5        DC32     0x6dc5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \        0x0   0x....'....        DC32     OSSchedLockNestingCtr

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x3F 0x53          DC8 "?SEM"

   \              0x45 0x4D    

   \              0x00
   \        0x5                      DS8 3

   \                                 In section .rodata, align 2
   \        0x0   0x20 0x00          DC8 " "
    964          
    965          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   OSSemCreate
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OS_PendListInit
        32   -> OS_SemDbgListAdd
      64   OSSemPend
        64   -> CPU_SR_Restore
        64   -> CPU_SR_Save
        64   -> OSSched
        64   -> OS_Pend
      32   OSSemPendAbort
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_PendAbort
      32   OSSemPost
        32   -> OS_IntQPost
        32   -> OS_SemPost
      16   OSSemSet
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
       8   OS_SemClr
         8   -> OS_PendListInit
       4   OS_SemDbgListAdd
       4   OS_SemDbgListRemove
       0   OS_SemInit
      40   OS_SemPost
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> OSSched
        40   -> OS_Post


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable4
       4  ??DataTable5
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
       8  ?_0
       2  ?_1
     108  OSSemCreate
     336  OSSemPend
     216  OSSemPendAbort
     122  OSSemPost
      90  OSSemSet
      24  OS_SemClr
      34  OS_SemDbgListAdd
      52  OS_SemDbgListRemove
      16  OS_SemInit
     188  OS_SemPost

 
    10 bytes in section .rodata
 1'310 bytes in section .text
 
 1'310 bytes of CODE  memory
    10 bytes of CONST memory

Errors: none
Warnings: none
