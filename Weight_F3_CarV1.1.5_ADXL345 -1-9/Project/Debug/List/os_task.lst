###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.4.261/W32 for ARM         10/Jan/2021  16:10:21
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Source\System\uCOS-III\Source\os_task.c
#    Command line      =
#        -f C:\Users\macanlin\AppData\Local\Temp\EWEC80.tmp
#        ("C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Source\System\uCOS-III\Source\os_task.c" -D USE_STDPERIPH_DRIVER
#        -D STM32F072 -lC
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\List" -o
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        C:\rj\IAR\arm\inc\c\DLib_Config_Normal.h -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\BSP\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\FWLib\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\CMSIS\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\OS_Cfg\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-CPU\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-LIB\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uCOS-III\Ports\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uCOS-III\Source\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\APP\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\FWLib\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-LIB\\" -Ol -I
#        C:\rj\IAR\arm\CMSIS\Core\Include\\ -I
#        C:\rj\IAR\arm\CMSIS\DSP\Include\\)
#    Locale            =  C
#    List file         =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\List\os_task.lst
#    Object file       =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\Obj\os_task.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#
###############################################################################

C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345 -1-9\Source\System\uCOS-III\Source\os_task.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2012; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                   TASK MANAGEMENT
     10          *
     11          * File    : OS_TASK.C
     12          * By      : JJL
     13          * Version : V3.03.01
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #define  MICRIUM_SOURCE
     34          #include <os.h>
     35          
     36          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     37          const  CPU_CHAR  *os_task__c = "$Id: $";
     38          #endif
     39          
     40          /*
     41          ************************************************************************************************************************
     42          *                                                CHANGE PRIORITY OF A TASK
     43          *
     44          * Description: This function allows you to change the priority of a task dynamically.  Note that the new
     45          *              priority MUST be available.
     46          *
     47          * Arguments  : p_tcb      is the TCB of the tack to change the priority for
     48          *
     49          *              prio_new   is the new priority
     50          *
     51          *              p_err      is a pointer to an error code returned by this function:
     52          *
     53          *                             OS_ERR_NONE                 is the call was successful
     54          *                             OS_ERR_PRIO_INVALID         if the priority you specify is higher that the maximum allowed
     55          *                                                         (i.e. >= (OS_CFG_PRIO_MAX-1))
     56          *                             OS_ERR_STATE_INVALID        if the task is in an invalid state
     57          *                             OS_ERR_TASK_CHANGE_PRIO_ISR if you tried to change the task's priority from an ISR
     58          ************************************************************************************************************************
     59          */
     60          
     61          #if OS_CFG_TASK_CHANGE_PRIO_EN > 0u

   \                                 In section .text, align 2, keep-with-next
     62          void  OSTaskChangePrio (OS_TCB   *p_tcb,
     63                                  OS_PRIO   prio_new,
     64                                  OS_ERR   *p_err)
     65          {
   \                     OSTaskChangePrio: (+1)
   \        0x0   0xB5F4             PUSH     {R2,R4-R7,LR}
     66              CPU_BOOLEAN   self;
     67              CPU_SR_ALLOC();
   \        0x2   0x2200             MOVS     R2,#+0
     68          
     69          
     70          
     71          #ifdef OS_SAFETY_CRITICAL
     72              if (p_err == (OS_ERR *)0) {
     73                  OS_SAFETY_CRITICAL_EXCEPTION();
     74                  return;
     75              }
     76          #endif
     77          
     78          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
     79              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ---------- CANNOT CREATE A TASK FROM AN ISR ---------- */
   \        0x4   0x....             LDR      R2,??DataTable0
   \        0x6   0x7812             LDRB     R2,[R2, #+0]
   \        0x8   0x2A00             CMP      R2,#+0
   \        0xA   0xD003             BEQ      ??OSTaskChangePrio_0
     80                 *p_err = OS_ERR_TASK_CHANGE_PRIO_ISR;
   \        0xC   0x....             LDR      R0,??DataTable0_1  ;; 0x7149
   \        0xE   0x9900             LDR      R1,[SP, #+0]
   \       0x10   0x8008             STRH     R0,[R1, #+0]
     81                  return;
   \       0x12   0xE053             B        ??OSTaskChangePrio_1
     82              }
   \                     ??OSTaskChangePrio_0: (+1)
   \       0x14   0x000C             MOVS     R4,R1
     83          #endif
     84          
     85          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
     86              if (prio_new == 0) {                                    /* Cannot set to IntQueue Task priority                   */
   \       0x16   0x0021             MOVS     R1,R4
   \       0x18   0xB2C9             UXTB     R1,R1
   \       0x1A   0x2900             CMP      R1,#+0
   \       0x1C   0xD103             BNE      ??OSTaskChangePrio_2
     87                 *p_err = OS_ERR_PRIO_INVALID;
   \       0x1E   0x....             LDR      R0,??DataTable0_2  ;; 0x6273
   \       0x20   0x9900             LDR      R1,[SP, #+0]
   \       0x22   0x8008             STRH     R0,[R1, #+0]
     88                  return;
   \       0x24   0xE04A             B        ??OSTaskChangePrio_1
     89              }
     90          #endif
     91          
     92              if (prio_new >= (OS_CFG_PRIO_MAX - 1u)) {               /* Cannot set to Idle Task priority                       */
   \                     ??OSTaskChangePrio_2: (+1)
   \       0x26   0x0021             MOVS     R1,R4
   \       0x28   0xB2C9             UXTB     R1,R1
   \       0x2A   0x290F             CMP      R1,#+15
   \       0x2C   0xD303             BCC      ??OSTaskChangePrio_3
     93                 *p_err = OS_ERR_PRIO_INVALID;
   \       0x2E   0x....             LDR      R0,??DataTable0_2  ;; 0x6273
   \       0x30   0x9900             LDR      R1,[SP, #+0]
   \       0x32   0x8008             STRH     R0,[R1, #+0]
     94                  return;
   \       0x34   0xE042             B        ??OSTaskChangePrio_1
     95              }
   \                     ??OSTaskChangePrio_3: (+1)
   \       0x36   0x0005             MOVS     R5,R0
     96          
     97              if (p_tcb == (OS_TCB *)0) {                             /* See if want to change priority of 'self'               */
   \       0x38   0x2D00             CMP      R5,#+0
   \       0x3A   0xD107             BNE      ??OSTaskChangePrio_4
     98                  CPU_CRITICAL_ENTER();
   \       0x3C   0x....'....        BL       CPU_SR_Save
     99                  p_tcb = OSTCBCurPtr;
   \       0x40   0x....             LDR      R1,??DataTable0_3
   \       0x42   0x680D             LDR      R5,[R1, #+0]
    100                  CPU_CRITICAL_EXIT();
   \       0x44   0x....'....        BL       CPU_SR_Restore
    101                  self  = DEF_TRUE;
   \       0x48   0x2601             MOVS     R6,#+1
   \       0x4A   0xE000             B        ??OSTaskChangePrio_5
    102              } else {
    103                  self  = DEF_FALSE;
   \                     ??OSTaskChangePrio_4: (+1)
   \       0x4C   0x2600             MOVS     R6,#+0
    104              }
    105          
    106              OS_CRITICAL_ENTER();
   \                     ??OSTaskChangePrio_5: (+1)
   \       0x4E   0x....'....        BL       CPU_SR_Save
   \       0x52   0x....             LDR      R7,??DataTable1
   \       0x54   0x7839             LDRB     R1,[R7, #+0]
   \       0x56   0x1C49             ADDS     R1,R1,#+1
   \       0x58   0x7039             STRB     R1,[R7, #+0]
   \       0x5A   0x....'....        BL       CPU_SR_Restore
    107              switch (p_tcb->TaskState) {
   \       0x5E   0x2036             MOVS     R0,#+54
   \       0x60   0x5C28             LDRB     R0,[R5, R0]
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD00B             BEQ      ??OSTaskChangePrio_6
   \       0x66   0x2802             CMP      R0,#+2
   \       0x68   0xD02C             BEQ      ??OSTaskChangePrio_7
   \       0x6A   0xD328             BCC      ??OSTaskChangePrio_8
   \       0x6C   0x2804             CMP      R0,#+4
   \       0x6E   0xD026             BEQ      ??OSTaskChangePrio_8
   \       0x70   0xD328             BCC      ??OSTaskChangePrio_7
   \       0x72   0x2806             CMP      R0,#+6
   \       0x74   0xD026             BEQ      ??OSTaskChangePrio_7
   \       0x76   0xD322             BCC      ??OSTaskChangePrio_8
   \       0x78   0x2807             CMP      R0,#+7
   \       0x7A   0xD023             BEQ      ??OSTaskChangePrio_7
   \       0x7C   0xE036             B        ??OSTaskChangePrio_9
    108                  case OS_TASK_STATE_RDY:
    109                       OS_RdyListRemove(p_tcb);                       /* Remove from current priority                           */
   \                     ??OSTaskChangePrio_6: (+1)
   \       0x7E   0x0028             MOVS     R0,R5
   \       0x80   0x....'....        BL       OS_RdyListRemove
    110                       p_tcb->Prio = prio_new;                        /* Set new task priority                                  */
   \       0x84   0x2037             MOVS     R0,#+55
   \       0x86   0x542C             STRB     R4,[R5, R0]
    111                       OS_PrioInsert(p_tcb->Prio);
   \       0x88   0x2037             MOVS     R0,#+55
   \       0x8A   0x5C28             LDRB     R0,[R5, R0]
   \       0x8C   0x....'....        BL       OS_PrioInsert
    112                       if (self == DEF_TRUE) {
   \       0x90   0xB2F6             UXTB     R6,R6
   \       0x92   0x2E01             CMP      R6,#+1
   \       0x94   0xD103             BNE      ??OSTaskChangePrio_10
    113                           OS_RdyListInsertHead(p_tcb);
   \       0x96   0x0028             MOVS     R0,R5
   \       0x98   0x....'....        BL       OS_RdyListInsertHead
   \       0x9C   0xE002             B        ??OSTaskChangePrio_11
    114                       } else {
    115                           OS_RdyListInsertTail(p_tcb);
   \                     ??OSTaskChangePrio_10: (+1)
   \       0x9E   0x0028             MOVS     R0,R5
   \       0xA0   0x....'....        BL       OS_RdyListInsertTail
    116                       }
    117                       break;
    118          
    119                  case OS_TASK_STATE_DLY:                             /* Nothing to do except change the priority in the OS_TCB */
    120                  case OS_TASK_STATE_SUSPENDED:
    121                  case OS_TASK_STATE_DLY_SUSPENDED:
    122                       p_tcb->Prio = prio_new;                        /* Set new task priority                                  */
    123                       break;
    124          
    125                  case OS_TASK_STATE_PEND:
    126                  case OS_TASK_STATE_PEND_TIMEOUT:
    127                  case OS_TASK_STATE_PEND_SUSPENDED:
    128                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    129                       switch (p_tcb->PendOn) {                       /* What to do depends on what we are pending on           */
    130                           case OS_TASK_PEND_ON_TASK_Q:               /* Nothing to do except change the priority in the OS_TCB */
    131                           case OS_TASK_PEND_ON_TASK_SEM:
    132                           case OS_TASK_PEND_ON_FLAG:
    133                                p_tcb->Prio = prio_new;               /* Set new task priority                                  */
    134                                break;
    135          
    136                           case OS_TASK_PEND_ON_MUTEX:
    137                           case OS_TASK_PEND_ON_MULTI:
    138                           case OS_TASK_PEND_ON_Q:
    139                           case OS_TASK_PEND_ON_SEM:
    140                                OS_PendListChangePrio(p_tcb,
    141                                                      prio_new);
    142                                break;
    143          
    144                           default:
    145                                break;
    146                      }
    147                       break;
    148          
    149                  default:
    150                       OS_CRITICAL_EXIT();
    151                      *p_err = OS_ERR_STATE_INVALID;
    152                       return;
    153              }
    154          
    155              OS_CRITICAL_EXIT_NO_SCHED();
   \                     ??OSTaskChangePrio_11: (+1)
   \                     ??OSTaskChangePrio_12: (+1)
   \       0xA4   0x....'....        BL       CPU_SR_Save
   \       0xA8   0x7839             LDRB     R1,[R7, #+0]
   \       0xAA   0x1E49             SUBS     R1,R1,#+1
   \       0xAC   0x7039             STRB     R1,[R7, #+0]
   \       0xAE   0x....'....        BL       CPU_SR_Restore
    156          
    157              OSSched();                                              /* Run highest priority task ready                        */
   \       0xB2   0x....'....        BL       OSSched
    158          
    159             *p_err = OS_ERR_NONE;
   \       0xB6   0x2000             MOVS     R0,#+0
   \       0xB8   0x9900             LDR      R1,[SP, #+0]
   \       0xBA   0x8008             STRH     R0,[R1, #+0]
    160          }
   \                     ??OSTaskChangePrio_1: (+1)
   \       0xBC   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   \                     ??OSTaskChangePrio_8: (+1)
   \       0xBE   0x2037             MOVS     R0,#+55
   \       0xC0   0x542C             STRB     R4,[R5, R0]
   \       0xC2   0xE7EF             B        ??OSTaskChangePrio_12
   \                     ??OSTaskChangePrio_7: (+1)
   \       0xC4   0x2034             MOVS     R0,#+52
   \       0xC6   0x5C28             LDRB     R0,[R5, R0]
   \       0xC8   0x1E40             SUBS     R0,R0,#+1
   \       0xCA   0x2801             CMP      R0,#+1
   \       0xCC   0xD904             BLS      ??OSTaskChangePrio_13
   \       0xCE   0x1E80             SUBS     R0,R0,#+2
   \       0xD0   0x2803             CMP      R0,#+3
   \       0xD2   0xD904             BLS      ??OSTaskChangePrio_14
   \       0xD4   0x1F00             SUBS     R0,R0,#+4
   \       0xD6   0xD108             BNE      ??OSTaskChangePrio_15
   \                     ??OSTaskChangePrio_13: (+1)
   \       0xD8   0x2037             MOVS     R0,#+55
   \       0xDA   0x542C             STRB     R4,[R5, R0]
   \       0xDC   0xE005             B        ??OSTaskChangePrio_16
   \                     ??OSTaskChangePrio_14: (+1)
   \       0xDE   0x0021             MOVS     R1,R4
   \       0xE0   0xB2C9             UXTB     R1,R1
   \       0xE2   0x0028             MOVS     R0,R5
   \       0xE4   0x....'....        BL       OS_PendListChangePrio
   \       0xE8   0xE7FF             B        ??OSTaskChangePrio_16
   \                     ??OSTaskChangePrio_15: (+1)
   \                     ??OSTaskChangePrio_16: (+1)
   \       0xEA   0xE7DB             B        ??OSTaskChangePrio_12
   \                     ??OSTaskChangePrio_9: (+1)
   \       0xEC   0x....'....        BL       CPU_SR_Save
   \       0xF0   0x7839             LDRB     R1,[R7, #+0]
   \       0xF2   0x1E49             SUBS     R1,R1,#+1
   \       0xF4   0x7039             STRB     R1,[R7, #+0]
   \       0xF6   0x7839             LDRB     R1,[R7, #+0]
   \       0xF8   0x2900             CMP      R1,#+0
   \       0xFA   0xD10B             BNE      ??OSTaskChangePrio_17
   \       0xFC   0x....             LDR      R1,??DataTable1_1
   \       0xFE   0x8809             LDRH     R1,[R1, #+0]
   \      0x100   0x2900             CMP      R1,#+0
   \      0x102   0xD004             BEQ      ??OSTaskChangePrio_18
   \      0x104   0x....'....        BL       CPU_SR_Restore
   \      0x108   0x....'....        BL       OS_Sched0
   \      0x10C   0xE004             B        ??OSTaskChangePrio_19
   \                     ??OSTaskChangePrio_18: (+1)
   \      0x10E   0x....'....        BL       CPU_SR_Restore
   \      0x112   0xE001             B        ??OSTaskChangePrio_19
   \                     ??OSTaskChangePrio_17: (+1)
   \      0x114   0x....'....        BL       CPU_SR_Restore
   \                     ??OSTaskChangePrio_19: (+1)
   \      0x118   0x....             LDR      R0,??DataTable1_2  ;; 0x6e2d
   \      0x11A   0x9900             LDR      R1,[SP, #+0]
   \      0x11C   0x8008             STRH     R0,[R1, #+0]
   \      0x11E   0xE7CD             B        ??OSTaskChangePrio_1
    161          #endif
    162          
    163          /*$PAGE*/
    164          /*
    165          ************************************************************************************************************************
    166          *                                                    CREATE A TASK
    167          *
    168          * Description: This function is used to have uC/OS-III manage the execution of a task.  Tasks can either be created
    169          *              prior to the start of multitasking or by a running task.  A task cannot be created by an ISR.
    170          *
    171          * Arguments  : p_tcb          is a pointer to the task's TCB
    172          *
    173          *              p_name         is a pointer to an ASCII string to provide a name to the task.
    174          *
    175          *              p_task         is a pointer to the task's code
    176          *
    177          *              p_arg          is a pointer to an optional data area which can be used to pass parameters to
    178          *                             the task when the task first executes.  Where the task is concerned it thinks
    179          *                             it was invoked and passed the argument 'p_arg' as follows:
    180          *
    181          *                                 void Task (void *p_arg)
    182          *                                 {
    183          *                                     for (;;) {
    184          *                                         Task code;
    185          *                                     }
    186          *                                 }
    187          *
    188          *              prio           is the task's priority.  A unique priority MUST be assigned to each task and the
    189          *                             lower the number, the higher the priority.
    190          *
    191          *              p_stk_base     is a pointer to the base address of the stack (i.e. low address).
    192          *
    193          *              stk_limit      is the number of stack elements to set as 'watermark' limit for the stack.  This value
    194          *                             represents the number of CPU_STK entries left before the stack is full.  For example,
    195          *                             specifying 10% of the 'stk_size' value indicates that the stack limit will be reached
    196          *                             when the stack reaches 90% full.
    197          *
    198          *              stk_size       is the size of the stack in number of elements.  If CPU_STK is set to CPU_INT08U,
    199          *                             'stk_size' corresponds to the number of bytes available.  If CPU_STK is set to
    200          *                             CPU_INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
    201          *                             CPU_STK is set to CPU_INT32U, 'stk_size' contains the number of 32-bit entries
    202          *                             available on the stack.
    203          *
    204          *              q_size         is the maximum number of messages that can be sent to the task
    205          *
    206          *              time_quanta    amount of time (in ticks) for time slice when round-robin between tasks.  Specify 0 to use
    207          *                             the default.
    208          *
    209          *              p_ext          is a pointer to a user supplied memory location which is used as a TCB extension.
    210          *                             For example, this user memory can hold the contents of floating-point registers
    211          *                             during a context switch, the time each task takes to execute, the number of times
    212          *                             the task has been switched-in, etc.
    213          *
    214          *              opt            contains additional information (or options) about the behavior of the task.
    215          *                             See OS_OPT_TASK_xxx in OS.H.  Current choices are:
    216          *
    217          *                                 OS_OPT_TASK_NONE            No option selected
    218          *                                 OS_OPT_TASK_STK_CHK         Stack checking to be allowed for the task
    219          *                                 OS_OPT_TASK_STK_CLR         Clear the stack when the task is created
    220          *                                 OS_OPT_TASK_SAVE_FP         If the CPU has floating-point registers, save them
    221          *                                                             during a context switch.
    222          *                                 OS_OPT_TASK_NO_TLS          If the caller doesn't want or need TLS (Thread Local 
    223          *                                                             Storage) support for the task.  If you do not include this
    224          *                                                             option, TLS will be supported by default.
    225          *
    226          *              p_err          is a pointer to an error code that will be set during this call.  The value pointer
    227          *                             to by 'p_err' can be:
    228          *
    229          *                                 OS_ERR_NONE                    if the function was successful.
    230          *                                 OS_ERR_ILLEGAL_CREATE_RUN_TIME if you are trying to create the task after you called
    231          *                                                                   OSSafetyCriticalStart().
    232          *                                 OS_ERR_NAME                    if 'p_name' is a NULL pointer
    233          *                                 OS_ERR_PRIO_INVALID            if the priority you specify is higher that the maximum
    234          *                                                                   allowed (i.e. >= OS_CFG_PRIO_MAX-1) or,
    235          *                                                                if OS_CFG_ISR_POST_DEFERRED_EN is set to 1 and you tried
    236          *                                                                   to use priority 0 which is reserved.
    237          *                                 OS_ERR_STK_INVALID             if you specified a NULL pointer for 'p_stk_base'
    238          *                                 OS_ERR_STK_SIZE_INVALID        if you specified zero for the 'stk_size'
    239          *                                 OS_ERR_STK_LIMIT_INVALID       if you specified a 'stk_limit' greater than or equal
    240          *                                                                   to 'stk_size'
    241          *                                 OS_ERR_TASK_CREATE_ISR         if you tried to create a task from an ISR.
    242          *                                 OS_ERR_TASK_INVALID            if you specified a NULL pointer for 'p_task'
    243          *                                 OS_ERR_TCB_INVALID             if you specified a NULL pointer for 'p_tcb'
    244          *
    245          * Returns    : A pointer to the TCB of the task created.  This pointer must be used as an ID (i.e handle) to the task.
    246          ************************************************************************************************************************
    247          */
    248          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
    249          void  OSTaskCreate (OS_TCB        *p_tcb,
    250                              CPU_CHAR      *p_name,
    251                              OS_TASK_PTR    p_task,
    252                              void          *p_arg,
    253                              OS_PRIO        prio,
    254                              CPU_STK       *p_stk_base,
    255                              CPU_STK_SIZE   stk_limit,
    256                              CPU_STK_SIZE   stk_size,
    257                              OS_MSG_QTY     q_size,
    258                              OS_TICK        time_quanta,
    259                              void          *p_ext,
    260                              OS_OPT         opt,
    261                              OS_ERR        *p_err)
    262          {
   \                     OSTaskCreate: (+1)
   \        0x0   0xB5FB             PUSH     {R0,R1,R3-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x9E14             LDR      R6,[SP, #+80]
    263              CPU_STK_SIZE   i;
    264          #if OS_CFG_TASK_REG_TBL_SIZE > 0u
    265              OS_REG_ID      reg_nbr;
    266          #endif
    267          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    268              OS_TLS_ID      id;
    269          #endif
    270          
    271              CPU_STK       *p_sp;
    272              CPU_STK       *p_stk_limit;
    273              CPU_SR_ALLOC();
   \        0x6   0x2100             MOVS     R1,#+0
    274          
    275          
    276          
    277          #ifdef OS_SAFETY_CRITICAL
    278              if (p_err == (OS_ERR *)0) {
    279                  OS_SAFETY_CRITICAL_EXCEPTION();
    280                  return;
    281              }
    282          #endif
    283          
    284          #ifdef OS_SAFETY_CRITICAL_IEC61508
    285              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    286                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
    287                  return;
    288              }
    289          #endif
    290          
    291          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    292              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ---------- CANNOT CREATE A TASK FROM AN ISR ---------- */
   \        0x8   0x....             LDR      R1,??DataTable1_3
   \        0xA   0x7809             LDRB     R1,[R1, #+0]
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD002             BEQ      ??OSTaskCreate_0
    293                 *p_err = OS_ERR_TASK_CREATE_ISR;
   \       0x10   0x....             LDR      R0,??DataTable1_4  ;; 0x714a
   \       0x12   0x8030             STRH     R0,[R6, #+0]
    294                  return;
   \       0x14   0xE0CE             B        ??OSTaskCreate_1
    295              }
   \                     ??OSTaskCreate_0: (+1)
   \       0x16   0x0004             MOVS     R4,R0
    296          #endif
    297          
    298          #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
    299              if (p_tcb == (OS_TCB *)0) {                             /* User must supply a valid OS_TCB                        */
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD102             BNE      ??OSTaskCreate_2
    300                 *p_err = OS_ERR_TCB_INVALID;
   \       0x1C   0x....             LDR      R0,??DataTable1_5  ;; 0x71ad
   \       0x1E   0x8030             STRH     R0,[R6, #+0]
    301                  return;
   \       0x20   0xE0C8             B        ??OSTaskCreate_1
    302              }
   \                     ??OSTaskCreate_2: (+1)
   \       0x22   0x9202             STR      R2,[SP, #+8]
    303              if (p_task == (OS_TASK_PTR)0) {                         /* User must supply a valid task                          */
   \       0x24   0x9802             LDR      R0,[SP, #+8]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD102             BNE      ??OSTaskCreate_3
    304                 *p_err = OS_ERR_TASK_INVALID;
   \       0x2A   0x....             LDR      R0,??DataTable1_6  ;; 0x714f
   \       0x2C   0x8030             STRH     R0,[R6, #+0]
    305                  return;
   \       0x2E   0xE0C1             B        ??OSTaskCreate_1
    306              }
   \                     ??OSTaskCreate_3: (+1)
   \       0x30   0x9F0D             LDR      R7,[SP, #+52]
    307              if (p_stk_base == (CPU_STK *)0) {                       /* User must supply a valid stack base address            */
   \       0x32   0x2F00             CMP      R7,#+0
   \       0x34   0xD102             BNE      ??OSTaskCreate_4
    308                 *p_err = OS_ERR_STK_INVALID;
   \       0x36   0x....             LDR      R0,??DataTable1_7  ;; 0x6e2f
   \       0x38   0x8030             STRH     R0,[R6, #+0]
    309                  return;
   \       0x3A   0xE0BB             B        ??OSTaskCreate_1
    310              }
   \                     ??OSTaskCreate_4: (+1)
   \       0x3C   0x9D0F             LDR      R5,[SP, #+60]
    311              if (stk_size < OSCfg_StkSizeMin) {                      /* User must supply a valid minimum stack size            */
   \       0x3E   0x....             LDR      R0,??DataTable1_8
   \       0x40   0x6800             LDR      R0,[R0, #+0]
   \       0x42   0x4285             CMP      R5,R0
   \       0x44   0xD202             BCS      ??OSTaskCreate_5
    312                 *p_err = OS_ERR_STK_SIZE_INVALID;
   \       0x46   0x....             LDR      R0,??DataTable1_9  ;; 0x6e30
   \       0x48   0x8030             STRH     R0,[R6, #+0]
    313                  return;
   \       0x4A   0xE0B3             B        ??OSTaskCreate_1
    314              }
    315              if (stk_limit >= stk_size) {                            /* User must supply a valid stack limit                   */
   \                     ??OSTaskCreate_5: (+1)
   \       0x4C   0x980E             LDR      R0,[SP, #+56]
   \       0x4E   0x42A8             CMP      R0,R5
   \       0x50   0xD302             BCC      ??OSTaskCreate_6
    316                 *p_err = OS_ERR_STK_LIMIT_INVALID;
   \       0x52   0x....             LDR      R0,??DataTable1_10  ;; 0x6e31
   \       0x54   0x8030             STRH     R0,[R6, #+0]
    317                  return;
   \       0x56   0xE0AD             B        ??OSTaskCreate_1
    318              }
    319              if (prio >= OS_CFG_PRIO_MAX) {                          /* Priority must be within 0 and OS_CFG_PRIO_MAX-1        */
   \                     ??OSTaskCreate_6: (+1)
   \       0x58   0xA80C             ADD      R0,SP,#+48
   \       0x5A   0x7800             LDRB     R0,[R0, #+0]
   \       0x5C   0x2810             CMP      R0,#+16
   \       0x5E   0xD302             BCC      ??OSTaskCreate_7
    320                 *p_err = OS_ERR_PRIO_INVALID;
   \       0x60   0x....             LDR      R0,??DataTable2  ;; 0x6273
   \       0x62   0x8030             STRH     R0,[R6, #+0]
    321                  return;
   \       0x64   0xE0A6             B        ??OSTaskCreate_1
    322              }
    323          #endif
    324          
    325          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    326              if (prio == (OS_PRIO)0) {
   \                     ??OSTaskCreate_7: (+1)
   \       0x66   0xA80C             ADD      R0,SP,#+48
   \       0x68   0x7800             LDRB     R0,[R0, #+0]
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD105             BNE      ??OSTaskCreate_8
    327                  if (p_tcb != &OSIntQTaskTCB) {
   \       0x6E   0x....             LDR      R0,??DataTable2_1
   \       0x70   0x4284             CMP      R4,R0
   \       0x72   0xD002             BEQ      ??OSTaskCreate_8
    328                     *p_err = OS_ERR_PRIO_INVALID;                    /* Not allowed to use priority 0                          */
   \       0x74   0x....             LDR      R0,??DataTable2  ;; 0x6273
   \       0x76   0x8030             STRH     R0,[R6, #+0]
    329                      return;
   \       0x78   0xE09C             B        ??OSTaskCreate_1
    330                  }
    331              }
    332          #endif
    333          
    334              if (prio == (OS_CFG_PRIO_MAX - 1u)) {
   \                     ??OSTaskCreate_8: (+1)
   \       0x7A   0xA80C             ADD      R0,SP,#+48
   \       0x7C   0x7800             LDRB     R0,[R0, #+0]
   \       0x7E   0x280F             CMP      R0,#+15
   \       0x80   0xD105             BNE      ??OSTaskCreate_9
    335                  if (p_tcb != &OSIdleTaskTCB) {
   \       0x82   0x....             LDR      R0,??DataTable2_2
   \       0x84   0x4284             CMP      R4,R0
   \       0x86   0xD002             BEQ      ??OSTaskCreate_9
    336                     *p_err = OS_ERR_PRIO_INVALID;                    /* Not allowed to use same priority as idle task          */
   \       0x88   0x....             LDR      R0,??DataTable2  ;; 0x6273
   \       0x8A   0x8030             STRH     R0,[R6, #+0]
    337                      return;
   \       0x8C   0xE092             B        ??OSTaskCreate_1
    338                  }
    339              }
    340          
    341              OS_TaskInitTCB(p_tcb);                                  /* Initialize the TCB to default values                   */
   \                     ??OSTaskCreate_9: (+1)
   \       0x8E   0x0020             MOVS     R0,R4
   \       0x90   0x....'....        BL       OS_TaskInitTCB
    342          
    343             *p_err = OS_ERR_NONE;
   \       0x94   0x2000             MOVS     R0,#+0
   \       0x96   0x8030             STRH     R0,[R6, #+0]
    344                                                                      /* --------------- CLEAR THE TASK'S STACK --------------- */
    345              if ((opt & OS_OPT_TASK_STK_CHK) != (OS_OPT)0) {         /* See if stack checking has been enabled                 */
   \       0x98   0xA813             ADD      R0,SP,#+76
   \       0x9A   0x8800             LDRH     R0,[R0, #+0]
   \       0x9C   0x07C0             LSLS     R0,R0,#+31
   \       0x9E   0xD50C             BPL      ??OSTaskCreate_10
    346                  if ((opt & OS_OPT_TASK_STK_CLR) != (OS_OPT)0) {     /* See if stack needs to be cleared                       */
   \       0xA0   0xA813             ADD      R0,SP,#+76
   \       0xA2   0x8800             LDRH     R0,[R0, #+0]
   \       0xA4   0x0780             LSLS     R0,R0,#+30
   \       0xA6   0xD508             BPL      ??OSTaskCreate_10
    347                      p_sp = p_stk_base;
   \       0xA8   0x0039             MOVS     R1,R7
    348                      for (i = 0u; i < stk_size; i++) {               /* Stack grows from HIGH to LOW memory                    */
   \       0xAA   0x2200             MOVS     R2,#+0
   \       0xAC   0x0010             MOVS     R0,R2
   \       0xAE   0xE002             B        ??OSTaskCreate_11
    349                         *p_sp = (CPU_STK)0;                          /* Clear from bottom of stack and up!                     */
   \                     ??OSTaskCreate_12: (+1)
   \       0xB0   0x600A             STR      R2,[R1, #+0]
    350                          p_sp++;
   \       0xB2   0x1D09             ADDS     R1,R1,#+4
    351                      }
   \       0xB4   0x1C40             ADDS     R0,R0,#+1
   \                     ??OSTaskCreate_11: (+1)
   \       0xB6   0x42A8             CMP      R0,R5
   \       0xB8   0xD3FA             BCC      ??OSTaskCreate_12
   \                     ??OSTaskCreate_10: (+1)
   \       0xBA   0x9E11             LDR      R6,[SP, #+68]
    352                  }
    353              }
    354                                                                      /* ------- INITIALIZE THE STACK FRAME OF THE TASK ------- */
    355          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
    356              p_stk_limit = p_stk_base + stk_limit;
   \       0xBC   0x980E             LDR      R0,[SP, #+56]
   \       0xBE   0x2104             MOVS     R1,#+4
   \       0xC0   0x4348             MULS     R0,R1,R0
   \       0xC2   0x1838             ADDS     R0,R7,R0
   \       0xC4   0x9003             STR      R0,[SP, #+12]
    357          #else
    358              p_stk_limit = p_stk_base + (stk_size - 1u) - stk_limit;
    359          #endif
    360          
    361              p_sp = OSTaskStkInit(p_task,
    362                                   p_arg,
    363                                   p_stk_base,
    364                                   p_stk_limit,
    365                                   stk_size,
    366                                   opt);
   \       0xC6   0xA813             ADD      R0,SP,#+76
   \       0xC8   0x8800             LDRH     R0,[R0, #+0]
   \       0xCA   0x9001             STR      R0,[SP, #+4]
   \       0xCC   0x9500             STR      R5,[SP, #+0]
   \       0xCE   0x9B03             LDR      R3,[SP, #+12]
   \       0xD0   0x003A             MOVS     R2,R7
   \       0xD2   0x9906             LDR      R1,[SP, #+24]
   \       0xD4   0x9802             LDR      R0,[SP, #+8]
   \       0xD6   0x....'....        BL       OSTaskStkInit
    367          
    368                                                                      /* -------------- INITIALIZE THE TCB FIELDS ------------- */
    369              p_tcb->TaskEntryAddr = p_task;                          /* Save task entry point address                          */
   \       0xDA   0x9902             LDR      R1,[SP, #+8]
   \       0xDC   0x62A1             STR      R1,[R4, #+40]
    370              p_tcb->TaskEntryArg  = p_arg;                           /* Save task entry argument                               */
   \       0xDE   0x9906             LDR      R1,[SP, #+24]
   \       0xE0   0x62E1             STR      R1,[R4, #+44]
    371          
    372              p_tcb->NamePtr       = p_name;                          /* Save task name                                         */
   \       0xE2   0x9905             LDR      R1,[SP, #+20]
   \       0xE4   0x6221             STR      R1,[R4, #+32]
    373          
    374              p_tcb->Prio          = prio;                            /* Save the task's priority                               */
   \       0xE6   0xA90C             ADD      R1,SP,#+48
   \       0xE8   0x7809             LDRB     R1,[R1, #+0]
   \       0xEA   0x2237             MOVS     R2,#+55
   \       0xEC   0x54A1             STRB     R1,[R4, R2]
    375          
    376              p_tcb->StkPtr        = p_sp;                            /* Save the new top-of-stack pointer                      */
   \       0xEE   0x6020             STR      R0,[R4, #+0]
    377              p_tcb->StkLimitPtr   = p_stk_limit;                     /* Save the stack limit pointer                           */
   \       0xF0   0x9803             LDR      R0,[SP, #+12]
   \       0xF2   0x60A0             STR      R0,[R4, #+8]
    378          
    379              p_tcb->TimeQuanta    = time_quanta;                     /* Save the #ticks for time slice (0 means not sliced)    */
   \       0xF4   0x6566             STR      R6,[R4, #+84]
    380          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
    381              if (time_quanta == (OS_TICK)0) {
   \       0xF6   0x2E00             CMP      R6,#+0
   \       0xF8   0xD103             BNE      ??OSTaskCreate_13
    382                  p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
   \       0xFA   0x....             LDR      R0,??DataTable3
   \       0xFC   0x6800             LDR      R0,[R0, #+0]
   \       0xFE   0x65A0             STR      R0,[R4, #+88]
   \      0x100   0xE000             B        ??OSTaskCreate_14
    383              } else {
    384                  p_tcb->TimeQuantaCtr = time_quanta;
   \                     ??OSTaskCreate_13: (+1)
   \      0x102   0x65A6             STR      R6,[R4, #+88]
   \                     ??OSTaskCreate_14: (+1)
   \      0x104   0x9812             LDR      R0,[SP, #+72]
    385              }
    386          #endif
    387              p_tcb->ExtPtr        = p_ext;                           /* Save pointer to TCB extension                          */
   \      0x106   0x6060             STR      R0,[R4, #+4]
    388              p_tcb->StkBasePtr    = p_stk_base;                      /* Save pointer to the base address of the stack          */
   \      0x108   0x6267             STR      R7,[R4, #+36]
    389              p_tcb->StkSize       = stk_size;                        /* Save the stack size (in number of CPU_STK elements)    */
   \      0x10A   0x63A5             STR      R5,[R4, #+56]
    390              p_tcb->Opt           = opt;                             /* Save task options                                      */
   \      0x10C   0xA813             ADD      R0,SP,#+76
   \      0x10E   0x8800             LDRH     R0,[R0, #+0]
   \      0x110   0x87A0             STRH     R0,[R4, #+60]
    391          
    392          #if OS_CFG_TASK_REG_TBL_SIZE > 0u
    393              for (reg_nbr = 0u; reg_nbr < OS_CFG_TASK_REG_TBL_SIZE; reg_nbr++) {
   \      0x112   0x2100             MOVS     R1,#+0
   \      0x114   0x0008             MOVS     R0,R1
   \      0x116   0xE006             B        ??OSTaskCreate_15
    394                  p_tcb->RegTbl[reg_nbr] = (OS_REG)0;
   \                     ??OSTaskCreate_16: (+1)
   \      0x118   0x0002             MOVS     R2,R0
   \      0x11A   0xB2D2             UXTB     R2,R2
   \      0x11C   0x2304             MOVS     R3,#+4
   \      0x11E   0x435A             MULS     R2,R3,R2
   \      0x120   0x18A2             ADDS     R2,R4,R2
   \      0x122   0x67D1             STR      R1,[R2, #+124]
    395              }
   \      0x124   0x1C40             ADDS     R0,R0,#+1
   \                     ??OSTaskCreate_15: (+1)
   \      0x126   0x0002             MOVS     R2,R0
   \      0x128   0xB2D2             UXTB     R2,R2
   \      0x12A   0x2A00             CMP      R2,#+0
   \      0x12C   0xD0F4             BEQ      ??OSTaskCreate_16
   \      0x12E   0x9910             LDR      R1,[SP, #+64]
    396          #endif
    397          
    398          #if OS_CFG_TASK_Q_EN > 0u
    399              OS_MsgQInit(&p_tcb->MsgQ,                               /* Initialize the task's message queue                    */
    400                          q_size);
   \      0x130   0xB289             UXTH     R1,R1
   \      0x132   0x0020             MOVS     R0,R4
   \      0x134   0x3064             ADDS     R0,R0,#+100
   \      0x136   0x....'....        BL       OS_MsgQInit
    401          #else
    402              (void)&q_size;
    403          #endif
    404          
    405              OSTaskCreateHook(p_tcb);                                /* Call user defined hook                                 */
   \      0x13A   0x0020             MOVS     R0,R4
   \      0x13C   0x....'....        BL       OSTaskCreateHook
    406          
    407          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    408              for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
    409                  p_tcb->TLS_Tbl[id] = (OS_TLS)0;
    410              }
    411              OS_TLS_TaskCreate(p_tcb);                               /* Call TLS hook                                          */
    412          #endif
    413                                                                      /* --------------- ADD TASK TO READY LIST --------------- */
    414              OS_CRITICAL_ENTER();
   \      0x140   0x....'....        BL       CPU_SR_Save
   \      0x144   0x....             LDR      R5,??DataTable1
   \      0x146   0x7829             LDRB     R1,[R5, #+0]
   \      0x148   0x1C49             ADDS     R1,R1,#+1
   \      0x14A   0x7029             STRB     R1,[R5, #+0]
   \      0x14C   0x....'....        BL       CPU_SR_Restore
    415              OS_PrioInsert(p_tcb->Prio);
   \      0x150   0x2037             MOVS     R0,#+55
   \      0x152   0x5C20             LDRB     R0,[R4, R0]
   \      0x154   0x....'....        BL       OS_PrioInsert
    416              OS_RdyListInsertTail(p_tcb);
   \      0x158   0x0020             MOVS     R0,R4
   \      0x15A   0x....'....        BL       OS_RdyListInsertTail
    417          
    418          #if OS_CFG_DBG_EN > 0u
    419              OS_TaskDbgListAdd(p_tcb);
   \      0x15E   0x0020             MOVS     R0,R4
   \      0x160   0x....'....        BL       OS_TaskDbgListAdd
    420          #endif
    421          
    422              OSTaskQty++;                                            /* Increment the #tasks counter                           */
   \      0x164   0x....             LDR      R0,??DataTable3_1
   \      0x166   0x8801             LDRH     R1,[R0, #+0]
   \      0x168   0x1C49             ADDS     R1,R1,#+1
   \      0x16A   0x8001             STRH     R1,[R0, #+0]
    423          
    424              if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Return if multitasking has not started                 */
   \      0x16C   0x....             LDR      R0,??DataTable3_2
   \      0x16E   0x7800             LDRB     R0,[R0, #+0]
   \      0x170   0x2801             CMP      R0,#+1
   \      0x172   0xD016             BEQ      ??OSTaskCreate_17
    425                  OS_CRITICAL_EXIT();
   \      0x174   0x....'....        BL       CPU_SR_Save
   \      0x178   0x7829             LDRB     R1,[R5, #+0]
   \      0x17A   0x1E49             SUBS     R1,R1,#+1
   \      0x17C   0x7029             STRB     R1,[R5, #+0]
   \      0x17E   0x7829             LDRB     R1,[R5, #+0]
   \      0x180   0x2900             CMP      R1,#+0
   \      0x182   0xD10B             BNE      ??OSTaskCreate_18
   \      0x184   0x....             LDR      R1,??DataTable1_1
   \      0x186   0x8809             LDRH     R1,[R1, #+0]
   \      0x188   0x2900             CMP      R1,#+0
   \      0x18A   0xD004             BEQ      ??OSTaskCreate_19
   \      0x18C   0x....'....        BL       CPU_SR_Restore
   \      0x190   0x....'....        BL       OS_Sched0
   \      0x194   0xE004             B        ??OSTaskCreate_20
   \                     ??OSTaskCreate_19: (+1)
   \      0x196   0x....'....        BL       CPU_SR_Restore
   \      0x19A   0xE001             B        ??OSTaskCreate_20
   \                     ??OSTaskCreate_18: (+1)
   \      0x19C   0x....'....        BL       CPU_SR_Restore
    426                  return;
   \                     ??OSTaskCreate_20: (+1)
   \      0x1A0   0xE008             B        ??OSTaskCreate_1
    427              }
    428          
    429              OS_CRITICAL_EXIT_NO_SCHED();
   \                     ??OSTaskCreate_17: (+1)
   \      0x1A2   0x....'....        BL       CPU_SR_Save
   \      0x1A6   0x7829             LDRB     R1,[R5, #+0]
   \      0x1A8   0x1E49             SUBS     R1,R1,#+1
   \      0x1AA   0x7029             STRB     R1,[R5, #+0]
   \      0x1AC   0x....'....        BL       CPU_SR_Restore
    430          
    431              OSSched();
   \      0x1B0   0x....'....        BL       OSSched
    432          }
   \                     ??OSTaskCreate_1: (+1)
   \      0x1B4   0xB007             ADD      SP,SP,#+28
   \      0x1B6   0xBDF0             POP      {R4-R7,PC}       ;; return
    433          
    434          /*$PAGE*/
    435          /*
    436          ************************************************************************************************************************
    437          *                                                     DELETE A TASK
    438          *
    439          * Description: This function allows you to delete a task.  The calling task can delete itself by specifying a NULL
    440          *              pointer for 'p_tcb'.  The deleted task is returned to the dormant state and can be re-activated by
    441          *              creating the deleted task again.
    442          *
    443          * Arguments  : p_tcb      is the TCB of the tack to delete
    444          *
    445          *              p_err      is a pointer to an error code returned by this function:
    446          *
    447          *                             OS_ERR_NONE                  if the call is successful
    448          *                             OS_ERR_STATE_INVALID         if the state of the task is invalid
    449          *                             OS_ERR_TASK_DEL_IDLE         if you attempted to delete uC/OS-III's idle task
    450          *                             OS_ERR_TASK_DEL_INVALID      if you attempted to delete uC/OS-III's ISR handler task
    451          *                             OS_ERR_TASK_DEL_ISR          if you tried to delete a task from an ISR
    452          *
    453          * Note(s)    : 1) 'p_err' gets set to OS_ERR_NONE before OSSched() to allow the returned error code to be monitored even
    454          *                 for a task that is deleting itself. In this case, 'p_err' MUST point to a global variable that can be
    455          *                 accessed by another task.
    456          ************************************************************************************************************************
    457          */
    458          
    459          #if OS_CFG_TASK_DEL_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    460          void  OSTaskDel (OS_TCB  *p_tcb,
    461                           OS_ERR  *p_err)
    462          {
   \                     OSTaskDel: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x000F             MOVS     R7,R1
    463              CPU_SR_ALLOC();
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x0021             MOVS     R1,R4
    464          
    465          
    466          
    467          #ifdef OS_SAFETY_CRITICAL
    468              if (p_err == (OS_ERR *)0) {
    469                  OS_SAFETY_CRITICAL_EXCEPTION();
    470                  return;
    471              }
    472          #endif
    473          
    474          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    475              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to delete from ISR                       */
   \        0x8   0x....             LDR      R1,??DataTable3_3
   \        0xA   0x7809             LDRB     R1,[R1, #+0]
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD002             BEQ      ??OSTaskDel_0
    476                 *p_err = OS_ERR_TASK_DEL_ISR;
   \       0x10   0x....             LDR      R0,??DataTable3_4  ;; 0x714e
   \       0x12   0x8038             STRH     R0,[R7, #+0]
    477                  return;
   \       0x14   0xE04D             B        ??OSTaskDel_1
    478              }
   \                     ??OSTaskDel_0: (+1)
   \       0x16   0x0005             MOVS     R5,R0
    479          #endif
    480          
    481              if (p_tcb == &OSIdleTaskTCB) {                          /* Not allowed to delete the idle task                    */
   \       0x18   0x....             LDR      R0,??DataTable2_2
   \       0x1A   0x4285             CMP      R5,R0
   \       0x1C   0xD102             BNE      ??OSTaskDel_2
    482                 *p_err = OS_ERR_TASK_DEL_IDLE;
   \       0x1E   0x....             LDR      R0,??DataTable3_5  ;; 0x714c
   \       0x20   0x8038             STRH     R0,[R7, #+0]
    483                  return;
   \       0x22   0xE046             B        ??OSTaskDel_1
    484              }
    485          
    486          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    487              if (p_tcb == &OSIntQTaskTCB) {                          /* Cannot delete the ISR handler task                     */
   \                     ??OSTaskDel_2: (+1)
   \       0x24   0x....             LDR      R0,??DataTable2_1
   \       0x26   0x4285             CMP      R5,R0
   \       0x28   0xD102             BNE      ??OSTaskDel_3
    488                 *p_err = OS_ERR_TASK_DEL_INVALID;
   \       0x2A   0x....             LDR      R0,??DataTable3_6  ;; 0x714d
   \       0x2C   0x8038             STRH     R0,[R7, #+0]
    489                  return;
   \       0x2E   0xE040             B        ??OSTaskDel_1
    490              }
    491          #endif
    492          
    493              if (p_tcb == (OS_TCB *)0) {                             /* Delete 'Self'?                                         */
   \                     ??OSTaskDel_3: (+1)
   \       0x30   0x2D00             CMP      R5,#+0
   \       0x32   0xD105             BNE      ??OSTaskDel_4
    494                  CPU_CRITICAL_ENTER();
   \       0x34   0x....'....        BL       CPU_SR_Save
    495                  p_tcb  = OSTCBCurPtr;                               /* Yes.                                                   */
   \       0x38   0x....             LDR      R1,??DataTable3_7
   \       0x3A   0x680D             LDR      R5,[R1, #+0]
    496                  CPU_CRITICAL_EXIT();
   \       0x3C   0x....'....        BL       CPU_SR_Restore
    497              }
    498          
    499              OS_CRITICAL_ENTER();
   \                     ??OSTaskDel_4: (+1)
   \       0x40   0x....'....        BL       CPU_SR_Save
   \       0x44   0x....             LDR      R6,??DataTable3_8
   \       0x46   0x7831             LDRB     R1,[R6, #+0]
   \       0x48   0x1C49             ADDS     R1,R1,#+1
   \       0x4A   0x7031             STRB     R1,[R6, #+0]
   \       0x4C   0x....'....        BL       CPU_SR_Restore
    500              switch (p_tcb->TaskState) {
   \       0x50   0x2036             MOVS     R0,#+54
   \       0x52   0x5C28             LDRB     R0,[R5, R0]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD00B             BEQ      ??OSTaskDel_5
   \       0x58   0x2802             CMP      R0,#+2
   \       0x5A   0xD030             BEQ      ??OSTaskDel_6
   \       0x5C   0xD32B             BCC      ??OSTaskDel_7
   \       0x5E   0x2804             CMP      R0,#+4
   \       0x60   0xD028             BEQ      ??OSTaskDel_8
   \       0x62   0xD32C             BCC      ??OSTaskDel_6
   \       0x64   0x2806             CMP      R0,#+6
   \       0x66   0xD02A             BEQ      ??OSTaskDel_6
   \       0x68   0xD325             BCC      ??OSTaskDel_7
   \       0x6A   0x2807             CMP      R0,#+7
   \       0x6C   0xD027             BEQ      ??OSTaskDel_6
   \       0x6E   0xE03C             B        ??OSTaskDel_9
    501                  case OS_TASK_STATE_RDY:
    502                       OS_RdyListRemove(p_tcb);
   \                     ??OSTaskDel_5: (+1)
   \       0x70   0x0028             MOVS     R0,R5
   \       0x72   0x....'....        BL       OS_RdyListRemove
    503                       break;
    504          
    505                  case OS_TASK_STATE_SUSPENDED:
    506                       break;
    507          
    508                  case OS_TASK_STATE_DLY:                             /* Task is only delayed, not on any wait list             */
    509                  case OS_TASK_STATE_DLY_SUSPENDED:
    510                       OS_TickListRemove(p_tcb);
    511                       break;
    512          
    513                  case OS_TASK_STATE_PEND:
    514                  case OS_TASK_STATE_PEND_SUSPENDED:
    515                  case OS_TASK_STATE_PEND_TIMEOUT:
    516                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    517                       OS_TickListRemove(p_tcb);
    518                       switch (p_tcb->PendOn) {                       /* See what we are pending on                             */
    519                           case OS_TASK_PEND_ON_NOTHING:
    520                           case OS_TASK_PEND_ON_TASK_Q:               /* There is no wait list for these two                    */
    521                           case OS_TASK_PEND_ON_TASK_SEM:
    522                                break;
    523          
    524                           case OS_TASK_PEND_ON_FLAG:                 /* Remove from wait list                                  */
    525                           case OS_TASK_PEND_ON_MULTI:
    526                           case OS_TASK_PEND_ON_MUTEX:
    527                           case OS_TASK_PEND_ON_Q:
    528                           case OS_TASK_PEND_ON_SEM:
    529                                OS_PendListRemove(p_tcb);
    530                                break;
    531          
    532                           default:
    533                                break;
    534                       }
    535                       break;
    536          
    537                  default:
    538                      OS_CRITICAL_EXIT();
    539                     *p_err = OS_ERR_STATE_INVALID;
    540                      return;
    541              }
    542          
    543          #if OS_CFG_TASK_Q_EN > 0u
    544              (void)OS_MsgQFreeAll(&p_tcb->MsgQ);                     /* Free task's message queue messages                     */
   \                     ??OSTaskDel_10: (+1)
   \       0x76   0x0028             MOVS     R0,R5
   \       0x78   0x3064             ADDS     R0,R0,#+100
   \       0x7A   0x....'....        BL       OS_MsgQFreeAll
    545          #endif
    546          
    547              OSTaskDelHook(p_tcb);                                   /* Call user defined hook                                 */
   \       0x7E   0x0028             MOVS     R0,R5
   \       0x80   0x....'....        BL       OSTaskDelHook
    548          
    549          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    550              OS_TLS_TaskDel(p_tcb);                                  /* Call TLS hook                                          */
    551          #endif
    552          
    553          #if OS_CFG_DBG_EN > 0u
    554              OS_TaskDbgListRemove(p_tcb);
   \       0x84   0x0028             MOVS     R0,R5
   \       0x86   0x....'....        BL       OS_TaskDbgListRemove
    555          #endif
    556              OSTaskQty--;                                            /* One less task being managed                            */
   \       0x8A   0x....             LDR      R0,??DataTable3_1
   \       0x8C   0x8801             LDRH     R1,[R0, #+0]
   \       0x8E   0x1E49             SUBS     R1,R1,#+1
   \       0x90   0x8001             STRH     R1,[R0, #+0]
    557          
    558              OS_TaskInitTCB(p_tcb);                                  /* Initialize the TCB to default values                   */
   \       0x92   0x0028             MOVS     R0,R5
   \       0x94   0x....'....        BL       OS_TaskInitTCB
    559              p_tcb->TaskState = (OS_STATE)OS_TASK_STATE_DEL;         /* Indicate that the task was deleted                     */
   \       0x98   0x20FF             MOVS     R0,#+255
   \       0x9A   0x2136             MOVS     R1,#+54
   \       0x9C   0x5468             STRB     R0,[R5, R1]
    560          
    561              OS_CRITICAL_EXIT_NO_SCHED();
   \       0x9E   0x....'....        BL       CPU_SR_Save
   \       0xA2   0x7831             LDRB     R1,[R6, #+0]
   \       0xA4   0x1E49             SUBS     R1,R1,#+1
   \       0xA6   0x7031             STRB     R1,[R6, #+0]
   \       0xA8   0x....'....        BL       CPU_SR_Restore
    562          
    563             *p_err = OS_ERR_NONE;                                    /* See Note #1.                                           */
   \       0xAC   0x803C             STRH     R4,[R7, #+0]
    564          
    565              OSSched();                                              /* Find new highest priority task                         */
   \       0xAE   0x....'....        BL       OSSched
    566          }
   \                     ??OSTaskDel_1: (+1)
   \       0xB2   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   \                     ??OSTaskDel_8: (+1)
   \       0xB4   0xE7DF             B        ??OSTaskDel_10
   \                     ??OSTaskDel_7: (+1)
   \       0xB6   0x0028             MOVS     R0,R5
   \       0xB8   0x....'....        BL       OS_TickListRemove
   \       0xBC   0xE7DB             B        ??OSTaskDel_10
   \                     ??OSTaskDel_6: (+1)
   \       0xBE   0x0028             MOVS     R0,R5
   \       0xC0   0x....'....        BL       OS_TickListRemove
   \       0xC4   0x2034             MOVS     R0,#+52
   \       0xC6   0x5C28             LDRB     R0,[R5, R0]
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xD008             BEQ      ??OSTaskDel_11
   \       0xCC   0x1E40             SUBS     R0,R0,#+1
   \       0xCE   0xD007             BEQ      ??OSTaskDel_12
   \       0xD0   0x1E40             SUBS     R0,R0,#+1
   \       0xD2   0xD004             BEQ      ??OSTaskDel_11
   \       0xD4   0x1E40             SUBS     R0,R0,#+1
   \       0xD6   0x2803             CMP      R0,#+3
   \       0xD8   0xD902             BLS      ??OSTaskDel_12
   \       0xDA   0x1F00             SUBS     R0,R0,#+4
   \       0xDC   0xD104             BNE      ??OSTaskDel_13
   \                     ??OSTaskDel_11: (+1)
   \       0xDE   0xE003             B        ??OSTaskDel_14
   \                     ??OSTaskDel_12: (+1)
   \       0xE0   0x0028             MOVS     R0,R5
   \       0xE2   0x....'....        BL       OS_PendListRemove
   \       0xE6   0xE7FF             B        ??OSTaskDel_14
   \                     ??OSTaskDel_13: (+1)
   \                     ??OSTaskDel_14: (+1)
   \       0xE8   0xE7C5             B        ??OSTaskDel_10
   \                     ??OSTaskDel_9: (+1)
   \       0xEA   0x....'....        BL       CPU_SR_Save
   \       0xEE   0x7831             LDRB     R1,[R6, #+0]
   \       0xF0   0x1E49             SUBS     R1,R1,#+1
   \       0xF2   0x7031             STRB     R1,[R6, #+0]
   \       0xF4   0x7831             LDRB     R1,[R6, #+0]
   \       0xF6   0x2900             CMP      R1,#+0
   \       0xF8   0xD10B             BNE      ??OSTaskDel_15
   \       0xFA   0x....             LDR      R1,??DataTable5
   \       0xFC   0x8809             LDRH     R1,[R1, #+0]
   \       0xFE   0x2900             CMP      R1,#+0
   \      0x100   0xD004             BEQ      ??OSTaskDel_16
   \      0x102   0x....'....        BL       CPU_SR_Restore
   \      0x106   0x....'....        BL       OS_Sched0
   \      0x10A   0xE004             B        ??OSTaskDel_17
   \                     ??OSTaskDel_16: (+1)
   \      0x10C   0x....'....        BL       CPU_SR_Restore
   \      0x110   0xE001             B        ??OSTaskDel_17
   \                     ??OSTaskDel_15: (+1)
   \      0x112   0x....'....        BL       CPU_SR_Restore
   \                     ??OSTaskDel_17: (+1)
   \      0x116   0x....             LDR      R0,??DataTable7  ;; 0x6e2d
   \      0x118   0x8038             STRH     R0,[R7, #+0]
   \      0x11A   0xE7CA             B        ??OSTaskDel_1
    567          #endif
    568          
    569          /*$PAGE*/
    570          /*
    571          ************************************************************************************************************************
    572          *                                                    FLUSH TASK's QUEUE
    573          *
    574          * Description: This function is used to flush the task's internal message queue.
    575          *
    576          * Arguments  : p_tcb       is a pointer to the task's OS_TCB.  Specifying a NULL pointer indicates that you wish to
    577          *                          flush the message queue of the calling task.
    578          *
    579          *              p_err       is a pointer to a variable that will contain an error code returned by this function.
    580          *
    581          *                              OS_ERR_NONE           upon success
    582          *                              OS_ERR_FLUSH_ISR      if you called this function from an ISR
    583          *
    584          * Returns     : The number of entries freed from the queue
    585          *
    586          * Note(s)     : 1) You should use this function with great care because, when to flush the queue, you LOOSE the
    587          *                  references to what the queue entries are pointing to and thus, you could cause 'memory leaks'.  In
    588          *                  other words, the data you are pointing to that's being referenced by the queue entries should, most
    589          *                  likely, need to be de-allocated (i.e. freed).
    590          ************************************************************************************************************************
    591          */
    592          
    593          #if OS_CFG_TASK_Q_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    594          OS_MSG_QTY  OSTaskQFlush (OS_TCB  *p_tcb,
    595                                    OS_ERR  *p_err)
    596          {
   \                     OSTaskQFlush: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x000F             MOVS     R7,R1
    597              OS_MSG_QTY  entries;
    598              CPU_SR_ALLOC();
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x0021             MOVS     R1,R4
    599          
    600          
    601          
    602          #ifdef OS_SAFETY_CRITICAL
    603              if (p_err == (OS_ERR *)0) {
    604                  OS_SAFETY_CRITICAL_EXCEPTION();
    605                  return ((OS_MSG_QTY)0);
    606              }
    607          #endif
    608          
    609          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    610              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't flush a message queue from an ISR                */
   \        0x8   0x....             LDR      R1,??DataTable3_3
   \        0xA   0x7809             LDRB     R1,[R1, #+0]
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD004             BEQ      ??OSTaskQFlush_0
    611                 *p_err = OS_ERR_FLUSH_ISR;
   \       0x10   0x20EC             MOVS     R0,#+236
   \       0x12   0x0180             LSLS     R0,R0,#+6        ;; #+15104
   \       0x14   0x8038             STRH     R0,[R7, #+0]
    612                  return ((OS_MSG_QTY)0);
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE02E             B        ??OSTaskQFlush_1
    613              }
   \                     ??OSTaskQFlush_0: (+1)
   \       0x1A   0x0006             MOVS     R6,R0
    614          #endif
    615          
    616              if (p_tcb == (OS_TCB *)0) {                             /* Flush message queue of calling task?                   */
   \       0x1C   0x2E00             CMP      R6,#+0
   \       0x1E   0xD105             BNE      ??OSTaskQFlush_2
    617                  CPU_CRITICAL_ENTER();
   \       0x20   0x....'....        BL       CPU_SR_Save
    618                  p_tcb = OSTCBCurPtr;
   \       0x24   0x....             LDR      R1,??DataTable3_7
   \       0x26   0x680E             LDR      R6,[R1, #+0]
    619                  CPU_CRITICAL_EXIT();
   \       0x28   0x....'....        BL       CPU_SR_Restore
    620              }
    621          
    622              OS_CRITICAL_ENTER();
   \                     ??OSTaskQFlush_2: (+1)
   \       0x2C   0x....'....        BL       CPU_SR_Save
   \       0x30   0x....             LDR      R5,??DataTable3_8
   \       0x32   0x7829             LDRB     R1,[R5, #+0]
   \       0x34   0x1C49             ADDS     R1,R1,#+1
   \       0x36   0x7029             STRB     R1,[R5, #+0]
   \       0x38   0x....'....        BL       CPU_SR_Restore
    623              entries = OS_MsgQFreeAll(&p_tcb->MsgQ);                 /* Return all OS_MSGs to the OS_MSG pool                  */
   \       0x3C   0x0030             MOVS     R0,R6
   \       0x3E   0x3064             ADDS     R0,R0,#+100
   \       0x40   0x....'....        BL       OS_MsgQFreeAll
   \       0x44   0x0006             MOVS     R6,R0
    624              OS_CRITICAL_EXIT();
   \       0x46   0x....'....        BL       CPU_SR_Save
   \       0x4A   0x7829             LDRB     R1,[R5, #+0]
   \       0x4C   0x1E49             SUBS     R1,R1,#+1
   \       0x4E   0x7029             STRB     R1,[R5, #+0]
   \       0x50   0x7829             LDRB     R1,[R5, #+0]
   \       0x52   0x2900             CMP      R1,#+0
   \       0x54   0xD10B             BNE      ??OSTaskQFlush_3
   \       0x56   0x....             LDR      R1,??DataTable5
   \       0x58   0x8809             LDRH     R1,[R1, #+0]
   \       0x5A   0x2900             CMP      R1,#+0
   \       0x5C   0xD004             BEQ      ??OSTaskQFlush_4
   \       0x5E   0x....'....        BL       CPU_SR_Restore
   \       0x62   0x....'....        BL       OS_Sched0
   \       0x66   0xE004             B        ??OSTaskQFlush_5
   \                     ??OSTaskQFlush_4: (+1)
   \       0x68   0x....'....        BL       CPU_SR_Restore
   \       0x6C   0xE001             B        ??OSTaskQFlush_5
   \                     ??OSTaskQFlush_3: (+1)
   \       0x6E   0x....'....        BL       CPU_SR_Restore
    625             *p_err   = OS_ERR_NONE;
   \                     ??OSTaskQFlush_5: (+1)
   \       0x72   0x803C             STRH     R4,[R7, #+0]
    626              return (entries);
   \       0x74   0x0030             MOVS     R0,R6
   \       0x76   0xB280             UXTH     R0,R0
   \                     ??OSTaskQFlush_1: (+1)
   \       0x78   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    627          }
    628          #endif
    629          
    630          /*$PAGE*/
    631          /*
    632          ************************************************************************************************************************
    633          *                                                  WAIT FOR A MESSAGE
    634          *
    635          * Description: This function causes the current task to wait for a message to be posted to it.
    636          *
    637          * Arguments  : timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait for a
    638          *                            message to arrive up to the amount of time specified by this argument.
    639          *                            If you specify 0, however, your task will wait forever or, until a message arrives.
    640          *
    641          *              opt           determines whether the user wants to block if the task's queue is empty or not:
    642          *
    643          *                                OS_OPT_PEND_BLOCKING
    644          *                                OS_OPT_PEND_NON_BLOCKING
    645          *
    646          *              p_msg_size    is a pointer to a variable that will receive the size of the message
    647          *
    648          *              p_ts          is a pointer to a variable that will receive the timestamp of when the message was
    649          *                            received.  If you pass a NULL pointer (i.e. (CPU_TS *)0) then you will not get the
    650          *                            timestamp.  In other words, passing a NULL pointer is valid and indicates that you don't
    651          *                            need the timestamp.
    652          *
    653          *              p_err         is a pointer to where an error message will be deposited.  Possible error
    654          *                            messages are:
    655          *
    656          *                                OS_ERR_NONE               The call was successful and your task received a message.
    657          *                                OS_ERR_PEND_ABORT
    658          *                                OS_ERR_PEND_ISR           If you called this function from an ISR and the result
    659          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but the queue was not empty
    660          *                                OS_ERR_Q_EMPTY
    661          *                                OS_ERR_SCHED_LOCKED       If the scheduler is locked
    662          *                                OS_ERR_TIMEOUT            A message was not received within the specified timeout
    663          *                                                          would lead to a suspension.
    664          *
    665          * Returns    : A pointer to the message received or a NULL pointer upon error.
    666          *
    667          * Note(s)    : 1) It is possible to receive NULL pointers when there are no errors.
    668          ************************************************************************************************************************
    669          */
    670          
    671          #if OS_CFG_TASK_Q_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    672          void  *OSTaskQPend (OS_TICK       timeout,
    673                              OS_OPT        opt,
    674                              OS_MSG_SIZE  *p_msg_size,
    675                              CPU_TS       *p_ts,
    676                              OS_ERR       *p_err)
    677          {
   \                     OSTaskQPend: (+1)
   \        0x0   0xB5F1             PUSH     {R0,R4-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x9E0A             LDR      R6,[SP, #+40]
    678              OS_MSG_Q     *p_msg_q;
    679              void         *p_void;
    680              CPU_SR_ALLOC();
   \        0x6   0x2400             MOVS     R4,#+0
   \        0x8   0x0020             MOVS     R0,R4
    681          
    682          
    683          
    684          #ifdef OS_SAFETY_CRITICAL
    685              if (p_err == (OS_ERR *)0) {
    686                  OS_SAFETY_CRITICAL_EXCEPTION();
    687                  return ((void *)0);
    688              }
    689          #endif
    690          
    691          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    692              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't Pend from an ISR                                 */
   \        0xA   0x....             LDR      R0,??DataTable8
   \        0xC   0x7800             LDRB     R0,[R0, #+0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD003             BEQ      ??OSTaskQPend_0
    693                 *p_err = OS_ERR_PEND_ISR;
   \       0x12   0x....             LDR      R0,??DataTable8_1  ;; 0x61ae
   \       0x14   0x8030             STRH     R0,[R6, #+0]
    694                  return ((void *)0);
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE0AB             B        ??OSTaskQPend_1
    695              }
   \                     ??OSTaskQPend_0: (+1)
   \       0x1A   0x9201             STR      R2,[SP, #+4]
    696          #endif
    697          
    698          #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
    699              if (p_msg_size == (OS_MSG_SIZE *)0) {                   /* User must supply a valid destination for msg size      */
   \       0x1C   0x9801             LDR      R0,[SP, #+4]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD103             BNE      ??OSTaskQPend_2
    700                 *p_err = OS_ERR_PTR_INVALID;
   \       0x22   0x....             LDR      R0,??DataTable9  ;; 0x62d5
   \       0x24   0x8030             STRH     R0,[R6, #+0]
    701                  return ((void *)0);
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xE0A3             B        ??OSTaskQPend_1
    702              }
   \                     ??OSTaskQPend_2: (+1)
   \       0x2A   0x4668             MOV      R0,SP
   \       0x2C   0x8101             STRH     R1,[R0, #+8]
    703              switch (opt) {                                          /* User must supply a valid option                        */
   \       0x2E   0x4668             MOV      R0,SP
   \       0x30   0x8900             LDRH     R0,[R0, #+8]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD003             BEQ      ??OSTaskQPend_3
   \       0x36   0x2180             MOVS     R1,#+128
   \       0x38   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \       0x3A   0x4288             CMP      R0,R1
   \       0x3C   0xD127             BNE      ??OSTaskQPend_4
   \                     ??OSTaskQPend_3: (+1)
   \       0x3E   0x001F             MOVS     R7,R3
    704                  case OS_OPT_PEND_BLOCKING:
    705                  case OS_OPT_PEND_NON_BLOCKING:
    706                       break;
    707          
    708                  default:
    709                      *p_err = OS_ERR_OPT_INVALID;
    710                       return ((void *)0);
    711              }
    712          #endif
    713          
    714              if (p_ts != (CPU_TS *)0) {
   \       0x40   0x2F00             CMP      R7,#+0
   \       0x42   0xD000             BEQ      ??OSTaskQPend_5
    715                 *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
   \       0x44   0x603C             STR      R4,[R7, #+0]
    716              }
    717          
    718              CPU_CRITICAL_ENTER();
   \                     ??OSTaskQPend_5: (+1)
   \       0x46   0x....'....        BL       CPU_SR_Save
   \       0x4A   0x9003             STR      R0,[SP, #+12]
    719              p_msg_q = &OSTCBCurPtr->MsgQ;                           /* Any message waiting in the message queue?              */
   \       0x4C   0x....             LDR      R5,??DataTable9_1
   \       0x4E   0x6828             LDR      R0,[R5, #+0]
   \       0x50   0x3064             ADDS     R0,R0,#+100
    720              p_void  = OS_MsgQGet(p_msg_q,
    721                                   p_msg_size,
    722                                   p_ts,
    723                                   p_err);
   \       0x52   0x0033             MOVS     R3,R6
   \       0x54   0x003A             MOVS     R2,R7
   \       0x56   0x9901             LDR      R1,[SP, #+4]
   \       0x58   0x....'....        BL       OS_MsgQGet
   \       0x5C   0x9000             STR      R0,[SP, #+0]
    724              if (*p_err == OS_ERR_NONE) {
   \       0x5E   0x8830             LDRH     R0,[R6, #+0]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD118             BNE      ??OSTaskQPend_6
    725          #if OS_CFG_TASK_PROFILE_EN > 0u
    726                  if (p_ts != (CPU_TS *)0) {
   \       0x64   0x2F00             CMP      R7,#+0
   \       0x66   0xD00D             BEQ      ??OSTaskQPend_7
    727                      OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - *p_ts;
   \       0x68   0x6838             LDR      R0,[R7, #+0]
   \       0x6A   0x4241             RSBS     R1,R0,#+0
   \       0x6C   0x6828             LDR      R0,[R5, #+0]
   \       0x6E   0x6741             STR      R1,[R0, #+116]
    728                      if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
   \       0x70   0x6828             LDR      R0,[R5, #+0]
   \       0x72   0x6F80             LDR      R0,[R0, #+120]
   \       0x74   0x6829             LDR      R1,[R5, #+0]
   \       0x76   0x6F49             LDR      R1,[R1, #+116]
   \       0x78   0x4288             CMP      R0,R1
   \       0x7A   0xD203             BCS      ??OSTaskQPend_7
    729                          OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
   \       0x7C   0x6828             LDR      R0,[R5, #+0]
   \       0x7E   0x6F40             LDR      R0,[R0, #+116]
   \       0x80   0x6829             LDR      R1,[R5, #+0]
   \       0x82   0x6788             STR      R0,[R1, #+120]
    730                      }
    731                  }
    732          #endif
    733                  CPU_CRITICAL_EXIT();
   \                     ??OSTaskQPend_7: (+1)
   \       0x84   0x9803             LDR      R0,[SP, #+12]
   \       0x86   0x....'....        BL       CPU_SR_Restore
    734                  return (p_void);                                    /* Yes, Return oldest message received                    */
   \       0x8A   0x9800             LDR      R0,[SP, #+0]
   \       0x8C   0xE071             B        ??OSTaskQPend_1
    735              }
   \                     ??OSTaskQPend_4: (+1)
   \       0x8E   0x....             LDR      R0,??DataTable9_2  ;; 0x5e25
   \       0x90   0x8030             STRH     R0,[R6, #+0]
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0xE06D             B        ??OSTaskQPend_1
    736          
    737              if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
   \                     ??OSTaskQPend_6: (+1)
   \       0x96   0x4668             MOV      R0,SP
   \       0x98   0x8900             LDRH     R0,[R0, #+8]
   \       0x9A   0x0400             LSLS     R0,R0,#+16
   \       0x9C   0xD506             BPL      ??OSTaskQPend_8
    738                 *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
   \       0x9E   0x....             LDR      R0,??DataTable9_3  ;; 0x61b0
   \       0xA0   0x8030             STRH     R0,[R6, #+0]
    739                  CPU_CRITICAL_EXIT();
   \       0xA2   0x9803             LDR      R0,[SP, #+12]
   \       0xA4   0x....'....        BL       CPU_SR_Restore
    740                  return ((void *)0);
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0xE062             B        ??OSTaskQPend_1
    741              } else {                                                /* Yes                                                    */
    742                  if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /*     Can't block when the scheduler is locked           */
   \                     ??OSTaskQPend_8: (+1)
   \       0xAC   0x....             LDR      R0,??DataTable9_4
   \       0xAE   0x7800             LDRB     R0,[R0, #+0]
   \       0xB0   0x2800             CMP      R0,#+0
   \       0xB2   0xD006             BEQ      ??OSTaskQPend_9
    743                      CPU_CRITICAL_EXIT();
   \       0xB4   0x9803             LDR      R0,[SP, #+12]
   \       0xB6   0x....'....        BL       CPU_SR_Restore
    744                     *p_err = OS_ERR_SCHED_LOCKED;
   \       0xBA   0x....             LDR      R0,??DataTable9_5  ;; 0x6d63
   \       0xBC   0x8030             STRH     R0,[R6, #+0]
    745                      return ((void *)0);
   \       0xBE   0x2000             MOVS     R0,#+0
   \       0xC0   0xE057             B        ??OSTaskQPend_1
    746                  }
    747              }
    748                                                                      /* Lock the scheduler/re-enable interrupts                */
    749              OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OSTaskQPend_9: (+1)
   \       0xC2   0x....             LDR      R0,??DataTable9_4
   \       0xC4   0x7800             LDRB     R0,[R0, #+0]
   \       0xC6   0x1C40             ADDS     R0,R0,#+1
   \       0xC8   0x....             LDR      R1,??DataTable9_4
   \       0xCA   0x7008             STRB     R0,[R1, #+0]
   \       0xCC   0x9803             LDR      R0,[SP, #+12]
   \       0xCE   0x....'....        BL       CPU_SR_Restore
    750              OS_Pend((OS_PEND_DATA *)0,                              /* Block task pending on Message                          */
    751                      (OS_PEND_OBJ  *)0,
    752                      (OS_STATE      )OS_TASK_PEND_ON_TASK_Q,
    753                      (OS_TICK       )timeout);
   \       0xD2   0x9B04             LDR      R3,[SP, #+16]
   \       0xD4   0x2202             MOVS     R2,#+2
   \       0xD6   0x2100             MOVS     R1,#+0
   \       0xD8   0x2000             MOVS     R0,#+0
   \       0xDA   0x....'....        BL       OS_Pend
    754              OS_CRITICAL_EXIT_NO_SCHED();
   \       0xDE   0x....'....        BL       CPU_SR_Save
   \       0xE2   0x....             LDR      R1,??DataTable9_4
   \       0xE4   0x7809             LDRB     R1,[R1, #+0]
   \       0xE6   0x1E49             SUBS     R1,R1,#+1
   \       0xE8   0x....             LDR      R2,??DataTable9_4
   \       0xEA   0x7011             STRB     R1,[R2, #+0]
   \       0xEC   0x....'....        BL       CPU_SR_Restore
    755          
    756              OSSched();                                              /* Find the next highest priority task ready to run       */
   \       0xF0   0x....'....        BL       OSSched
    757          
    758              CPU_CRITICAL_ENTER();
   \       0xF4   0x....'....        BL       CPU_SR_Save
    759              switch (OSTCBCurPtr->PendStatus) {
   \       0xF8   0x6829             LDR      R1,[R5, #+0]
   \       0xFA   0x2235             MOVS     R2,#+53
   \       0xFC   0x5C89             LDRB     R1,[R1, R2]
   \       0xFE   0x2900             CMP      R1,#+0
   \      0x100   0xD002             BEQ      ??OSTaskQPend_10
   \      0x102   0x2901             CMP      R1,#+1
   \      0x104   0xD01E             BEQ      ??OSTaskQPend_11
   \      0x106   0xE027             B        ??OSTaskQPend_12
    760                  case OS_STATUS_PEND_OK:                             /* Extract message from TCB (Put there by Post)           */
    761                       p_void      = OSTCBCurPtr->MsgPtr;
   \                     ??OSTaskQPend_10: (+1)
   \      0x108   0x6829             LDR      R1,[R5, #+0]
   \      0x10A   0x6DC9             LDR      R1,[R1, #+92]
   \      0x10C   0x9100             STR      R1,[SP, #+0]
    762                      *p_msg_size  = OSTCBCurPtr->MsgSize;
   \      0x10E   0x6829             LDR      R1,[R5, #+0]
   \      0x110   0x2260             MOVS     R2,#+96
   \      0x112   0x5A89             LDRH     R1,[R1, R2]
   \      0x114   0x9A01             LDR      R2,[SP, #+4]
   \      0x116   0x8011             STRH     R1,[R2, #+0]
    763                       if (p_ts != (CPU_TS *)0) {
   \      0x118   0x2F00             CMP      R7,#+0
   \      0x11A   0xD011             BEQ      ??OSTaskQPend_13
    764                          *p_ts  = OSTCBCurPtr->TS;
   \      0x11C   0x6829             LDR      R1,[R5, #+0]
   \      0x11E   0x6C09             LDR      R1,[R1, #+64]
   \      0x120   0x6039             STR      R1,[R7, #+0]
    765          #if OS_CFG_TASK_PROFILE_EN > 0u
    766                          OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
   \      0x122   0x6829             LDR      R1,[R5, #+0]
   \      0x124   0x6C09             LDR      R1,[R1, #+64]
   \      0x126   0x424A             RSBS     R2,R1,#+0
   \      0x128   0x6829             LDR      R1,[R5, #+0]
   \      0x12A   0x674A             STR      R2,[R1, #+116]
    767                          if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
   \      0x12C   0x6829             LDR      R1,[R5, #+0]
   \      0x12E   0x6F89             LDR      R1,[R1, #+120]
   \      0x130   0x682A             LDR      R2,[R5, #+0]
   \      0x132   0x6F52             LDR      R2,[R2, #+116]
   \      0x134   0x4291             CMP      R1,R2
   \      0x136   0xD203             BCS      ??OSTaskQPend_13
    768                              OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
   \      0x138   0x6829             LDR      R1,[R5, #+0]
   \      0x13A   0x6F49             LDR      R1,[R1, #+116]
   \      0x13C   0x682A             LDR      R2,[R5, #+0]
   \      0x13E   0x6791             STR      R1,[R2, #+120]
    769                          }
    770          #endif
    771                       }
    772                      *p_err = OS_ERR_NONE;
   \                     ??OSTaskQPend_13: (+1)
   \      0x140   0x8034             STRH     R4,[R6, #+0]
    773                       break;
   \      0x142   0xE013             B        ??OSTaskQPend_14
    774          
    775                  case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
    776                       p_void     = (void      *)0;
   \                     ??OSTaskQPend_11: (+1)
   \      0x144   0x9400             STR      R4,[SP, #+0]
    777                      *p_msg_size = (OS_MSG_SIZE)0;
   \      0x146   0x0021             MOVS     R1,R4
   \      0x148   0x9A01             LDR      R2,[SP, #+4]
   \      0x14A   0x8011             STRH     R1,[R2, #+0]
    778                       if (p_ts  != (CPU_TS *)0) {
   \      0x14C   0x2F00             CMP      R7,#+0
   \      0x14E   0xD000             BEQ      ??OSTaskQPend_15
    779                          *p_ts   = (CPU_TS  )0;
   \      0x150   0x603C             STR      R4,[R7, #+0]
    780                       }
    781                      *p_err      =  OS_ERR_PEND_ABORT;
   \                     ??OSTaskQPend_15: (+1)
   \      0x152   0x....             LDR      R1,??DataTable9_6  ;; 0x61a9
   \      0x154   0x8031             STRH     R1,[R6, #+0]
    782                       break;
   \      0x156   0xE009             B        ??OSTaskQPend_14
    783          
    784                  case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get event within TO            */
    785                  default:
    786                       p_void     = (void      *)0;
   \                     ??OSTaskQPend_12: (+1)
   \      0x158   0x9400             STR      R4,[SP, #+0]
    787                      *p_msg_size = (OS_MSG_SIZE)0;
   \      0x15A   0x9901             LDR      R1,[SP, #+4]
   \      0x15C   0x800C             STRH     R4,[R1, #+0]
    788                       if (p_ts  != (CPU_TS *)0) {
   \      0x15E   0x2F00             CMP      R7,#+0
   \      0x160   0xD002             BEQ      ??OSTaskQPend_16
    789                          *p_ts   =  OSTCBCurPtr->TS;
   \      0x162   0x6829             LDR      R1,[R5, #+0]
   \      0x164   0x6C09             LDR      R1,[R1, #+64]
   \      0x166   0x6039             STR      R1,[R7, #+0]
    790                       }
    791                      *p_err      =  OS_ERR_TIMEOUT;
   \                     ??OSTaskQPend_16: (+1)
   \      0x168   0x....             LDR      R1,??DataTable9_7  ;; 0x72d9
   \      0x16A   0x8031             STRH     R1,[R6, #+0]
    792                       break;
    793              }
    794              CPU_CRITICAL_EXIT();
   \                     ??OSTaskQPend_14: (+1)
   \      0x16C   0x....'....        BL       CPU_SR_Restore
    795              return (p_void);                                        /* Return received message                                */
   \      0x170   0x9800             LDR      R0,[SP, #+0]
   \                     ??OSTaskQPend_1: (+1)
   \      0x172   0xB005             ADD      SP,SP,#+20
   \      0x174   0xBDF0             POP      {R4-R7,PC}       ;; return
    796          }
    797          #endif
    798          
    799          /*$PAGE*/
    800          /*
    801          ************************************************************************************************************************
    802          *                                              ABORT WAITING FOR A MESSAGE
    803          *
    804          * Description: This function aborts & readies the task specified.  This function should be used to fault-abort the wait
    805          *              for a message, rather than to normally post the message to the task via OSTaskQPost().
    806          *
    807          * Arguments  : p_tcb     is a pointer to the task to pend abort
    808          *
    809          *              opt       provides options for this function:
    810          *
    811          *                            OS_OPT_POST_NONE         No option specified
    812          *                            OS_OPT_POST_NO_SCHED     Indicates that the scheduler will not be called.
    813          *
    814          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    815          *
    816          *                            OS_ERR_NONE              If the task was readied and informed of the aborted wait
    817          *                            OS_ERR_PEND_ABORT_ISR    If you called this function from an ISR
    818          *                            OS_ERR_PEND_ABORT_NONE   If task was not pending on a message and thus there is nothing to
    819          *                                                     abort.
    820          *                            OS_ERR_PEND_ABORT_SELF   If you passed a NULL pointer for 'p_tcb'
    821          *
    822          * Returns    : == DEF_FALSE   if task was not waiting for a message, or upon error.
    823          *              == DEF_TRUE    if task was waiting for a message and was readied and informed.
    824          ************************************************************************************************************************
    825          */
    826          
    827          #if (OS_CFG_TASK_Q_EN > 0u) && (OS_CFG_TASK_Q_PEND_ABORT_EN > 0u)
    828          CPU_BOOLEAN  OSTaskQPendAbort (OS_TCB  *p_tcb,
    829                                         OS_OPT   opt,
    830                                         OS_ERR  *p_err)
    831          {
    832              CPU_TS         ts;
    833              CPU_SR_ALLOC();
    834          
    835          
    836          
    837          #ifdef OS_SAFETY_CRITICAL
    838              if (p_err == (OS_ERR *)0) {
    839                  OS_SAFETY_CRITICAL_EXCEPTION();
    840                  return (DEF_FALSE);
    841              }
    842          #endif
    843          
    844          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    845              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
    846                 *p_err = OS_ERR_PEND_ABORT_ISR;                      /* ... can't Pend Abort from an ISR                       */
    847                  return (DEF_FALSE);
    848              }
    849          #endif
    850          
    851          #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
    852              switch (opt) {                                          /* User must supply a valid option                        */
    853                  case OS_OPT_POST_NONE:
    854                  case OS_OPT_POST_NO_SCHED:
    855                       break;
    856          
    857                  default:
    858                      *p_err = OS_ERR_OPT_INVALID;
    859                       return (DEF_FALSE);
    860              }
    861          #endif
    862          
    863              CPU_CRITICAL_ENTER();
    864          #if OS_CFG_ARG_CHK_EN > 0u
    865              if ((p_tcb == (OS_TCB *)0) ||                           /* Pend abort self?                                       */
    866                  (p_tcb == OSTCBCurPtr)) {
    867                  CPU_CRITICAL_EXIT();
    868                 *p_err = OS_ERR_PEND_ABORT_SELF;                     /* ... doesn't make sense                                 */
    869                  return (DEF_FALSE);
    870              }
    871          #endif
    872          
    873              if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_Q) {          /* Is task waiting for a message?                         */
    874                  CPU_CRITICAL_EXIT();                                /* No                                                     */
    875                 *p_err = OS_ERR_PEND_ABORT_NONE;
    876                  return (DEF_FALSE);
    877              }
    878          
    879              OS_CRITICAL_ENTER_CPU_EXIT();
    880              ts = OS_TS_GET();                                       /* Get timestamp of when the abort occurred               */
    881              OS_PendAbort((OS_PEND_OBJ *)0,                          /* Abort the pend                                         */
    882                           p_tcb,
    883                           ts);
    884              OS_CRITICAL_EXIT_NO_SCHED();
    885              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
    886                  OSSched();                                          /* Run the scheduler                                      */
    887              }
    888             *p_err = OS_ERR_NONE;
    889              return (DEF_TRUE);
    890          }
    891          #endif
    892          
    893          /*$PAGE*/
    894          /*
    895          ************************************************************************************************************************
    896          *                                               POST MESSAGE TO A TASK
    897          *
    898          * Description: This function sends a message to a task
    899          *
    900          * Arguments  : p_tcb      is a pointer to the TCB of the task receiving a message.  If you specify a NULL pointer then
    901          *                         the message will be posted to the task's queue of the calling task.  In other words, you'd be
    902          *                         posting a message to yourself.
    903          *
    904          *              p_void     is a pointer to the message to send.
    905          *
    906          *              msg_size   is the size of the message sent (in #bytes)
    907          *
    908          *              opt        specifies whether the post will be FIFO or LIFO:
    909          *
    910          *                             OS_OPT_POST_FIFO       Post at the end   of the queue
    911          *                             OS_OPT_POST_LIFO       Post at the front of the queue
    912          *
    913          *                             OS_OPT_POST_NO_SCHED   Do not run the scheduler after the post
    914          *
    915          *                          Note(s): 1) OS_OPT_POST_NO_SCHED can be added with one of the other options.
    916          *
    917          *
    918          *              p_err      is a pointer to a variable that will hold the error code associated
    919          *                         with the outcome of this call.  Errors can be:
    920          *
    921          *                             OS_ERR_NONE            The call was successful and the message was sent
    922          *                             OS_ERR_Q_MAX           If the queue is full
    923          *                             OS_ERR_MSG_POOL_EMPTY  If there are no more OS_MSGs available from the pool
    924          *
    925          * Returns    : none
    926          ************************************************************************************************************************
    927          */
    928          
    929          #if OS_CFG_TASK_Q_EN > 0u

   \                                 In section .text, align 2, keep-with-next
    930          void  OSTaskQPost (OS_TCB       *p_tcb,
    931                             void         *p_void,
    932                             OS_MSG_SIZE   msg_size,
    933                             OS_OPT        opt,
    934                             OS_ERR       *p_err)
    935          {
   \                     OSTaskQPost: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x9C08             LDR      R4,[SP, #+32]
    936              CPU_TS   ts;
    937          
    938          
    939          
    940          #ifdef OS_SAFETY_CRITICAL
    941              if (p_err == (OS_ERR *)0) {
    942                  OS_SAFETY_CRITICAL_EXCEPTION();
    943                  return;
    944              }
    945          #endif
    946          
    947          #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
    948              switch (opt) {                                          /* User must supply a valid option                        */
   \        0x4   0x001D             MOVS     R5,R3
   \        0x6   0xB2AD             UXTH     R5,R5
   \        0x8   0x2D00             CMP      R5,#+0
   \        0xA   0xD006             BEQ      ??OSTaskQPost_0
   \        0xC   0x3D10             SUBS     R5,R5,#+16
   \        0xE   0xD004             BEQ      ??OSTaskQPost_0
   \       0x10   0x....             LDR      R6,??DataTable9_8  ;; 0x7ff0
   \       0x12   0x1BAD             SUBS     R5,R5,R6
   \       0x14   0xD001             BEQ      ??OSTaskQPost_0
   \       0x16   0x3D10             SUBS     R5,R5,#+16
   \       0x18   0xD10B             BNE      ??OSTaskQPost_1
    949                  case OS_OPT_POST_FIFO:
    950                  case OS_OPT_POST_LIFO:
    951                  case OS_OPT_POST_FIFO | OS_OPT_POST_NO_SCHED:
    952                  case OS_OPT_POST_LIFO | OS_OPT_POST_NO_SCHED:
    953                       break;
    954          
    955                  default:
    956                      *p_err = OS_ERR_OPT_INVALID;
    957                       return;
    958              }
    959          #endif
    960          
    961              ts = OS_TS_GET();                                       /* Get timestamp                                          */
   \                     ??OSTaskQPost_0: (+1)
   \       0x1A   0x2500             MOVS     R5,#+0
    962          
    963          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    964              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {
   \       0x1C   0x....             LDR      R6,??DataTable8
   \       0x1E   0x7836             LDRB     R6,[R6, #+0]
   \       0x20   0x2E00             CMP      R6,#+0
   \       0x22   0xD109             BNE      ??OSTaskQPost_2
    965                  OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_MSG,      /* Post to ISR queue                                      */
    966                              (void      *)p_tcb,
    967                              (void      *)p_void,
    968                              (OS_MSG_SIZE)msg_size,
    969                              (OS_FLAGS   )0,
    970                              (OS_OPT     )opt,
    971                              (CPU_TS     )ts,
    972                              (OS_ERR    *)p_err);
    973                  return;
    974              }
    975          #endif
    976          
    977              OS_TaskQPost(p_tcb,
    978                           p_void,
    979                           msg_size,
    980                           opt,
    981                           ts,
    982                           p_err);
   \       0x24   0x9401             STR      R4,[SP, #+4]
   \       0x26   0x9500             STR      R5,[SP, #+0]
   \       0x28   0xB29B             UXTH     R3,R3
   \       0x2A   0xB292             UXTH     R2,R2
   \       0x2C   0x....'....        BL       OS_TaskQPost
    983          }
   \                     ??OSTaskQPost_3: (+1)
   \       0x30   0xBD7F             POP      {R0-R6,PC}       ;; return
   \                     ??OSTaskQPost_1: (+1)
   \       0x32   0x....             LDR      R0,??DataTable9_2  ;; 0x5e25
   \       0x34   0x8020             STRH     R0,[R4, #+0]
   \       0x36   0xE7FB             B        ??OSTaskQPost_3
   \                     ??OSTaskQPost_2: (+1)
   \       0x38   0x9403             STR      R4,[SP, #+12]
   \       0x3A   0x9502             STR      R5,[SP, #+8]
   \       0x3C   0xB29B             UXTH     R3,R3
   \       0x3E   0x9301             STR      R3,[SP, #+4]
   \       0x40   0x2300             MOVS     R3,#+0
   \       0x42   0x9300             STR      R3,[SP, #+0]
   \       0x44   0x0013             MOVS     R3,R2
   \       0x46   0xB29B             UXTH     R3,R3
   \       0x48   0x000A             MOVS     R2,R1
   \       0x4A   0x0001             MOVS     R1,R0
   \       0x4C   0x....             LDR      R0,??DataTable10  ;; 0x47534d54
   \       0x4E   0x....'....        BL       OS_IntQPost
   \       0x52   0xE7ED             B        ??OSTaskQPost_3
    984          #endif
    985          
    986          /*$PAGE*/
    987          /*
    988          ************************************************************************************************************************
    989          *                                       GET THE CURRENT VALUE OF A TASK REGISTER
    990          *
    991          * Description: This function is called to obtain the current value of a task register.  Task registers are application
    992          *              specific and can be used to store task specific values such as 'error numbers' (i.e. errno), statistics,
    993          *              etc.
    994          *
    995          * Arguments  : p_tcb     is a pointer to the OS_TCB of the task you want to read the register from.  If 'p_tcb' is a
    996          *                        NULL pointer then you will get the register of the current task.
    997          *
    998          *              id        is the 'id' of the desired task variable.  Note that the 'id' must be less than
    999          *                        OS_CFG_TASK_REG_TBL_SIZE
   1000          *
   1001          *              p_err     is a pointer to a variable that will hold an error code related to this call.
   1002          *
   1003          *                            OS_ERR_NONE            if the call was successful
   1004          *                            OS_ERR_REG_ID_INVALID  if the 'id' is not between 0 and OS_CFG_TASK_REG_TBL_SIZE-1
   1005          *
   1006          * Returns    : The current value of the task's register or 0 if an error is detected.
   1007          ************************************************************************************************************************
   1008          */
   1009          
   1010          #if OS_CFG_TASK_REG_TBL_SIZE > 0u

   \                                 In section .text, align 2, keep-with-next
   1011          OS_REG  OSTaskRegGet (OS_TCB     *p_tcb,
   1012                                OS_REG_ID   id,
   1013                                OS_ERR     *p_err)
   1014          {
   \                     OSTaskRegGet: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x000C             MOVS     R4,R1
   \        0x4   0x0017             MOVS     R7,R2
   1015              OS_REG     value;
   1016              CPU_SR_ALLOC();
   \        0x6   0x2500             MOVS     R5,#+0
   \        0x8   0x0029             MOVS     R1,R5
   1017          
   1018          
   1019          
   1020          #ifdef OS_SAFETY_CRITICAL
   1021              if (p_err == (OS_ERR *)0) {
   1022                  OS_SAFETY_CRITICAL_EXCEPTION();
   1023                  return ((OS_REG)0);
   1024              }
   1025          #endif
   1026          
   1027          #if OS_CFG_ARG_CHK_EN > 0u
   1028              if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
   \        0xA   0x0021             MOVS     R1,R4
   \        0xC   0xB2C9             UXTB     R1,R1
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD003             BEQ      ??OSTaskRegGet_0
   1029                 *p_err = OS_ERR_REG_ID_INVALID;
   \       0x12   0x....             LDR      R0,??DataTable10_1  ;; 0x6979
   \       0x14   0x8038             STRH     R0,[R7, #+0]
   1030                  return ((OS_REG)0);
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE00F             B        ??OSTaskRegGet_1
   1031              }
   \                     ??OSTaskRegGet_0: (+1)
   \       0x1A   0x0006             MOVS     R6,R0
   1032          #endif
   1033          
   1034              CPU_CRITICAL_ENTER();
   \       0x1C   0x....'....        BL       CPU_SR_Save
   1035              if (p_tcb == (OS_TCB *)0) {
   \       0x20   0x2E00             CMP      R6,#+0
   \       0x22   0xD101             BNE      ??OSTaskRegGet_2
   1036                  p_tcb = OSTCBCurPtr;
   \       0x24   0x....             LDR      R1,??DataTable9_1
   \       0x26   0x680E             LDR      R6,[R1, #+0]
   1037              }
   1038              value = p_tcb->RegTbl[id];
   \                     ??OSTaskRegGet_2: (+1)
   \       0x28   0xB2E4             UXTB     R4,R4
   \       0x2A   0x2104             MOVS     R1,#+4
   \       0x2C   0x434C             MULS     R4,R1,R4
   \       0x2E   0x1931             ADDS     R1,R6,R4
   \       0x30   0x6FCC             LDR      R4,[R1, #+124]
   1039              CPU_CRITICAL_EXIT();
   \       0x32   0x....'....        BL       CPU_SR_Restore
   1040             *p_err = OS_ERR_NONE;
   \       0x36   0x803D             STRH     R5,[R7, #+0]
   1041              return ((OS_REG)value);
   \       0x38   0x0020             MOVS     R0,R4
   \                     ??OSTaskRegGet_1: (+1)
   \       0x3A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1042          }
   1043          #endif
   1044          
   1045          /*$PAGE*/
   1046          /*
   1047          ************************************************************************************************************************
   1048          *                                    ALLOCATE THE NEXT AVAILABLE TASK REGISTER ID
   1049          *
   1050          * Description: This function is called to obtain a task register ID.  This function thus allows task registers IDs to be
   1051          *              allocated dynamically instead of statically.
   1052          *
   1053          * Arguments  : p_err       is a pointer to a variable that will hold an error code related to this call.
   1054          *
   1055          *                            OS_ERR_NONE               if the call was successful
   1056          *                            OS_ERR_NO_MORE_ID_AVAIL   if you are attempting to assign more task register IDs than you 
   1057          *                                                           have available through OS_CFG_TASK_REG_TBL_SIZE.
   1058          *
   1059          * Returns    : The next available task register 'id' or OS_CFG_TASK_REG_TBL_SIZE if an error is detected.
   1060          ************************************************************************************************************************
   1061          */
   1062          
   1063          #if OS_CFG_TASK_REG_TBL_SIZE > 0u

   \                                 In section .text, align 2, keep-with-next
   1064          OS_REG_ID  OSTaskRegGetID (OS_ERR  *p_err)
   1065          {
   \                     OSTaskRegGetID: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1066              OS_REG_ID  id;
   1067              CPU_SR_ALLOC();
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0x0028             MOVS     R0,R5
   1068          
   1069          
   1070          
   1071          #ifdef OS_SAFETY_CRITICAL
   1072              if (p_err == (OS_ERR *)0) {
   1073                  OS_SAFETY_CRITICAL_EXCEPTION();
   1074                  return ((OS_REG_ID)OS_CFG_TASK_REG_TBL_SIZE);
   1075              }
   1076          #endif
   1077          
   1078              CPU_CRITICAL_ENTER();
   \        0x8   0x....'....        BL       CPU_SR_Save
   1079              if (OSTaskRegNextAvailID >= OS_CFG_TASK_REG_TBL_SIZE) {       /* See if we exceeded the number of IDs available   */
   \        0xC   0x....             LDR      R1,??DataTable10_2
   \        0xE   0x780A             LDRB     R2,[R1, #+0]
   \       0x10   0x2A00             CMP      R2,#+0
   \       0x12   0xD005             BEQ      ??OSTaskRegGetID_0
   1080                 *p_err = OS_ERR_NO_MORE_ID_AVAIL;                          /* Yes, cannot allocate more task register IDs      */
   \       0x14   0x....             LDR      R1,??DataTable11  ;; 0x59da
   \       0x16   0x8021             STRH     R1,[R4, #+0]
   1081                  CPU_CRITICAL_EXIT();
   \       0x18   0x....'....        BL       CPU_SR_Restore
   1082                  return ((OS_REG_ID)OS_CFG_TASK_REG_TBL_SIZE);
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xE008             B        ??OSTaskRegGetID_1
   1083              }
   1084               
   1085              id    = OSTaskRegNextAvailID;								  /* Assign the next available ID                     */
   \                     ??OSTaskRegGetID_0: (+1)
   \       0x20   0x780E             LDRB     R6,[R1, #+0]
   1086              OSTaskRegNextAvailID++;										  /* Increment available ID for next request          */
   \       0x22   0x780A             LDRB     R2,[R1, #+0]
   \       0x24   0x1C52             ADDS     R2,R2,#+1
   \       0x26   0x700A             STRB     R2,[R1, #+0]
   1087              CPU_CRITICAL_EXIT();
   \       0x28   0x....'....        BL       CPU_SR_Restore
   1088             *p_err = OS_ERR_NONE;
   \       0x2C   0x8025             STRH     R5,[R4, #+0]
   1089              return (id);
   \       0x2E   0x0030             MOVS     R0,R6
   \       0x30   0xB2C0             UXTB     R0,R0
   \                     ??OSTaskRegGetID_1: (+1)
   \       0x32   0xBD70             POP      {R4-R6,PC}       ;; return
   1090          }
   1091          #endif
   1092          
   1093          /*$PAGE*/
   1094          /*
   1095          ************************************************************************************************************************
   1096          *                                       SET THE CURRENT VALUE OF A TASK REGISTER
   1097          *
   1098          * Description: This function is called to change the current value of a task register.  Task registers are application
   1099          *              specific and can be used to store task specific values such as 'error numbers' (i.e. errno), statistics,
   1100          *              etc.
   1101          *
   1102          * Arguments  : p_tcb     is a pointer to the OS_TCB of the task you want to set the register for.  If 'p_tcb' is a NULL
   1103          *                        pointer then you will change the register of the current task.
   1104          *
   1105          *              id        is the 'id' of the desired task register.  Note that the 'id' must be less than
   1106          *                        OS_CFG_TASK_REG_TBL_SIZE
   1107          *
   1108          *              value     is the desired value for the task register.
   1109          *
   1110          *              p_err     is a pointer to a variable that will hold an error code related to this call.
   1111          *
   1112          *                            OS_ERR_NONE            if the call was successful
   1113          *                            OS_ERR_REG_ID_INVALID  if the 'id' is not between 0 and OS_CFG_TASK_REG_TBL_SIZE-1
   1114          *
   1115          * Returns    : none
   1116          ************************************************************************************************************************
   1117          */
   1118          
   1119          #if OS_CFG_TASK_REG_TBL_SIZE > 0u

   \                                 In section .text, align 2, keep-with-next
   1120          void  OSTaskRegSet (OS_TCB     *p_tcb,
   1121                              OS_REG_ID   id,
   1122                              OS_REG      value,
   1123                              OS_ERR     *p_err)
   1124          {
   \                     OSTaskRegSet: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x000F             MOVS     R7,R1
   \        0x4   0x0014             MOVS     R4,R2
   1125              CPU_SR_ALLOC();
   \        0x6   0x2500             MOVS     R5,#+0
   \        0x8   0x0029             MOVS     R1,R5
   1126          
   1127          
   1128          
   1129          #ifdef OS_SAFETY_CRITICAL
   1130              if (p_err == (OS_ERR *)0) {
   1131                  OS_SAFETY_CRITICAL_EXCEPTION();
   1132                  return;
   1133              }
   1134          #endif
   1135          
   1136          #if OS_CFG_ARG_CHK_EN > 0u
   1137              if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
   \        0xA   0x0039             MOVS     R1,R7
   \        0xC   0xB2C9             UXTB     R1,R1
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD003             BEQ      ??OSTaskRegSet_0
   1138                 *p_err = OS_ERR_REG_ID_INVALID;
   \       0x12   0x....             LDR      R0,??DataTable10_1  ;; 0x6979
   \       0x14   0x9900             LDR      R1,[SP, #+0]
   \       0x16   0x8008             STRH     R0,[R1, #+0]
   1139                  return;
   \       0x18   0xE00F             B        ??OSTaskRegSet_1
   1140              }
   \                     ??OSTaskRegSet_0: (+1)
   \       0x1A   0x0006             MOVS     R6,R0
   1141          #endif
   1142          
   1143              CPU_CRITICAL_ENTER();
   \       0x1C   0x....'....        BL       CPU_SR_Save
   1144              if (p_tcb == (OS_TCB *)0) {
   \       0x20   0x2E00             CMP      R6,#+0
   \       0x22   0xD101             BNE      ??OSTaskRegSet_2
   1145                  p_tcb = OSTCBCurPtr;
   \       0x24   0x....             LDR      R1,??DataTable9_1
   \       0x26   0x680E             LDR      R6,[R1, #+0]
   1146              }
   1147              p_tcb->RegTbl[id] = value;
   \                     ??OSTaskRegSet_2: (+1)
   \       0x28   0xB2FF             UXTB     R7,R7
   \       0x2A   0x2104             MOVS     R1,#+4
   \       0x2C   0x434F             MULS     R7,R1,R7
   \       0x2E   0x19F1             ADDS     R1,R6,R7
   \       0x30   0x67CC             STR      R4,[R1, #+124]
   1148              CPU_CRITICAL_EXIT();
   \       0x32   0x....'....        BL       CPU_SR_Restore
   1149             *p_err             = OS_ERR_NONE;
   \       0x36   0x9800             LDR      R0,[SP, #+0]
   \       0x38   0x8005             STRH     R5,[R0, #+0]
   1150          }
   \                     ??OSTaskRegSet_1: (+1)
   \       0x3A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1151          #endif
   1152          
   1153          /*$PAGE*/
   1154          /*
   1155          ************************************************************************************************************************
   1156          *                                               RESUME A SUSPENDED TASK
   1157          *
   1158          * Description: This function is called to resume a previously suspended task.  This is the only call that will remove an
   1159          *              explicit task suspension.
   1160          *
   1161          * Arguments  : p_tcb      Is a pointer to the task's OS_TCB to resume
   1162          *
   1163          *              p_err      Is a pointer to a variable that will contain an error code returned by this function
   1164          *
   1165          *                             OS_ERR_NONE                  if the requested task is resumed
   1166          *                             OS_ERR_STATE_INVALID         if the task is in an invalid state
   1167          *                             OS_ERR_TASK_RESUME_ISR       if you called this function from an ISR
   1168          *                             OS_ERR_TASK_RESUME_SELF      You cannot resume 'self'
   1169          *                             OS_ERR_TASK_NOT_SUSPENDED    if the task to resume has not been suspended
   1170          *
   1171          * Returns    : none
   1172          ************************************************************************************************************************
   1173          */
   1174          
   1175          #if OS_CFG_TASK_SUSPEND_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   1176          void  OSTaskResume (OS_TCB  *p_tcb,
   1177                              OS_ERR  *p_err)
   1178          {
   \                     OSTaskResume: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   1179              CPU_SR_ALLOC();
   \        0x8   0x2000             MOVS     R0,#+0
   1180          
   1181          
   1182          
   1183          #ifdef OS_SAFETY_CRITICAL
   1184              if (p_err == (OS_ERR *)0) {
   1185                  OS_SAFETY_CRITICAL_EXCEPTION();
   1186                  return;
   1187              }
   1188          #endif
   1189          
   1190          #if (OS_CFG_ISR_POST_DEFERRED_EN   == 0u) && \
   1191              (OS_CFG_CALLED_FROM_ISR_CHK_EN >  0u)
   1192              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   1193                 *p_err = OS_ERR_TASK_RESUME_ISR;
   1194                  return;
   1195              }
   1196          #endif
   1197          
   1198          
   1199              CPU_CRITICAL_ENTER();
   \        0xA   0x....'....        BL       CPU_SR_Save
   1200          #if OS_CFG_ARG_CHK_EN > 0u
   1201              if ((p_tcb == (OS_TCB *)0) ||                           /* We cannot resume 'self'                                */
   1202                  (p_tcb == OSTCBCurPtr)) {
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD003             BEQ      ??OSTaskResume_0
   \       0x12   0x....             LDR      R1,??DataTable9_1
   \       0x14   0x6809             LDR      R1,[R1, #+0]
   \       0x16   0x428C             CMP      R4,R1
   \       0x18   0xD104             BNE      ??OSTaskResume_1
   1203                  CPU_CRITICAL_EXIT();
   \                     ??OSTaskResume_0: (+1)
   \       0x1A   0x....'....        BL       CPU_SR_Restore
   1204                 *p_err  = OS_ERR_TASK_RESUME_SELF;
   \       0x1E   0x....             LDR      R0,??DataTable11_1  ;; 0x7157
   \       0x20   0x8028             STRH     R0,[R5, #+0]
   1205                  return;
   \       0x22   0xE017             B        ??OSTaskResume_2
   1206              }
   1207          #endif
   1208              CPU_CRITICAL_EXIT();
   \                     ??OSTaskResume_1: (+1)
   \       0x24   0x....'....        BL       CPU_SR_Restore
   1209          
   1210          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
   1211              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
   \       0x28   0x....             LDR      R0,??DataTable12
   \       0x2A   0x7800             LDRB     R0,[R0, #+0]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD00D             BEQ      ??OSTaskResume_3
   1212                  OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_RESUME,   /* Post to ISR queue                                      */
   1213                              (void      *)p_tcb,
   1214                              (void      *)0,
   1215                              (OS_MSG_SIZE)0,
   1216                              (OS_FLAGS   )0,
   1217                              (OS_OPT     )0,
   1218                              (CPU_TS     )0,
   1219                              (OS_ERR    *)p_err);
   \       0x30   0x9503             STR      R5,[SP, #+12]
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x9002             STR      R0,[SP, #+8]
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x9001             STR      R0,[SP, #+4]
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x9000             STR      R0,[SP, #+0]
   \       0x3E   0x2300             MOVS     R3,#+0
   \       0x40   0x2200             MOVS     R2,#+0
   \       0x42   0x0021             MOVS     R1,R4
   \       0x44   0x....             LDR      R0,??DataTable13  ;; 0x53455254
   \       0x46   0x....'....        BL       OS_IntQPost
   1220                  return;
   \       0x4A   0xE003             B        ??OSTaskResume_2
   1221              }
   1222          #endif
   1223          
   1224              OS_TaskResume(p_tcb, p_err);
   \                     ??OSTaskResume_3: (+1)
   \       0x4C   0x0029             MOVS     R1,R5
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0x....'....        BL       OS_TaskResume
   1225          }
   \                     ??OSTaskResume_2: (+1)
   \       0x54   0xB005             ADD      SP,SP,#+20
   \       0x56   0xBD30             POP      {R4,R5,PC}       ;; return
   1226          #endif
   1227          
   1228          /*$PAGE*/
   1229          /*
   1230          ************************************************************************************************************************
   1231          *                                              WAIT FOR A TASK SEMAPHORE
   1232          *
   1233          * Description: This function is called to block the current task until a signal is sent by another task or ISR.
   1234          *
   1235          * Arguments  : timeout       is the amount of time you are will to wait for the signal
   1236          *
   1237          *              opt           determines whether the user wants to block if a semaphore post was not received:
   1238          *
   1239          *                                OS_OPT_PEND_BLOCKING
   1240          *                                OS_OPT_PEND_NON_BLOCKING
   1241          *
   1242          *              p_ts          is a pointer to a variable that will receive the timestamp of when the semaphore was posted
   1243          *                            or pend aborted.  If you pass a NULL pointer (i.e. (CPU_TS *)0) then you will not get the
   1244          *                            timestamp.  In other words, passing a NULL pointer is valid and indicates that you don't
   1245          *                            need the timestamp.
   1246          *
   1247          *              p_err         is a pointer to an error code that will be set by this function
   1248          *
   1249          *                                OS_ERR_NONE               The call was successful and your task received a message.
   1250          *                                OS_ERR_PEND_ABORT
   1251          *                                OS_ERR_PEND_ISR           If you called this function from an ISR and the result
   1252          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but no signal was received
   1253          *                                OS_ERR_SCHED_LOCKED       If the scheduler is locked
   1254          *                                OS_ERR_STATUS_INVALID     If the pend status is invalid
   1255          *                                OS_ERR_TIMEOUT            A message was not received within the specified timeout
   1256          *                                                          would lead to a suspension.
   1257          *
   1258          * Returns    : The current count of signals the task received, 0 if none.
   1259          ************************************************************************************************************************
   1260          */
   1261          

   \                                 In section .text, align 2, keep-with-next
   1262          OS_SEM_CTR  OSTaskSemPend (OS_TICK   timeout,
   1263                                     OS_OPT    opt,
   1264                                     CPU_TS   *p_ts,
   1265                                     OS_ERR   *p_err)
   1266          {
   \                     OSTaskSemPend: (+1)
   \        0x0   0xB5F1             PUSH     {R0,R4-R7,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
   \        0x4   0x001E             MOVS     R6,R3
   1267              OS_SEM_CTR    ctr;
   1268              CPU_SR_ALLOC();
   \        0x6   0x2500             MOVS     R5,#+0
   \        0x8   0x0028             MOVS     R0,R5
   1269          
   1270          
   1271          
   1272          #ifdef OS_SAFETY_CRITICAL
   1273              if (p_err == (OS_ERR *)0) {
   1274                  OS_SAFETY_CRITICAL_EXCEPTION();
   1275                  return ((OS_SEM_CTR)0);
   1276              }
   1277          #endif
   1278          
   1279          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
   1280              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   \        0xA   0x....             LDR      R0,??DataTable12
   \        0xC   0x7800             LDRB     R0,[R0, #+0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD003             BEQ      ??OSTaskSemPend_0
   1281                 *p_err = OS_ERR_PEND_ISR;
   \       0x12   0x....             LDR      R0,??DataTable13_1  ;; 0x61ae
   \       0x14   0x8030             STRH     R0,[R6, #+0]
   1282                  return ((OS_SEM_CTR)0);
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE0A8             B        ??OSTaskSemPend_1
   1283              }
   \                     ??OSTaskSemPend_0: (+1)
   \       0x1A   0x000F             MOVS     R7,R1
   1284          #endif
   1285          
   1286          #if OS_CFG_ARG_CHK_EN > 0u
   1287              switch (opt) {                                          /* Validate 'opt'                                         */
   \       0x1C   0x0038             MOVS     R0,R7
   \       0x1E   0xB280             UXTH     R0,R0
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD003             BEQ      ??OSTaskSemPend_2
   \       0x24   0x2180             MOVS     R1,#+128
   \       0x26   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \       0x28   0x4288             CMP      R0,R1
   \       0x2A   0xD133             BNE      ??OSTaskSemPend_3
   \                     ??OSTaskSemPend_2: (+1)
   \       0x2C   0x9200             STR      R2,[SP, #+0]
   1288                  case OS_OPT_PEND_BLOCKING:
   1289                  case OS_OPT_PEND_NON_BLOCKING:
   1290                       break;
   1291          
   1292                  default:
   1293                      *p_err = OS_ERR_OPT_INVALID;
   1294                       return ((OS_SEM_CTR)0);
   1295              }
   1296          #endif
   1297          
   1298              if (p_ts != (CPU_TS *)0) {
   \       0x2E   0x9800             LDR      R0,[SP, #+0]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD001             BEQ      ??OSTaskSemPend_4
   1299                 *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
   \       0x34   0x9800             LDR      R0,[SP, #+0]
   \       0x36   0x6005             STR      R5,[R0, #+0]
   1300              }
   1301          
   1302              CPU_CRITICAL_ENTER();
   \                     ??OSTaskSemPend_4: (+1)
   \       0x38   0x....'....        BL       CPU_SR_Save
   1303              if (OSTCBCurPtr->SemCtr > (OS_SEM_CTR)0) {              /* See if task already been signaled                      */
   \       0x3C   0x....             LDR      R4,??DataTable13_2
   \       0x3E   0x6821             LDR      R1,[R4, #+0]
   \       0x40   0x6C49             LDR      R1,[R1, #+68]
   \       0x42   0x2900             CMP      R1,#+0
   \       0x44   0xD02A             BEQ      ??OSTaskSemPend_5
   1304                  OSTCBCurPtr->SemCtr--;
   \       0x46   0x6821             LDR      R1,[R4, #+0]
   \       0x48   0x6C49             LDR      R1,[R1, #+68]
   \       0x4A   0x1E49             SUBS     R1,R1,#+1
   \       0x4C   0x6822             LDR      R2,[R4, #+0]
   \       0x4E   0x6451             STR      R1,[R2, #+68]
   1305                  ctr    = OSTCBCurPtr->SemCtr;
   \       0x50   0x6821             LDR      R1,[R4, #+0]
   \       0x52   0x6C4F             LDR      R7,[R1, #+68]
   1306                  if (p_ts != (CPU_TS *)0) {
   \       0x54   0x9900             LDR      R1,[SP, #+0]
   \       0x56   0x2900             CMP      R1,#+0
   \       0x58   0xD003             BEQ      ??OSTaskSemPend_6
   1307                     *p_ts  = OSTCBCurPtr->TS;
   \       0x5A   0x6821             LDR      R1,[R4, #+0]
   \       0x5C   0x6C09             LDR      R1,[R1, #+64]
   \       0x5E   0x9A00             LDR      R2,[SP, #+0]
   \       0x60   0x6011             STR      R1,[R2, #+0]
   1308                  }
   1309          #if OS_CFG_TASK_PROFILE_EN > 0u
   1310                  OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
   \                     ??OSTaskSemPend_6: (+1)
   \       0x62   0x6821             LDR      R1,[R4, #+0]
   \       0x64   0x6C0A             LDR      R2,[R1, #+64]
   \       0x66   0x4251             RSBS     R1,R2,#+0
   \       0x68   0x6823             LDR      R3,[R4, #+0]
   \       0x6A   0x22A4             MOVS     R2,#+164
   \       0x6C   0x5099             STR      R1,[R3, R2]
   1311                  if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
   \       0x6E   0x6821             LDR      R1,[R4, #+0]
   \       0x70   0x22A8             MOVS     R2,#+168
   \       0x72   0x5889             LDR      R1,[R1, R2]
   \       0x74   0x6822             LDR      R2,[R4, #+0]
   \       0x76   0x23A4             MOVS     R3,#+164
   \       0x78   0x58D2             LDR      R2,[R2, R3]
   \       0x7A   0x4291             CMP      R1,R2
   \       0x7C   0xD205             BCS      ??OSTaskSemPend_7
   1312                      OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
   \       0x7E   0x6821             LDR      R1,[R4, #+0]
   \       0x80   0x22A4             MOVS     R2,#+164
   \       0x82   0x5889             LDR      R1,[R1, R2]
   \       0x84   0x6822             LDR      R2,[R4, #+0]
   \       0x86   0x23A8             MOVS     R3,#+168
   \       0x88   0x50D1             STR      R1,[R2, R3]
   1313                  }
   1314          #endif
   1315                  CPU_CRITICAL_EXIT();
   \                     ??OSTaskSemPend_7: (+1)
   \       0x8A   0x....'....        BL       CPU_SR_Restore
   1316                 *p_err = OS_ERR_NONE;
   \       0x8E   0x8035             STRH     R5,[R6, #+0]
   1317                  return (ctr);
   \       0x90   0x0038             MOVS     R0,R7
   \       0x92   0xE06B             B        ??OSTaskSemPend_1
   1318              }
   \                     ??OSTaskSemPend_3: (+1)
   \       0x94   0x....             LDR      R0,??DataTable13_3  ;; 0x5e25
   \       0x96   0x8030             STRH     R0,[R6, #+0]
   \       0x98   0x2000             MOVS     R0,#+0
   \       0x9A   0xE067             B        ??OSTaskSemPend_1
   1319          
   1320              if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
   \                     ??OSTaskSemPend_5: (+1)
   \       0x9C   0x0439             LSLS     R1,R7,#+16
   \       0x9E   0xD505             BPL      ??OSTaskSemPend_8
   1321                  CPU_CRITICAL_EXIT();
   \       0xA0   0x....'....        BL       CPU_SR_Restore
   1322                 *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
   \       0xA4   0x....             LDR      R0,??DataTable14  ;; 0x61b0
   \       0xA6   0x8030             STRH     R0,[R6, #+0]
   1323                  return ((OS_SEM_CTR)0);
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0xE05F             B        ??OSTaskSemPend_1
   1324              } else {                                                /* Yes                                                    */
   1325                  if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
   \                     ??OSTaskSemPend_8: (+1)
   \       0xAC   0x....             LDR      R7,??DataTable14_1
   \       0xAE   0x7839             LDRB     R1,[R7, #+0]
   \       0xB0   0x2900             CMP      R1,#+0
   \       0xB2   0xD005             BEQ      ??OSTaskSemPend_9
   1326                      CPU_CRITICAL_EXIT();
   \       0xB4   0x....'....        BL       CPU_SR_Restore
   1327                     *p_err = OS_ERR_SCHED_LOCKED;
   \       0xB8   0x....             LDR      R0,??DataTable14_2  ;; 0x6d63
   \       0xBA   0x8030             STRH     R0,[R6, #+0]
   1328                      return ((OS_SEM_CTR)0);
   \       0xBC   0x2000             MOVS     R0,#+0
   \       0xBE   0xE055             B        ??OSTaskSemPend_1
   1329                  }
   1330              }
   1331                                                                      /* Lock the scheduler/re-enable interrupts                */
   1332              OS_CRITICAL_ENTER_CPU_EXIT();                           
   \                     ??OSTaskSemPend_9: (+1)
   \       0xC0   0x7839             LDRB     R1,[R7, #+0]
   \       0xC2   0x1C49             ADDS     R1,R1,#+1
   \       0xC4   0x7039             STRB     R1,[R7, #+0]
   \       0xC6   0x....'....        BL       CPU_SR_Restore
   1333              OS_Pend((OS_PEND_DATA *)0,                              /* Block task pending on Signal                           */
   1334                      (OS_PEND_OBJ  *)0,
   1335                      (OS_STATE      )OS_TASK_PEND_ON_TASK_SEM,
   1336                      (OS_TICK       )timeout);
   \       0xCA   0x9B02             LDR      R3,[SP, #+8]
   \       0xCC   0x2207             MOVS     R2,#+7
   \       0xCE   0x2100             MOVS     R1,#+0
   \       0xD0   0x2000             MOVS     R0,#+0
   \       0xD2   0x....'....        BL       OS_Pend
   1337              OS_CRITICAL_EXIT_NO_SCHED();
   \       0xD6   0x....'....        BL       CPU_SR_Save
   \       0xDA   0x7839             LDRB     R1,[R7, #+0]
   \       0xDC   0x1E49             SUBS     R1,R1,#+1
   \       0xDE   0x7039             STRB     R1,[R7, #+0]
   \       0xE0   0x....'....        BL       CPU_SR_Restore
   1338          
   1339              OSSched();                                              /* Find next highest priority task ready to run           */
   \       0xE4   0x....'....        BL       OSSched
   1340          
   1341              CPU_CRITICAL_ENTER();
   \       0xE8   0x....'....        BL       CPU_SR_Save
   1342              switch (OSTCBCurPtr->PendStatus) {                      /* See if we timed-out or aborted                         */
   \       0xEC   0x6821             LDR      R1,[R4, #+0]
   \       0xEE   0x2235             MOVS     R2,#+53
   \       0xF0   0x5C89             LDRB     R1,[R1, R2]
   \       0xF2   0x2900             CMP      R1,#+0
   \       0xF4   0xD004             BEQ      ??OSTaskSemPend_10
   \       0xF6   0x2901             CMP      R1,#+1
   \       0xF8   0xD01F             BEQ      ??OSTaskSemPend_11
   \       0xFA   0x2903             CMP      R1,#+3
   \       0xFC   0xD027             BEQ      ??OSTaskSemPend_12
   \       0xFE   0xE02E             B        ??OSTaskSemPend_13
   1343                  case OS_STATUS_PEND_OK:
   1344                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSTaskSemPend_10: (+1)
   \      0x100   0x9900             LDR      R1,[SP, #+0]
   \      0x102   0x2900             CMP      R1,#+0
   \      0x104   0xD017             BEQ      ??OSTaskSemPend_14
   1345                          *p_ts                    =  OSTCBCurPtr->TS;
   \      0x106   0x6821             LDR      R1,[R4, #+0]
   \      0x108   0x6C09             LDR      R1,[R1, #+64]
   \      0x10A   0x9A00             LDR      R2,[SP, #+0]
   \      0x10C   0x6011             STR      R1,[R2, #+0]
   1346          #if OS_CFG_TASK_PROFILE_EN > 0u
   1347                          OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
   \      0x10E   0x6821             LDR      R1,[R4, #+0]
   \      0x110   0x6C09             LDR      R1,[R1, #+64]
   \      0x112   0x424A             RSBS     R2,R1,#+0
   \      0x114   0x6821             LDR      R1,[R4, #+0]
   \      0x116   0x23A4             MOVS     R3,#+164
   \      0x118   0x50CA             STR      R2,[R1, R3]
   1348                          if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
   \      0x11A   0x6821             LDR      R1,[R4, #+0]
   \      0x11C   0x22A8             MOVS     R2,#+168
   \      0x11E   0x5889             LDR      R1,[R1, R2]
   \      0x120   0x6822             LDR      R2,[R4, #+0]
   \      0x122   0x23A4             MOVS     R3,#+164
   \      0x124   0x58D2             LDR      R2,[R2, R3]
   \      0x126   0x4291             CMP      R1,R2
   \      0x128   0xD205             BCS      ??OSTaskSemPend_14
   1349                              OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
   \      0x12A   0x6821             LDR      R1,[R4, #+0]
   \      0x12C   0x22A4             MOVS     R2,#+164
   \      0x12E   0x5889             LDR      R1,[R1, R2]
   \      0x130   0x6822             LDR      R2,[R4, #+0]
   \      0x132   0x23A8             MOVS     R3,#+168
   \      0x134   0x50D1             STR      R1,[R2, R3]
   1350                          }
   1351          #endif
   1352                       }
   1353                      *p_err = OS_ERR_NONE;
   \                     ??OSTaskSemPend_14: (+1)
   \      0x136   0x8035             STRH     R5,[R6, #+0]
   1354                       break;
   \      0x138   0xE013             B        ??OSTaskSemPend_15
   1355          
   1356                  case OS_STATUS_PEND_ABORT:
   1357                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSTaskSemPend_11: (+1)
   \      0x13A   0x9900             LDR      R1,[SP, #+0]
   \      0x13C   0x2900             CMP      R1,#+0
   \      0x13E   0xD003             BEQ      ??OSTaskSemPend_16
   1358                          *p_ts  =  OSTCBCurPtr->TS;
   \      0x140   0x6821             LDR      R1,[R4, #+0]
   \      0x142   0x6C09             LDR      R1,[R1, #+64]
   \      0x144   0x9A00             LDR      R2,[SP, #+0]
   \      0x146   0x6011             STR      R1,[R2, #+0]
   1359                       }
   1360                      *p_err = OS_ERR_PEND_ABORT;                     /* Indicate that we aborted                               */
   \                     ??OSTaskSemPend_16: (+1)
   \      0x148   0x....             LDR      R1,??DataTable15  ;; 0x61a9
   \      0x14A   0x8031             STRH     R1,[R6, #+0]
   1361                       break;
   \      0x14C   0xE009             B        ??OSTaskSemPend_15
   1362          
   1363                  case OS_STATUS_PEND_TIMEOUT:
   1364                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSTaskSemPend_12: (+1)
   \      0x14E   0x9900             LDR      R1,[SP, #+0]
   \      0x150   0x2900             CMP      R1,#+0
   \      0x152   0xD001             BEQ      ??OSTaskSemPend_17
   1365                          *p_ts  = (CPU_TS  )0;
   \      0x154   0x9900             LDR      R1,[SP, #+0]
   \      0x156   0x600D             STR      R5,[R1, #+0]
   1366                       }
   1367                      *p_err = OS_ERR_TIMEOUT;                        /* Indicate that we didn't get event within TO            */
   \                     ??OSTaskSemPend_17: (+1)
   \      0x158   0x....             LDR      R1,??DataTable15_1  ;; 0x72d9
   \      0x15A   0x8031             STRH     R1,[R6, #+0]
   1368                       break;
   \      0x15C   0xE001             B        ??OSTaskSemPend_15
   1369          
   1370                  default:
   1371                      *p_err = OS_ERR_STATUS_INVALID;
   \                     ??OSTaskSemPend_13: (+1)
   \      0x15E   0x....             LDR      R1,??DataTable17  ;; 0x6e2e
   \      0x160   0x8031             STRH     R1,[R6, #+0]
   1372                       break;
   1373              }
   1374              ctr = OSTCBCurPtr->SemCtr;
   \                     ??OSTaskSemPend_15: (+1)
   \      0x162   0x6821             LDR      R1,[R4, #+0]
   \      0x164   0x6C4C             LDR      R4,[R1, #+68]
   1375              CPU_CRITICAL_EXIT();
   \      0x166   0x....'....        BL       CPU_SR_Restore
   1376              return (ctr);
   \      0x16A   0x0020             MOVS     R0,R4
   \                     ??OSTaskSemPend_1: (+1)
   \      0x16C   0xBDFE             POP      {R1-R7,PC}       ;; return
   1377          }
   1378          
   1379          /*$PAGE*/
   1380          /*
   1381          ************************************************************************************************************************
   1382          *                                               ABORT WAITING FOR A SIGNAL
   1383          *
   1384          * Description: This function aborts & readies the task specified.  This function should be used to fault-abort the wait
   1385          *              for a signal, rather than to normally post the signal to the task via OSTaskSemPost().
   1386          *
   1387          * Arguments  : p_tcb     is a pointer to the task to pend abort
   1388          *
   1389          *              opt       provides options for this function:
   1390          *
   1391          *                            OS_OPT_POST_NONE         No option selected
   1392          *                            OS_OPT_POST_NO_SCHED     Indicates that the scheduler will not be called.
   1393          *
   1394          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
   1395          *
   1396          *                            OS_ERR_NONE              If the task was readied and informed of the aborted wait
   1397          *                            OS_ERR_PEND_ABORT_ISR    If you tried calling this function from an ISR
   1398          *                            OS_ERR_PEND_ABORT_NONE   If the task was not waiting for a signal
   1399          *                            OS_ERR_PEND_ABORT_SELF   If you attempted to pend abort the calling task.  This is not
   1400          *                                                     possible since the calling task cannot be pending because it's
   1401          *                                                     running.
   1402          *
   1403          * Returns    : == DEF_FALSE   if task was not waiting for a message, or upon error.
   1404          *              == DEF_TRUE    if task was waiting for a message and was readied and informed.
   1405          ************************************************************************************************************************
   1406          */
   1407          
   1408          #if OS_CFG_TASK_SEM_PEND_ABORT_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   1409          CPU_BOOLEAN  OSTaskSemPendAbort (OS_TCB  *p_tcb,
   1410                                           OS_OPT   opt,
   1411                                           OS_ERR  *p_err)
   1412          {
   \                     OSTaskSemPendAbort: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0014             MOVS     R4,R2
   1413              CPU_TS         ts;
   1414              CPU_SR_ALLOC();
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0x002A             MOVS     R2,R5
   1415          
   1416          
   1417          
   1418          #ifdef OS_SAFETY_CRITICAL
   1419              if (p_err == (OS_ERR *)0) {
   1420                  OS_SAFETY_CRITICAL_EXCEPTION();
   1421                  return (DEF_FALSE);
   1422              }
   1423          #endif
   1424          
   1425          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
   1426              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
   \        0x8   0x....             LDR      R2,??DataTable12
   \        0xA   0x7812             LDRB     R2,[R2, #+0]
   \        0xC   0x2A00             CMP      R2,#+0
   \        0xE   0xD003             BEQ      ??OSTaskSemPendAbort_0
   1427                 *p_err = OS_ERR_PEND_ABORT_ISR;                      /* ... can't Pend Abort from an ISR                       */
   \       0x10   0x....             LDR      R0,??DataTable16  ;; 0x61aa
   \       0x12   0x8020             STRH     R0,[R4, #+0]
   1428                  return (DEF_FALSE);
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xE044             B        ??OSTaskSemPendAbort_1
   1429              }
   \                     ??OSTaskSemPendAbort_0: (+1)
   \       0x18   0x000E             MOVS     R6,R1
   1430          #endif
   1431          
   1432          #if OS_CFG_ARG_CHK_EN > 0u
   1433              switch (opt) {                                          /* Validate 'opt'                                         */
   \       0x1A   0x0031             MOVS     R1,R6
   \       0x1C   0xB289             UXTH     R1,R1
   \       0x1E   0x2900             CMP      R1,#+0
   \       0x20   0xD003             BEQ      ??OSTaskSemPendAbort_2
   \       0x22   0x2280             MOVS     R2,#+128
   \       0x24   0x0212             LSLS     R2,R2,#+8        ;; #+32768
   \       0x26   0x4291             CMP      R1,R2
   \       0x28   0xD110             BNE      ??OSTaskSemPendAbort_3
   \                     ??OSTaskSemPendAbort_2: (+1)
   \       0x2A   0x9000             STR      R0,[SP, #+0]
   1434                  case OS_OPT_POST_NONE:
   1435                  case OS_OPT_POST_NO_SCHED:
   1436                       break;
   1437          
   1438                  default:
   1439                      *p_err =  OS_ERR_OPT_INVALID;
   1440                       return (DEF_FALSE);
   1441              }
   1442          #endif
   1443          
   1444              CPU_CRITICAL_ENTER();
   \       0x2C   0x....'....        BL       CPU_SR_Save
   1445              if ((p_tcb == (OS_TCB *)0) ||                           /* Pend abort self?                                       */
   1446                  (p_tcb == OSTCBCurPtr)) {
   \       0x30   0x9900             LDR      R1,[SP, #+0]
   \       0x32   0x2900             CMP      R1,#+0
   \       0x34   0xD004             BEQ      ??OSTaskSemPendAbort_4
   \       0x36   0x9900             LDR      R1,[SP, #+0]
   \       0x38   0x....             LDR      R2,??DataTable13_2
   \       0x3A   0x6812             LDR      R2,[R2, #+0]
   \       0x3C   0x4291             CMP      R1,R2
   \       0x3E   0xD109             BNE      ??OSTaskSemPendAbort_5
   1447                  CPU_CRITICAL_EXIT();                                /* ... doesn't make sense!                                */
   \                     ??OSTaskSemPendAbort_4: (+1)
   \       0x40   0x....'....        BL       CPU_SR_Restore
   1448                 *p_err = OS_ERR_PEND_ABORT_SELF;
   \       0x44   0x....             LDR      R0,??DataTable17_1  ;; 0x61ac
   \       0x46   0x8020             STRH     R0,[R4, #+0]
   1449                  return (DEF_FALSE);
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xE02A             B        ??OSTaskSemPendAbort_1
   1450              }
   \                     ??OSTaskSemPendAbort_3: (+1)
   \       0x4C   0x....             LDR      R0,??DataTable13_3  ;; 0x5e25
   \       0x4E   0x8020             STRH     R0,[R4, #+0]
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xE026             B        ??OSTaskSemPendAbort_1
   1451          
   1452              if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_SEM) {        /* Is task waiting for a signal?                          */
   \                     ??OSTaskSemPendAbort_5: (+1)
   \       0x54   0x9900             LDR      R1,[SP, #+0]
   \       0x56   0x2234             MOVS     R2,#+52
   \       0x58   0x5C89             LDRB     R1,[R1, R2]
   \       0x5A   0x2907             CMP      R1,#+7
   \       0x5C   0xD005             BEQ      ??OSTaskSemPendAbort_6
   1453                  CPU_CRITICAL_EXIT();
   \       0x5E   0x....'....        BL       CPU_SR_Restore
   1454                 *p_err = OS_ERR_PEND_ABORT_NONE;
   \       0x62   0x....             LDR      R0,??DataTable18  ;; 0x61ab
   \       0x64   0x8020             STRH     R0,[R4, #+0]
   1455                  return (DEF_FALSE);
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xE01B             B        ??OSTaskSemPendAbort_1
   1456              }
   1457              CPU_CRITICAL_EXIT();
   \                     ??OSTaskSemPendAbort_6: (+1)
   \       0x6A   0x....'....        BL       CPU_SR_Restore
   1458          
   1459              OS_CRITICAL_ENTER();
   \       0x6E   0x....'....        BL       CPU_SR_Save
   \       0x72   0x....             LDR      R7,??DataTable14_1
   \       0x74   0x7839             LDRB     R1,[R7, #+0]
   \       0x76   0x1C49             ADDS     R1,R1,#+1
   \       0x78   0x7039             STRB     R1,[R7, #+0]
   \       0x7A   0x....'....        BL       CPU_SR_Restore
   1460              ts = OS_TS_GET();
   \       0x7E   0x002A             MOVS     R2,R5
   1461              OS_PendAbort((OS_PEND_OBJ *)0,
   1462                           p_tcb,
   1463                           ts);
   \       0x80   0x9900             LDR      R1,[SP, #+0]
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0x....'....        BL       OS_PendAbort
   1464              OS_CRITICAL_EXIT_NO_SCHED();
   \       0x88   0x....'....        BL       CPU_SR_Save
   \       0x8C   0x7839             LDRB     R1,[R7, #+0]
   \       0x8E   0x1E49             SUBS     R1,R1,#+1
   \       0x90   0x7039             STRB     R1,[R7, #+0]
   \       0x92   0x....'....        BL       CPU_SR_Restore
   1465              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
   \       0x96   0x0430             LSLS     R0,R6,#+16
   \       0x98   0xD401             BMI      ??OSTaskSemPendAbort_7
   1466                  OSSched();                                          /* Run the scheduler                                      */
   \       0x9A   0x....'....        BL       OSSched
   1467              }
   1468             *p_err = OS_ERR_NONE;
   \                     ??OSTaskSemPendAbort_7: (+1)
   \       0x9E   0x8025             STRH     R5,[R4, #+0]
   1469              return (DEF_TRUE);
   \       0xA0   0x2001             MOVS     R0,#+1
   \                     ??OSTaskSemPendAbort_1: (+1)
   \       0xA2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1470          }
   1471          #endif
   1472          
   1473          /*$PAGE*/
   1474          /*
   1475          ************************************************************************************************************************
   1476          *                                                    SIGNAL A TASK
   1477          *
   1478          * Description: This function is called to signal a task waiting for a signal.
   1479          *
   1480          * Arguments  : p_tcb     is the pointer to the TCB of the task to signal.  A NULL pointer indicates that you are sending
   1481          *                        a signal to yourself.
   1482          *
   1483          *              opt       determines the type of POST performed:
   1484          *
   1485          *                             OS_OPT_POST_NONE         No option
   1486          *                             OS_OPT_POST_NO_SCHED     Do not call the scheduler
   1487          *
   1488          *              p_err     is a pointer to an error code returned by this function:
   1489          *
   1490          *                            OS_ERR_NONE              If the requested task is signaled
   1491          *                            OS_ERR_SEM_OVF           If the post would cause the semaphore count to overflow.
   1492          *
   1493          * Returns    : The current value of the task's signal counter or 0 if called from an ISR
   1494          ************************************************************************************************************************
   1495          */
   1496          

   \                                 In section .text, align 2, keep-with-next
   1497          OS_SEM_CTR  OSTaskSemPost (OS_TCB  *p_tcb,
   1498                                     OS_OPT   opt,
   1499                                     OS_ERR  *p_err)
   1500          {
   \                     OSTaskSemPost: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x0013             MOVS     R3,R2
   1501              OS_SEM_CTR  ctr;
   1502              CPU_TS      ts;
   1503          
   1504          
   1505          
   1506          #ifdef OS_SAFETY_CRITICAL
   1507              if (p_err == (OS_ERR *)0) {
   1508                  OS_SAFETY_CRITICAL_EXCEPTION();
   1509                  return ((OS_SEM_CTR)0);
   1510              }
   1511          #endif
   1512          
   1513          #if OS_CFG_ARG_CHK_EN > 0u
   1514              switch (opt) {                                          /* Validate 'opt'                                         */
   \        0x4   0x000A             MOVS     R2,R1
   \        0x6   0xB292             UXTH     R2,R2
   \        0x8   0x2A00             CMP      R2,#+0
   \        0xA   0xD003             BEQ      ??OSTaskSemPost_0
   \        0xC   0x2480             MOVS     R4,#+128
   \        0xE   0x0224             LSLS     R4,R4,#+8        ;; #+32768
   \       0x10   0x42A2             CMP      R2,R4
   \       0x12   0xD109             BNE      ??OSTaskSemPost_1
   1515                  case OS_OPT_POST_NONE:
   1516                  case OS_OPT_POST_NO_SCHED:
   1517                       break;
   1518          
   1519                  default:
   1520                      *p_err =  OS_ERR_OPT_INVALID;
   1521                       return ((OS_SEM_CTR)0u);
   1522              }
   1523          #endif
   1524          
   1525              ts = OS_TS_GET();                                       /* Get timestamp                                          */
   \                     ??OSTaskSemPost_0: (+1)
   \       0x14   0x2200             MOVS     R2,#+0
   1526          
   1527          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
   1528              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
   \       0x16   0x....             LDR      R4,??DataTable12
   \       0x18   0x7824             LDRB     R4,[R4, #+0]
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD108             BNE      ??OSTaskSemPost_2
   1529                  OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_SIGNAL,   /* Post to ISR queue                                      */
   1530                              (void      *)p_tcb,
   1531                              (void      *)0,
   1532                              (OS_MSG_SIZE)0,
   1533                              (OS_FLAGS   )0,
   1534                              (OS_OPT     )0,
   1535                              (CPU_TS     )ts,
   1536                              (OS_ERR    *)p_err);
   1537                  return ((OS_SEM_CTR)0);
   1538              }
   1539          #endif
   1540          
   1541              ctr = OS_TaskSemPost(p_tcb,
   1542                                   opt,
   1543                                   ts,
   1544                                   p_err);
   \       0x1E   0xB289             UXTH     R1,R1
   \       0x20   0x....'....        BL       OS_TaskSemPost
   1545          
   1546              return (ctr);
   \                     ??OSTaskSemPost_3: (+1)
   \       0x24   0xB004             ADD      SP,SP,#+16
   \       0x26   0xBD10             POP      {R4,PC}          ;; return
   \                     ??OSTaskSemPost_1: (+1)
   \       0x28   0x....             LDR      R0,??DataTable13_3  ;; 0x5e25
   \       0x2A   0x8018             STRH     R0,[R3, #+0]
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xE7F9             B        ??OSTaskSemPost_3
   \                     ??OSTaskSemPost_2: (+1)
   \       0x30   0x9303             STR      R3,[SP, #+12]
   \       0x32   0x9202             STR      R2,[SP, #+8]
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0x9101             STR      R1,[SP, #+4]
   \       0x38   0x2100             MOVS     R1,#+0
   \       0x3A   0x9100             STR      R1,[SP, #+0]
   \       0x3C   0x2300             MOVS     R3,#+0
   \       0x3E   0x2200             MOVS     R2,#+0
   \       0x40   0x0001             MOVS     R1,R0
   \       0x42   0x....             LDR      R0,??DataTable20  ;; 0x47495354
   \       0x44   0x....'....        BL       OS_IntQPost
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xE7EB             B        ??OSTaskSemPost_3
   1547          }
   1548          
   1549          /*$PAGE*/
   1550          /*
   1551          ************************************************************************************************************************
   1552          *                                            SET THE SIGNAL COUNTER OF A TASK
   1553          *
   1554          * Description: This function is called to clear the signal counter
   1555          *
   1556          * Arguments  : p_tcb      is the pointer to the TCB of the task to clear the counter.  If you specify a NULL pointer
   1557          *                         then the signal counter of the current task will be cleared.
   1558          *
   1559          *              cnt        is the desired value of the semaphore counter
   1560          *
   1561          *              p_err      is a pointer to an error code returned by this function
   1562          *
   1563          *                             OS_ERR_NONE        if the signal counter of the requested task is cleared
   1564          *                             OS_ERR_SET_ISR     if the function was called from an ISR
   1565          *
   1566          * Returns    : none
   1567          ************************************************************************************************************************
   1568          */
   1569          

   \                                 In section .text, align 2, keep-with-next
   1570          OS_SEM_CTR  OSTaskSemSet (OS_TCB      *p_tcb,
   1571                                    OS_SEM_CTR   cnt,
   1572                                    OS_ERR      *p_err)
   1573          {
   \                     OSTaskSemSet: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x000C             MOVS     R4,R1
   \        0x4   0x0017             MOVS     R7,R2
   1574              OS_SEM_CTR  ctr;
   1575              CPU_SR_ALLOC();
   \        0x6   0x2500             MOVS     R5,#+0
   \        0x8   0x0029             MOVS     R1,R5
   1576          
   1577          
   1578          
   1579          #ifdef OS_SAFETY_CRITICAL
   1580              if (p_err == (OS_ERR *)0) {
   1581                  OS_SAFETY_CRITICAL_EXCEPTION();
   1582                  return ((OS_SEM_CTR)0);
   1583              }
   1584          #endif
   1585          
   1586          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
   1587              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   \        0xA   0x....             LDR      R1,??DataTable19
   \        0xC   0x7809             LDRB     R1,[R1, #+0]
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD003             BEQ      ??OSTaskSemSet_0
   1588                 *p_err = OS_ERR_SET_ISR;
   \       0x12   0x....             LDR      R0,??DataTable19_1  ;; 0x6dc6
   \       0x14   0x8038             STRH     R0,[R7, #+0]
   1589                  return ((OS_SEM_CTR)0);
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE00D             B        ??OSTaskSemSet_1
   1590              }
   \                     ??OSTaskSemSet_0: (+1)
   \       0x1A   0x0006             MOVS     R6,R0
   1591          #endif
   1592          
   1593              CPU_CRITICAL_ENTER();
   \       0x1C   0x....'....        BL       CPU_SR_Save
   1594              if (p_tcb == (OS_TCB *)0) {
   \       0x20   0x2E00             CMP      R6,#+0
   \       0x22   0xD101             BNE      ??OSTaskSemSet_2
   1595                  p_tcb = OSTCBCurPtr;
   \       0x24   0x....             LDR      R1,??DataTable20_1
   \       0x26   0x680E             LDR      R6,[R1, #+0]
   \                     ??OSTaskSemSet_2: (+1)
   \       0x28   0x0021             MOVS     R1,R4
   1596              }
   1597              ctr           = p_tcb->SemCtr;
   \       0x2A   0x6C74             LDR      R4,[R6, #+68]
   1598              p_tcb->SemCtr = (OS_SEM_CTR)cnt;
   \       0x2C   0x6471             STR      R1,[R6, #+68]
   1599              CPU_CRITICAL_EXIT();
   \       0x2E   0x....'....        BL       CPU_SR_Restore
   1600             *p_err         =  OS_ERR_NONE;
   \       0x32   0x803D             STRH     R5,[R7, #+0]
   1601              return (ctr);
   \       0x34   0x0020             MOVS     R0,R4
   \                     ??OSTaskSemSet_1: (+1)
   \       0x36   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1602          }
   1603          
   1604          /*$PAGE*/
   1605          /*
   1606          ************************************************************************************************************************
   1607          *                                                    STACK CHECKING
   1608          *
   1609          * Description: This function is called to calculate the amount of free memory left on the specified task's stack.
   1610          *
   1611          * Arguments  : p_tcb       is a pointer to the TCB of the task to check.  If you specify a NULL pointer then
   1612          *                          you are specifying that you want to check the stack of the current task.
   1613          *
   1614          *              p_free      is a pointer to a variable that will receive the number of free 'entries' on the task's stack.
   1615          *
   1616          *              p_used      is a pointer to a variable that will receive the number of used 'entries' on the task's stack.
   1617          *
   1618          *              p_err       is a pointer to a variable that will contain an error code.
   1619          *
   1620          *                              OS_ERR_NONE               upon success
   1621          *                              OS_ERR_PTR_INVALID        if either 'p_free' or 'p_used' are NULL pointers
   1622          *                              OS_ERR_TASK_NOT_EXIST     if the stack pointer of the task is a NULL pointer
   1623          *                              OS_ERR_TASK_OPT           if you did NOT specified OS_OPT_TASK_STK_CHK when the task
   1624          *                                                        was created
   1625          *                              OS_ERR_TASK_STK_CHK_ISR   you called this function from an ISR
   1626          ************************************************************************************************************************
   1627          */
   1628          
   1629          #if OS_CFG_STAT_TASK_STK_CHK_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   1630          void  OSTaskStkChk (OS_TCB        *p_tcb,
   1631                              CPU_STK_SIZE  *p_free,
   1632                              CPU_STK_SIZE  *p_used,
   1633                              OS_ERR        *p_err)
   1634          {
   \                     OSTaskStkChk: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x001C             MOVS     R4,R3
   1635              CPU_STK_SIZE  free_stk;
   1636              CPU_STK      *p_stk;
   1637              CPU_SR_ALLOC();
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0x002B             MOVS     R3,R5
   1638          
   1639          
   1640          
   1641          #ifdef OS_SAFETY_CRITICAL
   1642              if (p_err == (OS_ERR *)0) {
   1643                  OS_SAFETY_CRITICAL_EXCEPTION();
   1644                  return;
   1645              }
   1646          #endif
   1647          
   1648          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
   1649              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to check stack from ISR                  */
   \        0x8   0x....             LDR      R3,??DataTable19
   \        0xA   0x781B             LDRB     R3,[R3, #+0]
   \        0xC   0x2B00             CMP      R3,#+0
   \        0xE   0xD002             BEQ      ??OSTaskStkChk_0
   1650                 *p_err = OS_ERR_TASK_STK_CHK_ISR;
   \       0x10   0x....             LDR      R0,??DataTable20_2  ;; 0x7159
   \       0x12   0x8020             STRH     R0,[R4, #+0]
   1651                  return;
   \       0x14   0xE03A             B        ??OSTaskStkChk_1
   1652              }
   \                     ??OSTaskStkChk_0: (+1)
   \       0x16   0x9100             STR      R1,[SP, #+0]
   1653          #endif
   1654          
   1655          #if OS_CFG_ARG_CHK_EN > 0u
   1656              if (p_free == (CPU_STK_SIZE*)0) {                       /* User must specify valid destinations for the sizes     */
   \       0x18   0x9900             LDR      R1,[SP, #+0]
   \       0x1A   0x2900             CMP      R1,#+0
   \       0x1C   0xD102             BNE      ??OSTaskStkChk_2
   1657                 *p_err  = OS_ERR_PTR_INVALID;
   \       0x1E   0x....             LDR      R0,??DataTable20_3  ;; 0x62d5
   \       0x20   0x8020             STRH     R0,[R4, #+0]
   1658                  return;
   \       0x22   0xE033             B        ??OSTaskStkChk_1
   1659              }
   \                     ??OSTaskStkChk_2: (+1)
   \       0x24   0x0017             MOVS     R7,R2
   1660          
   1661              if (p_used == (CPU_STK_SIZE*)0) {
   \       0x26   0x2F00             CMP      R7,#+0
   \       0x28   0xD102             BNE      ??OSTaskStkChk_3
   1662                 *p_err  = OS_ERR_PTR_INVALID;
   \       0x2A   0x....             LDR      R0,??DataTable20_3  ;; 0x62d5
   \       0x2C   0x8020             STRH     R0,[R4, #+0]
   1663                  return;
   \       0x2E   0xE02D             B        ??OSTaskStkChk_1
   1664              }
   \                     ??OSTaskStkChk_3: (+1)
   \       0x30   0x0006             MOVS     R6,R0
   1665          #endif
   1666          
   1667              CPU_CRITICAL_ENTER();
   \       0x32   0x....'....        BL       CPU_SR_Save
   1668              if (p_tcb == (OS_TCB *)0) {                             /* Check the stack of the current task?                   */
   \       0x36   0x2E00             CMP      R6,#+0
   \       0x38   0xD101             BNE      ??OSTaskStkChk_4
   1669                  p_tcb = OSTCBCurPtr;                                /* Yes                                                    */
   \       0x3A   0x....             LDR      R1,??DataTable20_1
   \       0x3C   0x680E             LDR      R6,[R1, #+0]
   1670              }
   1671          
   1672              if (p_tcb->StkPtr == (CPU_STK*)0) {                     /* Make sure task exist                                   */
   \                     ??OSTaskStkChk_4: (+1)
   \       0x3E   0x6831             LDR      R1,[R6, #+0]
   \       0x40   0x2900             CMP      R1,#+0
   \       0x42   0xD107             BNE      ??OSTaskStkChk_5
   1673                  CPU_CRITICAL_EXIT();
   \       0x44   0x....'....        BL       CPU_SR_Restore
   1674                 *p_free = (CPU_STK_SIZE)0;
   \       0x48   0x9800             LDR      R0,[SP, #+0]
   \       0x4A   0x6005             STR      R5,[R0, #+0]
   1675                 *p_used = (CPU_STK_SIZE)0;
   \       0x4C   0x603D             STR      R5,[R7, #+0]
   1676                 *p_err  =  OS_ERR_TASK_NOT_EXIST;
   \       0x4E   0x....             LDR      R0,??DataTable20_4  ;; 0x7152
   \       0x50   0x8020             STRH     R0,[R4, #+0]
   1677                  return;
   \       0x52   0xE01B             B        ??OSTaskStkChk_1
   1678              }
   1679          
   1680              if ((p_tcb->Opt & OS_OPT_TASK_STK_CHK) == (OS_OPT)0) {  /* Make sure stack checking option is set                 */
   \                     ??OSTaskStkChk_5: (+1)
   \       0x54   0x213C             MOVS     R1,#+60
   \       0x56   0x5C71             LDRB     R1,[R6, R1]
   \       0x58   0x07C9             LSLS     R1,R1,#+31
   \       0x5A   0xD407             BMI      ??OSTaskStkChk_6
   1681                  CPU_CRITICAL_EXIT();
   \       0x5C   0x....'....        BL       CPU_SR_Restore
   1682                 *p_free = (CPU_STK_SIZE)0;
   \       0x60   0x9800             LDR      R0,[SP, #+0]
   \       0x62   0x6005             STR      R5,[R0, #+0]
   1683                 *p_used = (CPU_STK_SIZE)0;
   \       0x64   0x603D             STR      R5,[R7, #+0]
   1684                 *p_err  =  OS_ERR_TASK_OPT;
   \       0x66   0x....             LDR      R0,??DataTable20_5  ;; 0x7154
   \       0x68   0x8020             STRH     R0,[R4, #+0]
   1685                  return;
   \       0x6A   0xE00F             B        ??OSTaskStkChk_1
   1686              }
   1687              CPU_CRITICAL_EXIT();
   \                     ??OSTaskStkChk_6: (+1)
   \       0x6C   0x....'....        BL       CPU_SR_Restore
   1688          
   1689              free_stk  = 0u;
   \       0x70   0x0028             MOVS     R0,R5
   1690          #if CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO
   1691              p_stk = p_tcb->StkBasePtr;                              /* Start at the lowest memory and go up                   */
   \       0x72   0x6A71             LDR      R1,[R6, #+36]
   \       0x74   0xE001             B        ??OSTaskStkChk_7
   1692              while (*p_stk == (CPU_STK)0) {                          /* Compute the number of zero entries on the stk          */
   1693                  p_stk++;
   \                     ??OSTaskStkChk_8: (+1)
   \       0x76   0x1D09             ADDS     R1,R1,#+4
   1694                  free_stk++;
   \       0x78   0x1C40             ADDS     R0,R0,#+1
   1695              }
   \                     ??OSTaskStkChk_7: (+1)
   \       0x7A   0x680A             LDR      R2,[R1, #+0]
   \       0x7C   0x2A00             CMP      R2,#+0
   \       0x7E   0xD0FA             BEQ      ??OSTaskStkChk_8
   1696          #else
   1697              p_stk = p_tcb->StkBasePtr + p_tcb->StkSize - 1u;        /* Start at the highest memory and go down                */
   1698              while (*p_stk == (CPU_STK)0) {
   1699                  free_stk++;
   1700                  p_stk--;
   1701              }
   1702          #endif
   1703             *p_free = free_stk;
   \       0x80   0x9900             LDR      R1,[SP, #+0]
   \       0x82   0x6008             STR      R0,[R1, #+0]
   1704             *p_used = (p_tcb->StkSize - free_stk);                   /* Compute number of entries used on the stack            */
   \       0x84   0x6BB1             LDR      R1,[R6, #+56]
   \       0x86   0x1A08             SUBS     R0,R1,R0
   \       0x88   0x6038             STR      R0,[R7, #+0]
   1705             *p_err  = OS_ERR_NONE;
   \       0x8A   0x8025             STRH     R5,[R4, #+0]
   1706          }
   \                     ??OSTaskStkChk_1: (+1)
   \       0x8C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1707          #endif
   1708          
   1709          /*$PAGE*/
   1710          /*
   1711          ************************************************************************************************************************
   1712          *                                                   SUSPEND A TASK
   1713          *
   1714          * Description: This function is called to suspend a task.  The task can be the calling task if 'p_tcb' is a NULL pointer
   1715          *              or the pointer to the TCB of the calling task.
   1716          *
   1717          * Arguments  : p_tcb    is a pointer to the TCB to suspend.
   1718          *                       If p_tcb is a NULL pointer then, suspend the current task.
   1719          *
   1720          *              p_err    is a pointer to a variable that will receive an error code from this function.
   1721          *
   1722          *                           OS_ERR_NONE                      if the requested task is suspended
   1723          *                           OS_ERR_SCHED_LOCKED              you can't suspend the current task is the scheduler is
   1724          *                                                            locked
   1725          *                           OS_ERR_TASK_SUSPEND_ISR          if you called this function from an ISR
   1726          *                           OS_ERR_TASK_SUSPEND_IDLE         if you attempted to suspend the idle task which is not
   1727          *                                                            allowed.
   1728          *                           OS_ERR_TASK_SUSPEND_INT_HANDLER  if you attempted to suspend the idle task which is not
   1729          *                                                            allowed.
   1730          *
   1731          * Note(s)    : 1) You should use this function with great care.  If you suspend a task that is waiting for an event
   1732          *                 (i.e. a message, a semaphore, a queue ...) you will prevent this task from running when the event
   1733          *                 arrives.
   1734          ************************************************************************************************************************
   1735          */
   1736          
   1737          #if OS_CFG_TASK_SUSPEND_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   1738          void   OSTaskSuspend (OS_TCB  *p_tcb,
   1739                                OS_ERR  *p_err)
   1740          {
   \                     OSTaskSuspend: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   1741          #ifdef OS_SAFETY_CRITICAL
   1742              if (p_err == (OS_ERR *)0) {
   1743                  OS_SAFETY_CRITICAL_EXCEPTION();
   1744                  return;
   1745              }
   1746          #endif
   1747          
   1748          #if (OS_CFG_ISR_POST_DEFERRED_EN   == 0u) && \
   1749              (OS_CFG_CALLED_FROM_ISR_CHK_EN >  0u)
   1750              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   1751                 *p_err = OS_ERR_TASK_SUSPEND_ISR;
   1752                  return;
   1753              }
   1754          #endif
   1755          
   1756              if (p_tcb == &OSIdleTaskTCB) {                          /* Make sure not suspending the idle task                 */
   \        0x2   0x....             LDR      R2,??DataTable20_6
   \        0x4   0x4290             CMP      R0,R2
   \        0x6   0xD102             BNE      ??OSTaskSuspend_0
   1757                 *p_err = OS_ERR_TASK_SUSPEND_IDLE;
   \        0x8   0x....             LDR      R0,??DataTable20_7  ;; 0x715b
   \        0xA   0x8008             STRH     R0,[R1, #+0]
   1758                  return;
   \        0xC   0xE019             B        ??OSTaskSuspend_1
   1759              }
   1760          
   1761          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
   1762              if (p_tcb == &OSIntQTaskTCB) {                          /* Not allowed to suspend the ISR handler task            */
   \                     ??OSTaskSuspend_0: (+1)
   \        0xE   0x....             LDR      R2,??DataTable20_8
   \       0x10   0x4290             CMP      R0,R2
   \       0x12   0xD102             BNE      ??OSTaskSuspend_2
   1763                 *p_err = OS_ERR_TASK_SUSPEND_INT_HANDLER;
   \       0x14   0x....             LDR      R0,??DataTable20_9  ;; 0x715c
   \       0x16   0x8008             STRH     R0,[R1, #+0]
   1764                  return;
   \       0x18   0xE013             B        ??OSTaskSuspend_1
   1765              }
   1766          
   1767              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
   \                     ??OSTaskSuspend_2: (+1)
   \       0x1A   0x....             LDR      R2,??DataTable19
   \       0x1C   0x7812             LDRB     R2,[R2, #+0]
   \       0x1E   0x2A00             CMP      R2,#+0
   \       0x20   0xD00D             BEQ      ??OSTaskSuspend_3
   1768                  OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_SUSPEND,  /* Post to ISR queue                                      */
   1769                              (void      *)p_tcb,
   1770                              (void      *)0,
   1771                              (OS_MSG_SIZE)0,
   1772                              (OS_FLAGS   )0,
   1773                              (OS_OPT     )0,
   1774                              (CPU_TS     )0,
   1775                              (OS_ERR    *)p_err);
   \       0x22   0x9103             STR      R1,[SP, #+12]
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x9102             STR      R1,[SP, #+8]
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x9101             STR      R1,[SP, #+4]
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x9100             STR      R1,[SP, #+0]
   \       0x30   0x2300             MOVS     R3,#+0
   \       0x32   0x2200             MOVS     R2,#+0
   \       0x34   0x0001             MOVS     R1,R0
   \       0x36   0x....             LDR      R0,??DataTable20_10  ;; 0x53555354
   \       0x38   0x....'....        BL       OS_IntQPost
   1776                  return;
   \       0x3C   0xE001             B        ??OSTaskSuspend_1
   1777              }
   1778          #endif
   1779          
   1780              OS_TaskSuspend(p_tcb, p_err);
   \                     ??OSTaskSuspend_3: (+1)
   \       0x3E   0x....'....        BL       OS_TaskSuspend
   1781          }
   \                     ??OSTaskSuspend_1: (+1)
   \       0x42   0xB005             ADD      SP,SP,#+20
   \       0x44   0xBD00             POP      {PC}             ;; return
   1782          #endif
   1783          
   1784          /*$PAGE*/
   1785          /*
   1786          ************************************************************************************************************************
   1787          *                                                CHANGE A TASK'S TIME SLICE
   1788          *
   1789          * Description: This function is called to change the value of the task's specific time slice.
   1790          *
   1791          * Arguments  : p_tcb        is the pointer to the TCB of the task to change. If you specify an NULL pointer, the current
   1792          *                           task is assumed.
   1793          *
   1794          *              time_quanta  is the number of ticks before the CPU is taken away when round-robin scheduling is enabled.
   1795          *
   1796          *              p_err        is a pointer to an error code returned by this function:
   1797          *
   1798          *                               OS_ERR_NONE       upon success
   1799          *                               OS_ERR_SET_ISR    if you called this function from an ISR
   1800          *
   1801          * Returns    : none
   1802          ************************************************************************************************************************
   1803          */
   1804          
   1805          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   1806          void  OSTaskTimeQuantaSet (OS_TCB   *p_tcb,
   1807                                     OS_TICK   time_quanta,
   1808                                     OS_ERR   *p_err)
   1809          {
   \                     OSTaskTimeQuantaSet: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x000C             MOVS     R4,R1
   \        0x4   0x0017             MOVS     R7,R2
   1810              CPU_SR_ALLOC();
   \        0x6   0x2500             MOVS     R5,#+0
   \        0x8   0x0029             MOVS     R1,R5
   1811          
   1812          
   1813          
   1814          #ifdef OS_SAFETY_CRITICAL
   1815              if (p_err == (OS_ERR *)0) {
   1816                  OS_SAFETY_CRITICAL_EXCEPTION();
   1817                  return;
   1818              }
   1819          #endif
   1820          
   1821          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
   1822              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
   \        0xA   0x....             LDR      R1,??DataTable19
   \        0xC   0x7809             LDRB     R1,[R1, #+0]
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD002             BEQ      ??OSTaskTimeQuantaSet_0
   1823                 *p_err = OS_ERR_SET_ISR;
   \       0x12   0x....             LDR      R0,??DataTable19_1  ;; 0x6dc6
   \       0x14   0x8038             STRH     R0,[R7, #+0]
   1824                  return;
   \       0x16   0xE016             B        ??OSTaskTimeQuantaSet_1
   1825              }
   \                     ??OSTaskTimeQuantaSet_0: (+1)
   \       0x18   0x0006             MOVS     R6,R0
   1826          #endif
   1827          
   1828              CPU_CRITICAL_ENTER();
   \       0x1A   0x....'....        BL       CPU_SR_Save
   1829              if (p_tcb == (OS_TCB *)0) {
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD101             BNE      ??OSTaskTimeQuantaSet_2
   1830                  p_tcb = OSTCBCurPtr;
   \       0x22   0x....             LDR      R1,??DataTable20_1
   \       0x24   0x680E             LDR      R6,[R1, #+0]
   1831              }
   1832          
   1833              if (time_quanta == 0u) {
   \                     ??OSTaskTimeQuantaSet_2: (+1)
   \       0x26   0x2C00             CMP      R4,#+0
   \       0x28   0xD103             BNE      ??OSTaskTimeQuantaSet_3
   1834                  p_tcb->TimeQuanta    = OSSchedRoundRobinDfltTimeQuanta;
   \       0x2A   0x....             LDR      R1,??DataTable21
   \       0x2C   0x6809             LDR      R1,[R1, #+0]
   \       0x2E   0x6571             STR      R1,[R6, #+84]
   \       0x30   0xE000             B        ??OSTaskTimeQuantaSet_4
   1835              } else {
   1836                  p_tcb->TimeQuanta    = time_quanta;
   \                     ??OSTaskTimeQuantaSet_3: (+1)
   \       0x32   0x6574             STR      R4,[R6, #+84]
   1837              }
   1838              if (p_tcb->TimeQuanta > p_tcb->TimeQuantaCtr) {
   \                     ??OSTaskTimeQuantaSet_4: (+1)
   \       0x34   0x6DB1             LDR      R1,[R6, #+88]
   \       0x36   0x6D72             LDR      R2,[R6, #+84]
   \       0x38   0x4291             CMP      R1,R2
   \       0x3A   0xD201             BCS      ??OSTaskTimeQuantaSet_5
   1839                  p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;
   \       0x3C   0x6D71             LDR      R1,[R6, #+84]
   \       0x3E   0x65B1             STR      R1,[R6, #+88]
   1840              }
   1841              CPU_CRITICAL_EXIT();
   \                     ??OSTaskTimeQuantaSet_5: (+1)
   \       0x40   0x....'....        BL       CPU_SR_Restore
   1842             *p_err = OS_ERR_NONE;
   \       0x44   0x803D             STRH     R5,[R7, #+0]
   1843          }
   \                     ??OSTaskTimeQuantaSet_1: (+1)
   \       0x46   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1844          #endif
   1845          
   1846          /*$PAGE*/
   1847          /*
   1848          ************************************************************************************************************************
   1849          *                                            ADD/REMOVE TASK TO/FROM DEBUG LIST
   1850          *
   1851          * Description: These functions are called by uC/OS-III to add or remove an OS_TCB from the debug list.
   1852          *
   1853          * Arguments  : p_tcb     is a pointer to the OS_TCB to add/remove
   1854          *
   1855          * Returns    : none
   1856          *
   1857          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
   1858          ************************************************************************************************************************
   1859          */
   1860          
   1861          #if OS_CFG_DBG_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   1862          void  OS_TaskDbgListAdd (OS_TCB  *p_tcb)
   1863          {
   \                     OS_TaskDbgListAdd: (+1)
   \        0x0   0xB500             PUSH     {LR}
   1864              p_tcb->DbgPrevPtr                = (OS_TCB *)0;
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x21B4             MOVS     R1,#+180
   \        0x6   0x5042             STR      R2,[R0, R1]
   1865              if (OSTaskDbgListPtr == (OS_TCB *)0) {
   \        0x8   0x....             LDR      R1,??DataTable21_1
   \        0xA   0x680B             LDR      R3,[R1, #+0]
   \        0xC   0x2B00             CMP      R3,#+0
   \        0xE   0xD102             BNE      ??OS_TaskDbgListAdd_0
   1866                  p_tcb->DbgNextPtr            = (OS_TCB *)0;
   \       0x10   0x23B8             MOVS     R3,#+184
   \       0x12   0x50C2             STR      R2,[R0, R3]
   \       0x14   0xE005             B        ??OS_TaskDbgListAdd_1
   1867              } else {
   1868                  p_tcb->DbgNextPtr            =  OSTaskDbgListPtr;
   \                     ??OS_TaskDbgListAdd_0: (+1)
   \       0x16   0x680A             LDR      R2,[R1, #+0]
   \       0x18   0x23B8             MOVS     R3,#+184
   \       0x1A   0x50C2             STR      R2,[R0, R3]
   1869                  OSTaskDbgListPtr->DbgPrevPtr =  p_tcb;
   \       0x1C   0x680A             LDR      R2,[R1, #+0]
   \       0x1E   0x23B4             MOVS     R3,#+180
   \       0x20   0x50D0             STR      R0,[R2, R3]
   1870              }
   1871              OSTaskDbgListPtr                 =  p_tcb;
   \                     ??OS_TaskDbgListAdd_1: (+1)
   \       0x22   0x6008             STR      R0,[R1, #+0]
   1872          }
   \       0x24   0xBD00             POP      {PC}             ;; return
   1873          
   1874          
   1875          

   \                                 In section .text, align 2, keep-with-next
   1876          void  OS_TaskDbgListRemove (OS_TCB  *p_tcb)
   1877          {
   \                     OS_TaskDbgListRemove: (+1)
   \        0x0   0xB500             PUSH     {LR}
   1878              OS_TCB  *p_tcb_next;
   1879              OS_TCB  *p_tcb_prev;
   1880          
   1881          
   1882              p_tcb_prev = p_tcb->DbgPrevPtr;
   \        0x2   0x21B4             MOVS     R1,#+180
   \        0x4   0x5842             LDR      R2,[R0, R1]
   1883              p_tcb_next = p_tcb->DbgNextPtr;
   \        0x6   0x21B8             MOVS     R1,#+184
   \        0x8   0x5841             LDR      R1,[R0, R1]
   1884          
   1885              if (p_tcb_prev == (OS_TCB *)0) {
   \        0xA   0x2A00             CMP      R2,#+0
   \        0xC   0xD10A             BNE      ??OS_TaskDbgListRemove_0
   1886                  OSTaskDbgListPtr = p_tcb_next;
   \        0xE   0x....             LDR      R2,??DataTable21_1
   \       0x10   0x6011             STR      R1,[R2, #+0]
   1887                  if (p_tcb_next != (OS_TCB *)0) {
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD002             BEQ      ??OS_TaskDbgListRemove_1
   1888                      p_tcb_next->DbgPrevPtr = (OS_TCB *)0;
   \       0x16   0x2200             MOVS     R2,#+0
   \       0x18   0x23B4             MOVS     R3,#+180
   \       0x1A   0x50CA             STR      R2,[R1, R3]
   1889                  }
   1890                  p_tcb->DbgNextPtr = (OS_TCB *)0;
   \                     ??OS_TaskDbgListRemove_1: (+1)
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x22B8             MOVS     R2,#+184
   \       0x20   0x5081             STR      R1,[R0, R2]
   \       0x22   0xE010             B        ??OS_TaskDbgListRemove_2
   1891          
   1892              } else if (p_tcb_next == (OS_TCB *)0) {
   \                     ??OS_TaskDbgListRemove_0: (+1)
   \       0x24   0x2900             CMP      R1,#+0
   \       0x26   0xD105             BNE      ??OS_TaskDbgListRemove_3
   1893                  p_tcb_prev->DbgNextPtr = (OS_TCB *)0;
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x23B8             MOVS     R3,#+184
   \       0x2C   0x50D1             STR      R1,[R2, R3]
   1894                  p_tcb->DbgPrevPtr      = (OS_TCB *)0;
   \       0x2E   0x22B4             MOVS     R2,#+180
   \       0x30   0x5081             STR      R1,[R0, R2]
   \       0x32   0xE008             B        ??OS_TaskDbgListRemove_2
   1895          
   1896              } else {
   1897                  p_tcb_prev->DbgNextPtr =  p_tcb_next;
   \                     ??OS_TaskDbgListRemove_3: (+1)
   \       0x34   0x23B8             MOVS     R3,#+184
   \       0x36   0x50D1             STR      R1,[R2, R3]
   1898                  p_tcb_next->DbgPrevPtr =  p_tcb_prev;
   \       0x38   0x23B4             MOVS     R3,#+180
   \       0x3A   0x50CA             STR      R2,[R1, R3]
   1899                  p_tcb->DbgNextPtr      = (OS_TCB *)0;
   \       0x3C   0x2100             MOVS     R1,#+0
   \       0x3E   0x22B8             MOVS     R2,#+184
   \       0x40   0x5081             STR      R1,[R0, R2]
   1900                  p_tcb->DbgPrevPtr      = (OS_TCB *)0;
   \       0x42   0x22B4             MOVS     R2,#+180
   \       0x44   0x5081             STR      R1,[R0, R2]
   1901              }
   1902          }
   \                     ??OS_TaskDbgListRemove_2: (+1)
   \       0x46   0xBD00             POP      {PC}             ;; return
   1903          #endif
   1904          
   1905          /*$PAGE*/
   1906          /*
   1907          ************************************************************************************************************************
   1908          *                                             TASK MANAGER INITIALIZATION
   1909          *
   1910          * Description: This function is called by OSInit() to initialize the task management.
   1911          *
   1912          
   1913          * Argument(s): p_err        is a pointer to a variable that will contain an error code returned by this function.
   1914          *
   1915          *                                OS_ERR_NONE     the call was successful
   1916          *
   1917          * Returns    : none
   1918          *
   1919          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1920          ************************************************************************************************************************
   1921          */
   1922          

   \                                 In section .text, align 2, keep-with-next
   1923          void  OS_TaskInit (OS_ERR  *p_err)
   1924          {
   1925          #ifdef OS_SAFETY_CRITICAL
   1926              if (p_err == (OS_ERR *)0) {
   1927                  OS_SAFETY_CRITICAL_EXCEPTION();
   1928                  return;
   1929              }
   1930          #endif
   1931          
   1932          #if OS_CFG_DBG_EN > 0u
   1933              OSTaskDbgListPtr = (OS_TCB      *)0;
   \                     OS_TaskInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x....             LDR      R2,??DataTable21_1
   \        0x4   0x6011             STR      R1,[R2, #+0]
   1934          #endif
   1935          
   1936              OSTaskQty        = (OS_OBJ_QTY   )0;                    /* Clear the number of tasks                              */
   \        0x6   0x000A             MOVS     R2,R1
   \        0x8   0x....             LDR      R3,??DataTable21_2
   \        0xA   0x801A             STRH     R2,[R3, #+0]
   1937              OSTaskCtxSwCtr   = (OS_CTX_SW_CTR)0;                    /* Clear the context switch counter                       */
   \        0xC   0x....             LDR      R2,??DataTable22
   \        0xE   0x6011             STR      R1,[R2, #+0]
   1938          
   1939             *p_err            = OS_ERR_NONE;
   \       0x10   0x8001             STRH     R1,[R0, #+0]
   1940          }
   \       0x12   0x4770             BX       LR               ;; return
   1941          
   1942          /*$PAGE*/
   1943          /*
   1944          ************************************************************************************************************************
   1945          *                                               INITIALIZE TCB FIELDS
   1946          *
   1947          * Description: This function is called to initialize a TCB to default values
   1948          *
   1949          * Arguments  : p_tcb    is a pointer to the TCB to initialize
   1950          *
   1951          * Returns    : none
   1952          *
   1953          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1954          ************************************************************************************************************************
   1955          */
   1956          

   \                                 In section .text, align 2, keep-with-next
   1957          void  OS_TaskInitTCB (OS_TCB  *p_tcb)
   1958          {
   \                     OS_TaskInitTCB: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1959          #if OS_CFG_TASK_REG_TBL_SIZE > 0u
   1960              OS_REG_ID   reg_id;
   1961          #endif
   1962          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
   1963              OS_TLS_ID   id;
   1964          #endif
   1965          #if OS_CFG_TASK_PROFILE_EN > 0u
   1966              CPU_TS      ts;
   1967          #endif
   1968          
   1969          
   1970              p_tcb->StkPtr             = (CPU_STK       *)0;
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0x6025             STR      R5,[R4, #+0]
   1971              p_tcb->StkLimitPtr        = (CPU_STK       *)0;
   \        0x8   0x60A5             STR      R5,[R4, #+8]
   1972          
   1973              p_tcb->ExtPtr             = (void          *)0;
   \        0xA   0x6065             STR      R5,[R4, #+4]
   1974          
   1975              p_tcb->NextPtr            = (OS_TCB        *)0;
   \        0xC   0x60E5             STR      R5,[R4, #+12]
   1976              p_tcb->PrevPtr            = (OS_TCB        *)0;
   \        0xE   0x6125             STR      R5,[R4, #+16]
   1977          
   1978              p_tcb->TickNextPtr        = (OS_TCB        *)0;
   \       0x10   0x6165             STR      R5,[R4, #+20]
   1979              p_tcb->TickPrevPtr        = (OS_TCB        *)0;
   \       0x12   0x61A5             STR      R5,[R4, #+24]
   1980              p_tcb->TickSpokePtr       = (OS_TICK_SPOKE *)0;
   \       0x14   0x61E5             STR      R5,[R4, #+28]
   1981          
   1982              p_tcb->NamePtr            = (CPU_CHAR      *)((void *)"?Task");
   \       0x16   0x....             LDR      R0,??DataTable23
   \       0x18   0x6220             STR      R0,[R4, #+32]
   1983          
   1984              p_tcb->StkBasePtr         = (CPU_STK       *)0;
   \       0x1A   0x6265             STR      R5,[R4, #+36]
   1985          
   1986              p_tcb->TaskEntryAddr      = (OS_TASK_PTR    )0;
   \       0x1C   0x62A5             STR      R5,[R4, #+40]
   1987              p_tcb->TaskEntryArg       = (void          *)0;
   \       0x1E   0x62E5             STR      R5,[R4, #+44]
   1988          
   1989          #if (OS_CFG_PEND_MULTI_EN > 0u)
   1990              p_tcb->PendDataTblPtr     = (OS_PEND_DATA  *)0;
   \       0x20   0x6325             STR      R5,[R4, #+48]
   1991              p_tcb->PendDataTblEntries = (OS_OBJ_QTY     )0u;
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0x87E0             STRH     R0,[R4, #+62]
   1992          #endif
   1993          
   1994              p_tcb->TS                 = (CPU_TS         )0u;
   \       0x26   0x6425             STR      R5,[R4, #+64]
   1995          
   1996          #if (OS_MSG_EN > 0u)
   1997              p_tcb->MsgPtr             = (void          *)0;
   \       0x28   0x65E5             STR      R5,[R4, #+92]
   1998              p_tcb->MsgSize            = (OS_MSG_SIZE    )0u;
   \       0x2A   0x0028             MOVS     R0,R5
   \       0x2C   0x2160             MOVS     R1,#+96
   \       0x2E   0x5260             STRH     R0,[R4, R1]
   1999          #endif
   2000          
   2001          #if OS_CFG_TASK_Q_EN > 0u
   2002              OS_MsgQInit(&p_tcb->MsgQ,
   2003                          (OS_MSG_QTY)0u);
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x3064             ADDS     R0,R0,#+100
   \       0x36   0x....'....        BL       OS_MsgQInit
   2004          #if OS_CFG_TASK_PROFILE_EN > 0u
   2005              p_tcb->MsgQPendTime       = (CPU_TS         )0u;
   \       0x3A   0x6765             STR      R5,[R4, #+116]
   2006              p_tcb->MsgQPendTimeMax    = (CPU_TS         )0u;
   \       0x3C   0x67A5             STR      R5,[R4, #+120]
   2007          #endif
   2008          #endif
   2009          
   2010          #if OS_CFG_FLAG_EN > 0u
   2011              p_tcb->FlagsPend          = (OS_FLAGS       )0u;
   \       0x3E   0x2080             MOVS     R0,#+128
   \       0x40   0x5025             STR      R5,[R4, R0]
   2012              p_tcb->FlagsOpt           = (OS_OPT         )0u;
   \       0x42   0x0028             MOVS     R0,R5
   \       0x44   0x2188             MOVS     R1,#+136
   \       0x46   0x5260             STRH     R0,[R4, R1]
   2013              p_tcb->FlagsRdy           = (OS_FLAGS       )0u;
   \       0x48   0x2084             MOVS     R0,#+132
   \       0x4A   0x5025             STR      R5,[R4, R0]
   2014          #endif
   2015          
   2016          #if OS_CFG_TASK_REG_TBL_SIZE > 0u
   2017              for (reg_id = 0u; reg_id < OS_CFG_TASK_REG_TBL_SIZE; reg_id++) {
   \       0x4C   0x0028             MOVS     R0,R5
   \       0x4E   0xE006             B        ??OS_TaskInitTCB_0
   2018                  p_tcb->RegTbl[reg_id] = (OS_REG)0u;
   \                     ??OS_TaskInitTCB_1: (+1)
   \       0x50   0x0001             MOVS     R1,R0
   \       0x52   0xB2C9             UXTB     R1,R1
   \       0x54   0x2204             MOVS     R2,#+4
   \       0x56   0x4351             MULS     R1,R2,R1
   \       0x58   0x1861             ADDS     R1,R4,R1
   \       0x5A   0x67CD             STR      R5,[R1, #+124]
   2019              }
   \       0x5C   0x1C40             ADDS     R0,R0,#+1
   \                     ??OS_TaskInitTCB_0: (+1)
   \       0x5E   0x0001             MOVS     R1,R0
   \       0x60   0xB2C9             UXTB     R1,R1
   \       0x62   0x2900             CMP      R1,#+0
   \       0x64   0xD0F4             BEQ      ??OS_TaskInitTCB_1
   2020          #endif
   2021          
   2022          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
   2023              for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
   2024                  p_tcb->TLS_Tbl[id]    = (OS_TLS)0;
   2025              }
   2026          #endif
   2027          
   2028              p_tcb->SemCtr             = (OS_SEM_CTR     )0u;
   \       0x66   0x6465             STR      R5,[R4, #+68]
   2029          #if OS_CFG_TASK_PROFILE_EN > 0u
   2030              p_tcb->SemPendTime        = (CPU_TS         )0u;
   \       0x68   0x20A4             MOVS     R0,#+164
   \       0x6A   0x5025             STR      R5,[R4, R0]
   2031              p_tcb->SemPendTimeMax     = (CPU_TS         )0u;
   \       0x6C   0x20A8             MOVS     R0,#+168
   \       0x6E   0x5025             STR      R5,[R4, R0]
   2032          #endif
   2033          
   2034              p_tcb->StkSize            = (CPU_STK_SIZE   )0u;
   \       0x70   0x63A5             STR      R5,[R4, #+56]
   2035          
   2036          
   2037          #if OS_CFG_TASK_SUSPEND_EN > 0u
   2038              p_tcb->SuspendCtr         = (OS_NESTING_CTR )0u;
   \       0x72   0x0028             MOVS     R0,R5
   \       0x74   0x218A             MOVS     R1,#+138
   \       0x76   0x5460             STRB     R0,[R4, R1]
   2039          #endif
   2040          
   2041          #if OS_CFG_STAT_TASK_STK_CHK_EN > 0u
   2042              p_tcb->StkFree            = (CPU_STK_SIZE   )0u;
   \       0x78   0x20B0             MOVS     R0,#+176
   \       0x7A   0x5025             STR      R5,[R4, R0]
   2043              p_tcb->StkUsed            = (CPU_STK_SIZE   )0u;
   \       0x7C   0x20AC             MOVS     R0,#+172
   \       0x7E   0x5025             STR      R5,[R4, R0]
   2044          #endif
   2045          
   2046              p_tcb->Opt                = (OS_OPT         )0u;
   \       0x80   0x0028             MOVS     R0,R5
   \       0x82   0x87A0             STRH     R0,[R4, #+60]
   2047          
   2048              p_tcb->TickCtrPrev        = (OS_TICK        )OS_TICK_TH_INIT;
   \       0x84   0x2080             MOVS     R0,#+128
   \       0x86   0x0600             LSLS     R0,R0,#+24       ;; #-2147483648
   \       0x88   0x64A0             STR      R0,[R4, #+72]
   2049              p_tcb->TickCtrMatch       = (OS_TICK        )0u;
   \       0x8A   0x64E5             STR      R5,[R4, #+76]
   2050              p_tcb->TickRemain         = (OS_TICK        )0u;
   \       0x8C   0x6525             STR      R5,[R4, #+80]
   2051          
   2052              p_tcb->TimeQuanta         = (OS_TICK        )0u;
   \       0x8E   0x6565             STR      R5,[R4, #+84]
   2053              p_tcb->TimeQuantaCtr      = (OS_TICK        )0u;
   \       0x90   0x65A5             STR      R5,[R4, #+88]
   2054          
   2055          #if OS_CFG_TASK_PROFILE_EN > 0u
   2056              p_tcb->CPUUsage           = (OS_CPU_USAGE   )0u;
   \       0x92   0x0028             MOVS     R0,R5
   \       0x94   0x218C             MOVS     R1,#+140
   \       0x96   0x5260             STRH     R0,[R4, R1]
   2057              p_tcb->CPUUsageMax        = (OS_CPU_USAGE   )0u;
   \       0x98   0x0028             MOVS     R0,R5
   \       0x9A   0x218E             MOVS     R1,#+142
   \       0x9C   0x5260             STRH     R0,[R4, R1]
   2058              p_tcb->CtxSwCtr           = (OS_CTX_SW_CTR  )0u;
   \       0x9E   0x2090             MOVS     R0,#+144
   \       0xA0   0x5025             STR      R5,[R4, R0]
   2059              p_tcb->CyclesDelta        = (CPU_TS         )0u;
   \       0xA2   0x2094             MOVS     R0,#+148
   \       0xA4   0x5025             STR      R5,[R4, R0]
   2060              ts                        = OS_TS_GET();                /* Read the current timestamp and save                    */
   \       0xA6   0x0028             MOVS     R0,R5
   2061              p_tcb->CyclesStart        = ts;
   \       0xA8   0x2198             MOVS     R1,#+152
   \       0xAA   0x5060             STR      R0,[R4, R1]
   2062              p_tcb->CyclesTotal        = (OS_CYCLES      )0u;
   \       0xAC   0x209C             MOVS     R0,#+156
   \       0xAE   0x5025             STR      R5,[R4, R0]
   2063          #endif
   2064          #ifdef CPU_CFG_INT_DIS_MEAS_EN
   2065              p_tcb->IntDisTimeMax      = (CPU_TS         )0u;
   2066          #endif
   2067          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
   2068              p_tcb->SchedLockTimeMax   = (CPU_TS         )0u;
   2069          #endif
   2070          
   2071              p_tcb->PendOn             = (OS_STATE       )OS_TASK_PEND_ON_NOTHING;
   \       0xB0   0x0028             MOVS     R0,R5
   \       0xB2   0x2134             MOVS     R1,#+52
   \       0xB4   0x5460             STRB     R0,[R4, R1]
   2072              p_tcb->PendStatus         = (OS_STATUS      )OS_STATUS_PEND_OK;
   \       0xB6   0x0028             MOVS     R0,R5
   \       0xB8   0x2135             MOVS     R1,#+53
   \       0xBA   0x5460             STRB     R0,[R4, R1]
   2073              p_tcb->TaskState          = (OS_STATE       )OS_TASK_STATE_RDY;
   \       0xBC   0x0028             MOVS     R0,R5
   \       0xBE   0x2136             MOVS     R1,#+54
   \       0xC0   0x5460             STRB     R0,[R4, R1]
   2074          
   2075              p_tcb->Prio               = (OS_PRIO        )OS_PRIO_INIT;
   \       0xC2   0x2010             MOVS     R0,#+16
   \       0xC4   0x2137             MOVS     R1,#+55
   \       0xC6   0x5460             STRB     R0,[R4, R1]
   2076          
   2077          #if OS_CFG_DBG_EN > 0u
   2078              p_tcb->DbgPrevPtr         = (OS_TCB        *)0;
   \       0xC8   0x20B4             MOVS     R0,#+180
   \       0xCA   0x5025             STR      R5,[R4, R0]
   2079              p_tcb->DbgNextPtr         = (OS_TCB        *)0;
   \       0xCC   0x20B8             MOVS     R0,#+184
   \       0xCE   0x5025             STR      R5,[R4, R0]
   2080              p_tcb->DbgNamePtr         = (CPU_CHAR      *)((void *)" ");
   \       0xD0   0x....             ADR      R0,??DataTable23_1  ;; " "
   \       0xD2   0x21BC             MOVS     R1,#+188
   \       0xD4   0x5060             STR      R0,[R4, R1]
   2081          #endif
   2082          }
   \       0xD6   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2083          
   2084          /*$PAGE*/
   2085          /*
   2086          ************************************************************************************************************************
   2087          *                                               POST MESSAGE TO A TASK
   2088          *
   2089          * Description: This function sends a message to a task
   2090          *
   2091          * Arguments  : p_tcb      is a pointer to the TCB of the task receiving a message.  If you specify a NULL pointer then
   2092          *                         the message will be posted to the task's queue of the calling task.  In other words, you'd be
   2093          *                         posting a message to yourself.
   2094          *
   2095          *              p_void     is a pointer to the message to send.
   2096          *
   2097          *              msg_size   is the size of the message sent (in #bytes)
   2098          *
   2099          *              opt        specifies whether the post will be FIFO or LIFO:
   2100          *
   2101          *                             OS_OPT_POST_FIFO       Post at the end   of the queue
   2102          *                             OS_OPT_POST_LIFO       Post at the front of the queue
   2103          *
   2104          *                             OS_OPT_POST_NO_SCHED   Do not run the scheduler after the post
   2105          *
   2106          *                          Note(s): 1) OS_OPT_POST_NO_SCHED can be added with one of the other options.
   2107          *
   2108          *
   2109          *              ts         is a timestamp indicating when the post occurred.
   2110          *
   2111          *              p_err      is a pointer to a variable that will hold the error code associated
   2112          *                         with the outcome of this call.  Errors can be:
   2113          *
   2114          *                             OS_ERR_NONE            The call was successful and the message was sent
   2115          *                             OS_ERR_MSG_POOL_EMPTY  If there are no more OS_MSGs available from the pool
   2116          *                             OS_ERR_Q_MAX           If the queue is full
   2117          *                             OS_ERR_STATE_INVALID   If the task is in an invalid state.  This should never happen
   2118          *                                                    and if it does, would be considered a system failure.
   2119          *
   2120          * Returns    : none
   2121          *
   2122          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2123          ************************************************************************************************************************
   2124          */
   2125          
   2126          #if OS_CFG_TASK_Q_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   2127          void  OS_TaskQPost (OS_TCB       *p_tcb,
   2128                              void         *p_void,
   2129                              OS_MSG_SIZE   msg_size,
   2130                              OS_OPT        opt,
   2131                              CPU_TS        ts,
   2132                              OS_ERR       *p_err)
   2133          {
   \                     OS_TaskQPost: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
   \        0x4   0x0004             MOVS     R4,R0
   2134              CPU_SR_ALLOC();
   \        0x6   0x2600             MOVS     R6,#+0
   \        0x8   0x0030             MOVS     R0,R6
   2135          
   2136          
   2137          
   2138              OS_CRITICAL_ENTER();
   \        0xA   0x....'....        BL       CPU_SR_Save
   \        0xE   0x....             LDR      R5,??DataTable23_2
   \       0x10   0x7829             LDRB     R1,[R5, #+0]
   \       0x12   0x1C49             ADDS     R1,R1,#+1
   \       0x14   0x7029             STRB     R1,[R5, #+0]
   \       0x16   0x....'....        BL       CPU_SR_Restore
   2139              if (p_tcb == (OS_TCB *)0) {                             /* Post msg to 'self'?                                    */
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD101             BNE      ??OS_TaskQPost_0
   2140                  p_tcb = OSTCBCurPtr;
   \       0x1E   0x....             LDR      R0,??DataTable23_3
   \       0x20   0x6804             LDR      R4,[R0, #+0]
   \                     ??OS_TaskQPost_0: (+1)
   \       0x22   0x9F0B             LDR      R7,[SP, #+44]
   2141              }
   2142             *p_err  = OS_ERR_NONE;                                   /* Assume we won't have any errors                        */
   \       0x24   0x803E             STRH     R6,[R7, #+0]
   \       0x26   0x4668             MOV      R0,SP
   \       0x28   0x8982             LDRH     R2,[R0, #+12]
   \       0x2A   0x4668             MOV      R0,SP
   \       0x2C   0x8A06             LDRH     R6,[R0, #+16]
   \       0x2E   0x980A             LDR      R0,[SP, #+40]
   2143              switch (p_tcb->TaskState) {
   \       0x30   0x2136             MOVS     R1,#+54
   \       0x32   0x5C61             LDRB     R1,[R4, R1]
   \       0x34   0x2900             CMP      R1,#+0
   \       0x36   0x2901             CMP      R1,#+1
   \       0x38   0xD909             BLS      ??OS_TaskQPost_1
   \       0x3A   0x1E89             SUBS     R1,R1,#+2
   \       0x3C   0x2901             CMP      R1,#+1
   \       0x3E   0xD927             BLS      ??OS_TaskQPost_2
   \       0x40   0x1E89             SUBS     R1,R1,#+2
   \       0x42   0x2901             CMP      R1,#+1
   \       0x44   0xD903             BLS      ??OS_TaskQPost_1
   \       0x46   0x1E89             SUBS     R1,R1,#+2
   \       0x48   0x2901             CMP      R1,#+1
   \       0x4A   0xD921             BLS      ??OS_TaskQPost_2
   \       0x4C   0xE059             B        ??OS_TaskQPost_3
   2144                  case OS_TASK_STATE_RDY:
   2145                  case OS_TASK_STATE_DLY:
   2146                  case OS_TASK_STATE_SUSPENDED:
   2147                  case OS_TASK_STATE_DLY_SUSPENDED:
   2148                       OS_MsgQPut(&p_tcb->MsgQ,                       /* Deposit the message in the queue                       */
   2149                                  p_void,
   2150                                  msg_size,
   2151                                  opt,
   2152                                  ts,
   2153                                  p_err);
   \                     ??OS_TaskQPost_1: (+1)
   \       0x4E   0x9701             STR      R7,[SP, #+4]
   \       0x50   0x9000             STR      R0,[SP, #+0]
   \       0x52   0x0033             MOVS     R3,R6
   \       0x54   0xB29B             UXTH     R3,R3
   \       0x56   0xB292             UXTH     R2,R2
   \       0x58   0x9902             LDR      R1,[SP, #+8]
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0x3064             ADDS     R0,R0,#+100
   \       0x5E   0x....'....        BL       OS_MsgQPut
   2154                       OS_CRITICAL_EXIT();
   \       0x62   0x....'....        BL       CPU_SR_Save
   \       0x66   0x7829             LDRB     R1,[R5, #+0]
   \       0x68   0x1E49             SUBS     R1,R1,#+1
   \       0x6A   0x7029             STRB     R1,[R5, #+0]
   \       0x6C   0x7829             LDRB     R1,[R5, #+0]
   \       0x6E   0x2900             CMP      R1,#+0
   \       0x70   0xD10B             BNE      ??OS_TaskQPost_4
   \       0x72   0x....             LDR      R1,??DataTable23_4
   \       0x74   0x8809             LDRH     R1,[R1, #+0]
   \       0x76   0x2900             CMP      R1,#+0
   \       0x78   0xD004             BEQ      ??OS_TaskQPost_5
   \       0x7A   0x....'....        BL       CPU_SR_Restore
   \       0x7E   0x....'....        BL       OS_Sched0
   \       0x82   0xE004             B        ??OS_TaskQPost_6
   \                     ??OS_TaskQPost_5: (+1)
   \       0x84   0x....'....        BL       CPU_SR_Restore
   \       0x88   0xE001             B        ??OS_TaskQPost_6
   \                     ??OS_TaskQPost_4: (+1)
   \       0x8A   0x....'....        BL       CPU_SR_Restore
   2155                       break;
   \                     ??OS_TaskQPost_6: (+1)
   \       0x8E   0xE050             B        ??OS_TaskQPost_7
   2156          
   2157                  case OS_TASK_STATE_PEND:
   2158                  case OS_TASK_STATE_PEND_TIMEOUT:
   2159                  case OS_TASK_STATE_PEND_SUSPENDED:
   2160                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   2161                       if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_Q) { /* Is task waiting for a message to be sent to it?        */
   \                     ??OS_TaskQPost_2: (+1)
   \       0x90   0x2134             MOVS     R1,#+52
   \       0x92   0x5C61             LDRB     R1,[R4, R1]
   \       0x94   0x2902             CMP      R1,#+2
   \       0x96   0xD113             BNE      ??OS_TaskQPost_8
   2162                           OS_Post((OS_PEND_OBJ *)0,
   2163                                   p_tcb,
   2164                                   p_void,
   2165                                   msg_size,
   2166                                   ts);
   \       0x98   0x9000             STR      R0,[SP, #+0]
   \       0x9A   0x0013             MOVS     R3,R2
   \       0x9C   0xB29B             UXTH     R3,R3
   \       0x9E   0x9A02             LDR      R2,[SP, #+8]
   \       0xA0   0x0021             MOVS     R1,R4
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0x....'....        BL       OS_Post
   2167                           OS_CRITICAL_EXIT_NO_SCHED();
   \       0xA8   0x....'....        BL       CPU_SR_Save
   \       0xAC   0x7829             LDRB     R1,[R5, #+0]
   \       0xAE   0x1E49             SUBS     R1,R1,#+1
   \       0xB0   0x7029             STRB     R1,[R5, #+0]
   \       0xB2   0x....'....        BL       CPU_SR_Restore
   2168                           if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
   \       0xB6   0x0430             LSLS     R0,R6,#+16
   \       0xB8   0xD422             BMI      ??OS_TaskQPost_9
   2169                               OSSched();                             /* Run the scheduler                                      */
   \       0xBA   0x....'....        BL       OSSched
   \       0xBE   0xE01F             B        ??OS_TaskQPost_9
   2170                           }
   2171                       } else {
   2172                           OS_MsgQPut(&p_tcb->MsgQ,                   /* No,  Task is pending on something else ...             */
   2173                                      p_void,                         /*      ... Deposit the message in the task's queue       */
   2174                                      msg_size,
   2175                                      opt,
   2176                                      ts,
   2177                                      p_err);
   \                     ??OS_TaskQPost_8: (+1)
   \       0xC0   0x9701             STR      R7,[SP, #+4]
   \       0xC2   0x9000             STR      R0,[SP, #+0]
   \       0xC4   0x0033             MOVS     R3,R6
   \       0xC6   0xB29B             UXTH     R3,R3
   \       0xC8   0xB292             UXTH     R2,R2
   \       0xCA   0x9902             LDR      R1,[SP, #+8]
   \       0xCC   0x0020             MOVS     R0,R4
   \       0xCE   0x3064             ADDS     R0,R0,#+100
   \       0xD0   0x....'....        BL       OS_MsgQPut
   2178                           OS_CRITICAL_EXIT();
   \       0xD4   0x....'....        BL       CPU_SR_Save
   \       0xD8   0x7829             LDRB     R1,[R5, #+0]
   \       0xDA   0x1E49             SUBS     R1,R1,#+1
   \       0xDC   0x7029             STRB     R1,[R5, #+0]
   \       0xDE   0x7829             LDRB     R1,[R5, #+0]
   \       0xE0   0x2900             CMP      R1,#+0
   \       0xE2   0xD10B             BNE      ??OS_TaskQPost_10
   \       0xE4   0x....             LDR      R1,??DataTable23_4
   \       0xE6   0x8809             LDRH     R1,[R1, #+0]
   \       0xE8   0x2900             CMP      R1,#+0
   \       0xEA   0xD004             BEQ      ??OS_TaskQPost_11
   \       0xEC   0x....'....        BL       CPU_SR_Restore
   \       0xF0   0x....'....        BL       OS_Sched0
   \       0xF4   0xE004             B        ??OS_TaskQPost_12
   \                     ??OS_TaskQPost_11: (+1)
   \       0xF6   0x....'....        BL       CPU_SR_Restore
   \       0xFA   0xE001             B        ??OS_TaskQPost_12
   \                     ??OS_TaskQPost_10: (+1)
   \       0xFC   0x....'....        BL       CPU_SR_Restore
   2179                       }
   2180                       break;
   \                     ??OS_TaskQPost_12: (+1)
   \                     ??OS_TaskQPost_9: (+1)
   \      0x100   0xE017             B        ??OS_TaskQPost_7
   2181          
   2182                  default:
   2183                       OS_CRITICAL_EXIT();
   \                     ??OS_TaskQPost_3: (+1)
   \      0x102   0x....'....        BL       CPU_SR_Save
   \      0x106   0x7829             LDRB     R1,[R5, #+0]
   \      0x108   0x1E49             SUBS     R1,R1,#+1
   \      0x10A   0x7029             STRB     R1,[R5, #+0]
   \      0x10C   0x7829             LDRB     R1,[R5, #+0]
   \      0x10E   0x2900             CMP      R1,#+0
   \      0x110   0xD10B             BNE      ??OS_TaskQPost_13
   \      0x112   0x....             LDR      R1,??DataTable23_4
   \      0x114   0x8809             LDRH     R1,[R1, #+0]
   \      0x116   0x2900             CMP      R1,#+0
   \      0x118   0xD004             BEQ      ??OS_TaskQPost_14
   \      0x11A   0x....'....        BL       CPU_SR_Restore
   \      0x11E   0x....'....        BL       OS_Sched0
   \      0x122   0xE004             B        ??OS_TaskQPost_15
   \                     ??OS_TaskQPost_14: (+1)
   \      0x124   0x....'....        BL       CPU_SR_Restore
   \      0x128   0xE001             B        ??OS_TaskQPost_15
   \                     ??OS_TaskQPost_13: (+1)
   \      0x12A   0x....'....        BL       CPU_SR_Restore
   2184                      *p_err = OS_ERR_STATE_INVALID;
   \                     ??OS_TaskQPost_15: (+1)
   \      0x12E   0x....             LDR      R0,??DataTable24  ;; 0x6e2d
   \      0x130   0x8038             STRH     R0,[R7, #+0]
   2185                       break;
   2186              }
   2187          }
   \                     ??OS_TaskQPost_7: (+1)
   \      0x132   0xB005             ADD      SP,SP,#+20
   \      0x134   0xBDF0             POP      {R4-R7,PC}       ;; return
   2188          #endif
   2189          
   2190          /*$PAGE*/
   2191          /*
   2192          ************************************************************************************************************************
   2193          *                                               RESUME A SUSPENDED TASK
   2194          *
   2195          * Description: This function is called to resume a previously suspended task.  This is the only call that will remove an
   2196          *              explicit task suspension.
   2197          *
   2198          * Arguments  : p_tcb      Is a pointer to the task's OS_TCB to resume
   2199          *
   2200          *              p_err      Is a pointer to a variable that will contain an error code returned by this function
   2201          *
   2202          *                             OS_ERR_NONE                  if the requested task is resumed
   2203          *                             OS_ERR_STATE_INVALID         if the task is in an invalid state
   2204          *                             OS_ERR_TASK_RESUME_ISR       if you called this function from an ISR
   2205          *                             OS_ERR_TASK_RESUME_SELF      You cannot resume 'self'
   2206          *                             OS_ERR_TASK_NOT_SUSPENDED    if the task to resume has not been suspended
   2207          *
   2208          * Returns    : none
   2209          *
   2210          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2211          ************************************************************************************************************************
   2212          */
   2213          
   2214          #if OS_CFG_TASK_SUSPEND_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   2215          void  OS_TaskResume (OS_TCB  *p_tcb,
   2216                               OS_ERR  *p_err)
   2217          {
   \                     OS_TaskResume: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   2218              CPU_SR_ALLOC();
   \        0x6   0x2600             MOVS     R6,#+0
   \        0x8   0x0030             MOVS     R0,R6
   2219          
   2220          
   2221              CPU_CRITICAL_ENTER();
   \        0xA   0x....'....        BL       CPU_SR_Save
   2222             *p_err  = OS_ERR_NONE;
   \        0xE   0x0031             MOVS     R1,R6
   \       0x10   0x8021             STRH     R1,[R4, #+0]
   2223              switch (p_tcb->TaskState) {
   \       0x12   0x2136             MOVS     R1,#+54
   \       0x14   0x5C69             LDRB     R1,[R5, R1]
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0x2903             CMP      R1,#+3
   \       0x1A   0xD908             BLS      ??OS_TaskResume_0
   \       0x1C   0x1F09             SUBS     R1,R1,#+4
   \       0x1E   0xD00D             BEQ      ??OS_TaskResume_1
   \       0x20   0x1E49             SUBS     R1,R1,#+1
   \       0x22   0xD027             BEQ      ??OS_TaskResume_2
   \       0x24   0x1E49             SUBS     R1,R1,#+1
   \       0x26   0xD034             BEQ      ??OS_TaskResume_3
   \       0x28   0x1E49             SUBS     R1,R1,#+1
   \       0x2A   0xD041             BEQ      ??OS_TaskResume_4
   \       0x2C   0xE04F             B        ??OS_TaskResume_5
   2224                  case OS_TASK_STATE_RDY:
   2225                  case OS_TASK_STATE_DLY:
   2226                  case OS_TASK_STATE_PEND:
   2227                  case OS_TASK_STATE_PEND_TIMEOUT:
   2228                       CPU_CRITICAL_EXIT();
   \                     ??OS_TaskResume_0: (+1)
   \       0x2E   0x....'....        BL       CPU_SR_Restore
   2229                      *p_err = OS_ERR_TASK_NOT_SUSPENDED;
   \       0x32   0x....             LDR      R0,??DataTable24_1  ;; 0x7153
   \       0x34   0x8020             STRH     R0,[R4, #+0]
   2230                       break;
   2231          
   2232                  case OS_TASK_STATE_SUSPENDED:
   2233                       OS_CRITICAL_ENTER_CPU_EXIT();
   2234                       p_tcb->SuspendCtr--;
   2235                       if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
   2236                           p_tcb->TaskState = OS_TASK_STATE_RDY;
   2237                           OS_TaskRdy(p_tcb);
   2238                       }
   2239                       OS_CRITICAL_EXIT_NO_SCHED();
   2240                       break;
   2241          
   2242                  case OS_TASK_STATE_DLY_SUSPENDED:
   2243                       p_tcb->SuspendCtr--;
   2244                       if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
   2245                           p_tcb->TaskState = OS_TASK_STATE_DLY;
   2246                       }
   2247                       CPU_CRITICAL_EXIT();
   2248                       break;
   2249          
   2250                  case OS_TASK_STATE_PEND_SUSPENDED:
   2251                       p_tcb->SuspendCtr--;
   2252                       if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
   2253                           p_tcb->TaskState = OS_TASK_STATE_PEND;
   2254                       }
   2255                       CPU_CRITICAL_EXIT();
   2256                       break;
   2257          
   2258                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   2259                       p_tcb->SuspendCtr--;
   2260                       if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
   2261                           p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
   2262                       }
   2263                       CPU_CRITICAL_EXIT();
   2264                       break;
   2265          
   2266                  default:
   2267                       CPU_CRITICAL_EXIT();
   2268                      *p_err = OS_ERR_STATE_INVALID;
   2269                       return;
   2270              }
   2271          
   2272              OSSched();
   \                     ??OS_TaskResume_6: (+1)
   \       0x36   0x....'....        BL       OSSched
   2273          }
   \                     ??OS_TaskResume_7: (+1)
   \       0x3A   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??OS_TaskResume_1: (+1)
   \       0x3C   0x....             LDR      R4,??DataTable23_2
   \       0x3E   0x7821             LDRB     R1,[R4, #+0]
   \       0x40   0x1C49             ADDS     R1,R1,#+1
   \       0x42   0x7021             STRB     R1,[R4, #+0]
   \       0x44   0x....'....        BL       CPU_SR_Restore
   \       0x48   0x208A             MOVS     R0,#+138
   \       0x4A   0x5C28             LDRB     R0,[R5, R0]
   \       0x4C   0x1E40             SUBS     R0,R0,#+1
   \       0x4E   0x218A             MOVS     R1,#+138
   \       0x50   0x5468             STRB     R0,[R5, R1]
   \       0x52   0x208A             MOVS     R0,#+138
   \       0x54   0x5C28             LDRB     R0,[R5, R0]
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD104             BNE      ??OS_TaskResume_8
   \       0x5A   0x2036             MOVS     R0,#+54
   \       0x5C   0x542E             STRB     R6,[R5, R0]
   \       0x5E   0x0028             MOVS     R0,R5
   \       0x60   0x....'....        BL       OS_TaskRdy
   \                     ??OS_TaskResume_8: (+1)
   \       0x64   0x....'....        BL       CPU_SR_Save
   \       0x68   0x7821             LDRB     R1,[R4, #+0]
   \       0x6A   0x1E49             SUBS     R1,R1,#+1
   \       0x6C   0x7021             STRB     R1,[R4, #+0]
   \       0x6E   0x....'....        BL       CPU_SR_Restore
   \       0x72   0xE7E0             B        ??OS_TaskResume_6
   \                     ??OS_TaskResume_2: (+1)
   \       0x74   0x218A             MOVS     R1,#+138
   \       0x76   0x5C69             LDRB     R1,[R5, R1]
   \       0x78   0x1E49             SUBS     R1,R1,#+1
   \       0x7A   0x228A             MOVS     R2,#+138
   \       0x7C   0x54A9             STRB     R1,[R5, R2]
   \       0x7E   0x218A             MOVS     R1,#+138
   \       0x80   0x5C69             LDRB     R1,[R5, R1]
   \       0x82   0x2900             CMP      R1,#+0
   \       0x84   0xD102             BNE      ??OS_TaskResume_9
   \       0x86   0x2101             MOVS     R1,#+1
   \       0x88   0x2236             MOVS     R2,#+54
   \       0x8A   0x54A9             STRB     R1,[R5, R2]
   \                     ??OS_TaskResume_9: (+1)
   \       0x8C   0x....'....        BL       CPU_SR_Restore
   \       0x90   0xE7D1             B        ??OS_TaskResume_6
   \                     ??OS_TaskResume_3: (+1)
   \       0x92   0x218A             MOVS     R1,#+138
   \       0x94   0x5C69             LDRB     R1,[R5, R1]
   \       0x96   0x1E49             SUBS     R1,R1,#+1
   \       0x98   0x228A             MOVS     R2,#+138
   \       0x9A   0x54A9             STRB     R1,[R5, R2]
   \       0x9C   0x218A             MOVS     R1,#+138
   \       0x9E   0x5C69             LDRB     R1,[R5, R1]
   \       0xA0   0x2900             CMP      R1,#+0
   \       0xA2   0xD102             BNE      ??OS_TaskResume_10
   \       0xA4   0x2102             MOVS     R1,#+2
   \       0xA6   0x2236             MOVS     R2,#+54
   \       0xA8   0x54A9             STRB     R1,[R5, R2]
   \                     ??OS_TaskResume_10: (+1)
   \       0xAA   0x....'....        BL       CPU_SR_Restore
   \       0xAE   0xE7C2             B        ??OS_TaskResume_6
   \                     ??OS_TaskResume_4: (+1)
   \       0xB0   0x218A             MOVS     R1,#+138
   \       0xB2   0x5C69             LDRB     R1,[R5, R1]
   \       0xB4   0x1E49             SUBS     R1,R1,#+1
   \       0xB6   0x228A             MOVS     R2,#+138
   \       0xB8   0x54A9             STRB     R1,[R5, R2]
   \       0xBA   0x218A             MOVS     R1,#+138
   \       0xBC   0x5C69             LDRB     R1,[R5, R1]
   \       0xBE   0x2900             CMP      R1,#+0
   \       0xC0   0xD102             BNE      ??OS_TaskResume_11
   \       0xC2   0x2103             MOVS     R1,#+3
   \       0xC4   0x2236             MOVS     R2,#+54
   \       0xC6   0x54A9             STRB     R1,[R5, R2]
   \                     ??OS_TaskResume_11: (+1)
   \       0xC8   0x....'....        BL       CPU_SR_Restore
   \       0xCC   0xE7B3             B        ??OS_TaskResume_6
   \                     ??OS_TaskResume_5: (+1)
   \       0xCE   0x....'....        BL       CPU_SR_Restore
   \       0xD2   0x....             LDR      R0,??DataTable24  ;; 0x6e2d
   \       0xD4   0x8020             STRH     R0,[R4, #+0]
   \       0xD6   0xE7B0             B        ??OS_TaskResume_7
   2274          #endif
   2275          
   2276          /*$PAGE*/
   2277          /*
   2278          ************************************************************************************************************************
   2279          *                                              CATCH ACCIDENTAL TASK RETURN
   2280          *
   2281          * Description: This function is called if a task accidentally returns without deleting itself.  In other words, a task
   2282          *              should either be an infinite loop or delete itself if it's done.
   2283          *
   2284          * Arguments  : none
   2285          *
   2286          * Returns    : none
   2287          *
   2288          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2289          ************************************************************************************************************************
   2290          */
   2291          

   \                                 In section .text, align 2, keep-with-next
   2292          void  OS_TaskReturn (void)
   2293          {
   \                     OS_TaskReturn: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2294              OS_ERR  err;
   2295          
   2296          
   2297          
   2298              OSTaskReturnHook(OSTCBCurPtr);                          /* Call hook to let user decide on what to do             */
   \        0x2   0x....             LDR      R0,??DataTable25
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x....'....        BL       OSTaskReturnHook
   2299          #if OS_CFG_TASK_DEL_EN > 0u
   2300              OSTaskDel((OS_TCB *)0,                                  /* Delete task if it accidentally returns!                */
   2301                        (OS_ERR *)&err);
   \        0xA   0x4669             MOV      R1,SP
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x....'....        BL       OSTaskDel
   2302          #else
   2303              for (;;) {
   2304                  OSTimeDly((OS_TICK )OSCfg_TickRate_Hz,
   2305                            (OS_OPT  )OS_OPT_TIME_DLY,
   2306                            (OS_ERR *)&err);
   2307              }
   2308          #endif
   2309          }
   \       0x12   0xBD01             POP      {R0,PC}          ;; return
   2310          
   2311          /*$PAGE*/
   2312          /*
   2313          ************************************************************************************************************************
   2314          *                                                    SIGNAL A TASK
   2315          *
   2316          * Description: This function is called to signal a task waiting for a signal.
   2317          *
   2318          * Arguments  : p_tcb     is the pointer to the TCB of the task to signal.  A NULL pointer indicates that you are sending
   2319          *                        a signal to yourself.
   2320          *
   2321          *              opt       determines the type of POST performed:
   2322          *
   2323          *                             OS_OPT_POST_NONE         No option
   2324          *
   2325          *                             OS_OPT_POST_NO_SCHED     Do not call the scheduler
   2326          *
   2327          *              ts        is a timestamp indicating when the post occurred.
   2328          *
   2329          *              p_err     is a pointer to an error code returned by this function:
   2330          *
   2331          *                            OS_ERR_NONE           If the requested task is signaled
   2332          *                            OS_ERR_SEM_OVF        If the post would cause the semaphore count to overflow.
   2333          *                            OS_ERR_STATE_INVALID  If the task is in an invalid state.  This should never happen
   2334          *                                                  and if it does, would be considered a system failure.
   2335          *
   2336          * Returns    : The current value of the task's signal counter or 0 if called from an ISR
   2337          *
   2338          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2339          ************************************************************************************************************************
   2340          */
   2341          

   \                                 In section .text, align 2, keep-with-next
   2342          OS_SEM_CTR  OS_TaskSemPost (OS_TCB  *p_tcb,
   2343                                      OS_OPT   opt,
   2344                                      CPU_TS   ts,
   2345                                      OS_ERR  *p_err)
   2346          {
   \                     OS_TaskSemPost: (+1)
   \        0x0   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \        0x2   0xB081             SUB      SP,SP,#+4
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x0017             MOVS     R7,R2
   \        0x8   0x001E             MOVS     R6,R3
   2347              OS_SEM_CTR  ctr;
   2348              CPU_SR_ALLOC();
   \        0xA   0x2000             MOVS     R0,#+0
   2349          
   2350          
   2351          
   2352              OS_CRITICAL_ENTER();
   \        0xC   0x....'....        BL       CPU_SR_Save
   \       0x10   0x....             LDR      R5,??DataTable25_1
   \       0x12   0x7829             LDRB     R1,[R5, #+0]
   \       0x14   0x1C49             ADDS     R1,R1,#+1
   \       0x16   0x7029             STRB     R1,[R5, #+0]
   \       0x18   0x....'....        BL       CPU_SR_Restore
   2353              if (p_tcb == (OS_TCB *)0) {                             /* Post signal to 'self'?                                 */
   \       0x1C   0x2C00             CMP      R4,#+0
   \       0x1E   0xD101             BNE      ??OS_TaskSemPost_0
   2354                  p_tcb = OSTCBCurPtr;
   \       0x20   0x....             LDR      R0,??DataTable25
   \       0x22   0x6804             LDR      R4,[R0, #+0]
   \                     ??OS_TaskSemPost_0: (+1)
   \       0x24   0x9600             STR      R6,[SP, #+0]
   2355              }
   2356              p_tcb->TS = ts;
   \       0x26   0x6427             STR      R7,[R4, #+64]
   2357             *p_err     = OS_ERR_NONE;                                /* Assume we won't have any errors                        */
   \       0x28   0x2600             MOVS     R6,#+0
   \       0x2A   0x0030             MOVS     R0,R6
   \       0x2C   0x9900             LDR      R1,[SP, #+0]
   \       0x2E   0x8008             STRH     R0,[R1, #+0]
   2358              switch (p_tcb->TaskState) {
   \       0x30   0x2036             MOVS     R0,#+54
   \       0x32   0x5C20             LDRB     R0,[R4, R0]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0x2801             CMP      R0,#+1
   \       0x38   0xD909             BLS      ??OS_TaskSemPost_1
   \       0x3A   0x1E80             SUBS     R0,R0,#+2
   \       0x3C   0x2801             CMP      R0,#+1
   \       0x3E   0xD941             BLS      ??OS_TaskSemPost_2
   \       0x40   0x1E80             SUBS     R0,R0,#+2
   \       0x42   0x2801             CMP      R0,#+1
   \       0x44   0xD903             BLS      ??OS_TaskSemPost_1
   \       0x46   0x1E80             SUBS     R0,R0,#+2
   \       0x48   0x2801             CMP      R0,#+1
   \       0x4A   0xD93B             BLS      ??OS_TaskSemPost_2
   \       0x4C   0xE08F             B        ??OS_TaskSemPost_3
   2359                  case OS_TASK_STATE_RDY:
   2360                  case OS_TASK_STATE_DLY:
   2361                  case OS_TASK_STATE_SUSPENDED:
   2362                  case OS_TASK_STATE_DLY_SUSPENDED:
   2363                       switch (sizeof(OS_SEM_CTR)) {
   2364                           case 1u:
   2365                                if (p_tcb->SemCtr == DEF_INT_08U_MAX_VAL) {
   2366                                    OS_CRITICAL_EXIT();
   2367                                   *p_err = OS_ERR_SEM_OVF;
   2368                                    return ((OS_SEM_CTR)0);
   2369                                }
   2370                                break;
   2371          
   2372                           case 2u:
   2373                                if (p_tcb->SemCtr == DEF_INT_16U_MAX_VAL) {
   2374                                    OS_CRITICAL_EXIT();
   2375                                   *p_err = OS_ERR_SEM_OVF;
   2376                                    return ((OS_SEM_CTR)0);
   2377                                }
   2378                                break;
   2379          
   2380                           case 4u:
   2381                                if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
   \                     ??OS_TaskSemPost_1: (+1)
   \       0x4E   0x6C60             LDR      R0,[R4, #+68]
   \       0x50   0x2100             MOVS     R1,#+0
   \       0x52   0x43C9             MVNS     R1,R1            ;; #-1
   \       0x54   0x4288             CMP      R0,R1
   \       0x56   0xD11A             BNE      ??OS_TaskSemPost_4
   2382                                    OS_CRITICAL_EXIT();
   \       0x58   0x....'....        BL       CPU_SR_Save
   \       0x5C   0x7829             LDRB     R1,[R5, #+0]
   \       0x5E   0x1E49             SUBS     R1,R1,#+1
   \       0x60   0x7029             STRB     R1,[R5, #+0]
   \       0x62   0x7829             LDRB     R1,[R5, #+0]
   \       0x64   0x2900             CMP      R1,#+0
   \       0x66   0xD10B             BNE      ??OS_TaskSemPost_5
   \       0x68   0x....             LDR      R1,??DataTable25_2
   \       0x6A   0x8809             LDRH     R1,[R1, #+0]
   \       0x6C   0x2900             CMP      R1,#+0
   \       0x6E   0xD004             BEQ      ??OS_TaskSemPost_6
   \       0x70   0x....'....        BL       CPU_SR_Restore
   \       0x74   0x....'....        BL       OS_Sched0
   \       0x78   0xE004             B        ??OS_TaskSemPost_7
   \                     ??OS_TaskSemPost_6: (+1)
   \       0x7A   0x....'....        BL       CPU_SR_Restore
   \       0x7E   0xE001             B        ??OS_TaskSemPost_7
   \                     ??OS_TaskSemPost_5: (+1)
   \       0x80   0x....'....        BL       CPU_SR_Restore
   2383                                   *p_err = OS_ERR_SEM_OVF;
   \                     ??OS_TaskSemPost_7: (+1)
   \       0x84   0x....             LDR      R0,??DataTable25_3  ;; 0x6dc5
   \       0x86   0x9900             LDR      R1,[SP, #+0]
   \       0x88   0x8008             STRH     R0,[R1, #+0]
   2384                                    return ((OS_SEM_CTR)0);
   \       0x8A   0x2000             MOVS     R0,#+0
   \       0x8C   0xE08A             B        ??OS_TaskSemPost_8
   2385                                }
   2386                                break;
   2387          
   2388                           default:
   2389                                break;
   2390                       }
   2391                       p_tcb->SemCtr++;                               /* Task signaled is not pending on anything               */
   \                     ??OS_TaskSemPost_4: (+1)
   \       0x8E   0x6C60             LDR      R0,[R4, #+68]
   \       0x90   0x1C40             ADDS     R0,R0,#+1
   \       0x92   0x6460             STR      R0,[R4, #+68]
   2392                       ctr = p_tcb->SemCtr;
   \       0x94   0x6C64             LDR      R4,[R4, #+68]
   2393                       OS_CRITICAL_EXIT();
   \       0x96   0x....'....        BL       CPU_SR_Save
   \       0x9A   0x7829             LDRB     R1,[R5, #+0]
   \       0x9C   0x1E49             SUBS     R1,R1,#+1
   \       0x9E   0x7029             STRB     R1,[R5, #+0]
   \       0xA0   0x7829             LDRB     R1,[R5, #+0]
   \       0xA2   0x2900             CMP      R1,#+0
   \       0xA4   0xD10B             BNE      ??OS_TaskSemPost_9
   \       0xA6   0x....             LDR      R1,??DataTable25_2
   \       0xA8   0x8809             LDRH     R1,[R1, #+0]
   \       0xAA   0x2900             CMP      R1,#+0
   \       0xAC   0xD004             BEQ      ??OS_TaskSemPost_10
   \       0xAE   0x....'....        BL       CPU_SR_Restore
   \       0xB2   0x....'....        BL       OS_Sched0
   \       0xB6   0xE004             B        ??OS_TaskSemPost_11
   \                     ??OS_TaskSemPost_10: (+1)
   \       0xB8   0x....'....        BL       CPU_SR_Restore
   \       0xBC   0xE001             B        ??OS_TaskSemPost_11
   \                     ??OS_TaskSemPost_9: (+1)
   \       0xBE   0x....'....        BL       CPU_SR_Restore
   2394                       break;
   \                     ??OS_TaskSemPost_11: (+1)
   \       0xC2   0xE06E             B        ??OS_TaskSemPost_12
   2395          
   2396                  case OS_TASK_STATE_PEND:
   2397                  case OS_TASK_STATE_PEND_TIMEOUT:
   2398                  case OS_TASK_STATE_PEND_SUSPENDED:
   2399                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   2400                       if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_SEM) {   /* Is task signaled waiting for a signal?             */
   \                     ??OS_TaskSemPost_2: (+1)
   \       0xC4   0x2034             MOVS     R0,#+52
   \       0xC6   0x5C20             LDRB     R0,[R4, R0]
   \       0xC8   0x2807             CMP      R0,#+7
   \       0xCA   0xD115             BNE      ??OS_TaskSemPost_13
   \       0xCC   0x4668             MOV      R0,SP
   \       0xCE   0x8906             LDRH     R6,[R0, #+8]
   2401                           OS_Post((OS_PEND_OBJ *)0,                      /*      Task is pending on signal                     */
   2402                                   (OS_TCB      *)p_tcb,
   2403                                   (void        *)0,
   2404                                   (OS_MSG_SIZE  )0u,
   2405                                   (CPU_TS       )ts);
   \       0xD0   0x9700             STR      R7,[SP, #+0]
   \       0xD2   0x2300             MOVS     R3,#+0
   \       0xD4   0x2200             MOVS     R2,#+0
   \       0xD6   0x0021             MOVS     R1,R4
   \       0xD8   0x2000             MOVS     R0,#+0
   \       0xDA   0x....'....        BL       OS_Post
   2406                           ctr = p_tcb->SemCtr;
   \       0xDE   0x6C64             LDR      R4,[R4, #+68]
   2407                           OS_CRITICAL_EXIT_NO_SCHED();
   \       0xE0   0x....'....        BL       CPU_SR_Save
   \       0xE4   0x7829             LDRB     R1,[R5, #+0]
   \       0xE6   0x1E49             SUBS     R1,R1,#+1
   \       0xE8   0x7029             STRB     R1,[R5, #+0]
   \       0xEA   0x....'....        BL       CPU_SR_Restore
   2408                           if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
   \       0xEE   0x0430             LSLS     R0,R6,#+16
   \       0xF0   0xD43C             BMI      ??OS_TaskSemPost_14
   2409                               OSSched();                                 /* Run the scheduler                                  */
   \       0xF2   0x....'....        BL       OSSched
   \       0xF6   0xE039             B        ??OS_TaskSemPost_14
   2410                           }
   2411                       } else {
   2412                           switch (sizeof(OS_SEM_CTR)) {
   2413                               case 1u:
   2414                                    if (p_tcb->SemCtr == DEF_INT_08U_MAX_VAL) {
   2415                                        OS_CRITICAL_EXIT();
   2416                                       *p_err = OS_ERR_SEM_OVF;
   2417                                        return ((OS_SEM_CTR)0);
   2418                                    }
   2419                                    break;
   2420          
   2421                               case 2u:
   2422                                    if (p_tcb->SemCtr == DEF_INT_16U_MAX_VAL) {
   2423                                        OS_CRITICAL_EXIT();
   2424                                       *p_err = OS_ERR_SEM_OVF;
   2425                                        return ((OS_SEM_CTR)0);
   2426                                    }
   2427                                    break;
   2428          
   2429                               case 4u:
   2430                                    if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
   \                     ??OS_TaskSemPost_13: (+1)
   \       0xF8   0x6C60             LDR      R0,[R4, #+68]
   \       0xFA   0x2100             MOVS     R1,#+0
   \       0xFC   0x43C9             MVNS     R1,R1            ;; #-1
   \       0xFE   0x4288             CMP      R0,R1
   \      0x100   0xD11A             BNE      ??OS_TaskSemPost_15
   2431                                        OS_CRITICAL_EXIT();
   \      0x102   0x....'....        BL       CPU_SR_Save
   \      0x106   0x7829             LDRB     R1,[R5, #+0]
   \      0x108   0x1E49             SUBS     R1,R1,#+1
   \      0x10A   0x7029             STRB     R1,[R5, #+0]
   \      0x10C   0x7829             LDRB     R1,[R5, #+0]
   \      0x10E   0x2900             CMP      R1,#+0
   \      0x110   0xD10B             BNE      ??OS_TaskSemPost_16
   \      0x112   0x....             LDR      R1,??DataTable25_2
   \      0x114   0x8809             LDRH     R1,[R1, #+0]
   \      0x116   0x2900             CMP      R1,#+0
   \      0x118   0xD004             BEQ      ??OS_TaskSemPost_17
   \      0x11A   0x....'....        BL       CPU_SR_Restore
   \      0x11E   0x....'....        BL       OS_Sched0
   \      0x122   0xE004             B        ??OS_TaskSemPost_18
   \                     ??OS_TaskSemPost_17: (+1)
   \      0x124   0x....'....        BL       CPU_SR_Restore
   \      0x128   0xE001             B        ??OS_TaskSemPost_18
   \                     ??OS_TaskSemPost_16: (+1)
   \      0x12A   0x....'....        BL       CPU_SR_Restore
   2432                                       *p_err = OS_ERR_SEM_OVF;
   \                     ??OS_TaskSemPost_18: (+1)
   \      0x12E   0x....             LDR      R0,??DataTable25_3  ;; 0x6dc5
   \      0x130   0x9900             LDR      R1,[SP, #+0]
   \      0x132   0x8008             STRH     R0,[R1, #+0]
   2433                                        return ((OS_SEM_CTR)0);
   \      0x134   0x2000             MOVS     R0,#+0
   \      0x136   0xE035             B        ??OS_TaskSemPost_8
   2434                                    }
   2435                                    break;
   2436          
   2437                               default:
   2438                                    break;
   2439                           }
   2440                           p_tcb->SemCtr++;                           /* No,  Task signaled is NOT pending on semaphore ...     */
   \                     ??OS_TaskSemPost_15: (+1)
   \      0x138   0x6C60             LDR      R0,[R4, #+68]
   \      0x13A   0x1C40             ADDS     R0,R0,#+1
   \      0x13C   0x6460             STR      R0,[R4, #+68]
   2441                           ctr = p_tcb->SemCtr;                       /*      ... it must be waiting on something else          */
   \      0x13E   0x6C64             LDR      R4,[R4, #+68]
   2442                           OS_CRITICAL_EXIT();
   \      0x140   0x....'....        BL       CPU_SR_Save
   \      0x144   0x7829             LDRB     R1,[R5, #+0]
   \      0x146   0x1E49             SUBS     R1,R1,#+1
   \      0x148   0x7029             STRB     R1,[R5, #+0]
   \      0x14A   0x7829             LDRB     R1,[R5, #+0]
   \      0x14C   0x2900             CMP      R1,#+0
   \      0x14E   0xD10B             BNE      ??OS_TaskSemPost_19
   \      0x150   0x....             LDR      R1,??DataTable25_2
   \      0x152   0x8809             LDRH     R1,[R1, #+0]
   \      0x154   0x2900             CMP      R1,#+0
   \      0x156   0xD004             BEQ      ??OS_TaskSemPost_20
   \      0x158   0x....'....        BL       CPU_SR_Restore
   \      0x15C   0x....'....        BL       OS_Sched0
   \      0x160   0xE004             B        ??OS_TaskSemPost_21
   \                     ??OS_TaskSemPost_20: (+1)
   \      0x162   0x....'....        BL       CPU_SR_Restore
   \      0x166   0xE001             B        ??OS_TaskSemPost_21
   \                     ??OS_TaskSemPost_19: (+1)
   \      0x168   0x....'....        BL       CPU_SR_Restore
   2443                       }
   2444                       break;
   \                     ??OS_TaskSemPost_21: (+1)
   \                     ??OS_TaskSemPost_14: (+1)
   \      0x16C   0xE019             B        ??OS_TaskSemPost_12
   2445          
   2446                  default:
   2447                       OS_CRITICAL_EXIT();
   \                     ??OS_TaskSemPost_3: (+1)
   \      0x16E   0x....'....        BL       CPU_SR_Save
   \      0x172   0x7829             LDRB     R1,[R5, #+0]
   \      0x174   0x1E49             SUBS     R1,R1,#+1
   \      0x176   0x7029             STRB     R1,[R5, #+0]
   \      0x178   0x7829             LDRB     R1,[R5, #+0]
   \      0x17A   0x2900             CMP      R1,#+0
   \      0x17C   0xD10B             BNE      ??OS_TaskSemPost_22
   \      0x17E   0x....             LDR      R1,??DataTable25_2
   \      0x180   0x8809             LDRH     R1,[R1, #+0]
   \      0x182   0x2900             CMP      R1,#+0
   \      0x184   0xD004             BEQ      ??OS_TaskSemPost_23
   \      0x186   0x....'....        BL       CPU_SR_Restore
   \      0x18A   0x....'....        BL       OS_Sched0
   \      0x18E   0xE004             B        ??OS_TaskSemPost_24
   \                     ??OS_TaskSemPost_23: (+1)
   \      0x190   0x....'....        BL       CPU_SR_Restore
   \      0x194   0xE001             B        ??OS_TaskSemPost_24
   \                     ??OS_TaskSemPost_22: (+1)
   \      0x196   0x....'....        BL       CPU_SR_Restore
   2448                      *p_err = OS_ERR_STATE_INVALID;
   \                     ??OS_TaskSemPost_24: (+1)
   \      0x19A   0x....             LDR      R0,??DataTable24  ;; 0x6e2d
   \      0x19C   0x9900             LDR      R1,[SP, #+0]
   \      0x19E   0x8008             STRH     R0,[R1, #+0]
   2449                       ctr   = (OS_SEM_CTR)0;
   \      0x1A0   0x0034             MOVS     R4,R6
   2450                       break;
   2451              }
   2452              return (ctr);
   \                     ??OS_TaskSemPost_12: (+1)
   \      0x1A2   0x0020             MOVS     R0,R4
   \                     ??OS_TaskSemPost_8: (+1)
   \      0x1A4   0xBDFE             POP      {R1-R7,PC}       ;; return
   2453          }
   2454          
   2455          /*$PAGE*/
   2456          /*
   2457          ************************************************************************************************************************
   2458          *                                                   SUSPEND A TASK
   2459          *
   2460          * Description: This function is called to suspend a task.  The task can be the calling task if 'p_tcb' is a NULL pointer
   2461          *              or the pointer to the TCB of the calling task.
   2462          *
   2463          * Arguments  : p_tcb    is a pointer to the TCB to suspend.
   2464          *                       If p_tcb is a NULL pointer then, suspend the current task.
   2465          *
   2466          *              p_err    is a pointer to a variable that will receive an error code from this function.
   2467          *
   2468          *                           OS_ERR_NONE                      if the requested task is suspended
   2469          *                           OS_ERR_SCHED_LOCKED              you can't suspend the current task is the scheduler is
   2470          *                                                            locked
   2471          *                           OS_ERR_TASK_SUSPEND_ISR          if you called this function from an ISR
   2472          *                           OS_ERR_TASK_SUSPEND_IDLE         if you attempted to suspend the idle task which is not
   2473          *                                                            allowed.
   2474          *                           OS_ERR_TASK_SUSPEND_INT_HANDLER  if you attempted to suspend the idle task which is not
   2475          *                                                            allowed.
   2476          *
   2477          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application should not call it.
   2478          *
   2479          *              2) You should use this function with great care.  If you suspend a task that is waiting for an event
   2480          *                 (i.e. a message, a semaphore, a queue ...) you will prevent this task from running when the event
   2481          *                 arrives.
   2482          ************************************************************************************************************************
   2483          */
   2484          
   2485          #if OS_CFG_TASK_SUSPEND_EN > 0u

   \                                 In section .text, align 2, keep-with-next
   2486          void   OS_TaskSuspend (OS_TCB  *p_tcb,
   2487                                 OS_ERR  *p_err)
   2488          {
   \                     OS_TaskSuspend: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   2489              CPU_SR_ALLOC();
   \        0x6   0x2600             MOVS     R6,#+0
   \        0x8   0x0030             MOVS     R0,R6
   2490          
   2491          
   2492          
   2493              CPU_CRITICAL_ENTER();
   \        0xA   0x....'....        BL       CPU_SR_Save
   2494              if (p_tcb == (OS_TCB *)0) {                             /* See if specified to suspend self                       */
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD101             BNE      ??OS_TaskSuspend_0
   2495                  p_tcb = OSTCBCurPtr;
   \       0x12   0x....             LDR      R1,??DataTable25
   \       0x14   0x680D             LDR      R5,[R1, #+0]
   2496              }
   2497          
   2498              if (p_tcb == OSTCBCurPtr) {
   \                     ??OS_TaskSuspend_0: (+1)
   \       0x16   0x....             LDR      R1,??DataTable25
   \       0x18   0x6809             LDR      R1,[R1, #+0]
   \       0x1A   0x428D             CMP      R5,R1
   \       0x1C   0xD108             BNE      ??OS_TaskSuspend_1
   2499                  if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't suspend when the scheduler is locked             */
   \       0x1E   0x....             LDR      R1,??DataTable25_1
   \       0x20   0x7809             LDRB     R1,[R1, #+0]
   \       0x22   0x2900             CMP      R1,#+0
   \       0x24   0xD004             BEQ      ??OS_TaskSuspend_1
   2500                      CPU_CRITICAL_EXIT();
   \       0x26   0x....'....        BL       CPU_SR_Restore
   2501                     *p_err = OS_ERR_SCHED_LOCKED;
   \       0x2A   0x....             LDR      R0,??DataTable25_4  ;; 0x6d63
   \       0x2C   0x8020             STRH     R0,[R4, #+0]
   2502                      return;
   \       0x2E   0xE026             B        ??OS_TaskSuspend_2
   2503                  }
   2504              }
   2505          
   2506             *p_err = OS_ERR_NONE;
   \                     ??OS_TaskSuspend_1: (+1)
   \       0x30   0x8026             STRH     R6,[R4, #+0]
   2507              switch (p_tcb->TaskState) {
   \       0x32   0x2136             MOVS     R1,#+54
   \       0x34   0x5C69             LDRB     R1,[R5, R1]
   \       0x36   0x2900             CMP      R1,#+0
   \       0x38   0xD009             BEQ      ??OS_TaskSuspend_3
   \       0x3A   0x1E49             SUBS     R1,R1,#+1
   \       0x3C   0xD020             BEQ      ??OS_TaskSuspend_4
   \       0x3E   0x1E49             SUBS     R1,R1,#+1
   \       0x40   0xD027             BEQ      ??OS_TaskSuspend_5
   \       0x42   0x1E49             SUBS     R1,R1,#+1
   \       0x44   0xD02E             BEQ      ??OS_TaskSuspend_6
   \       0x46   0x1E49             SUBS     R1,R1,#+1
   \       0x48   0x2903             CMP      R1,#+3
   \       0x4A   0xD934             BLS      ??OS_TaskSuspend_7
   \       0x4C   0xE03B             B        ??OS_TaskSuspend_8
   2508                  case OS_TASK_STATE_RDY:
   2509                       OS_CRITICAL_ENTER_CPU_EXIT();
   \                     ??OS_TaskSuspend_3: (+1)
   \       0x4E   0x....             LDR      R4,??DataTable25_1
   \       0x50   0x7821             LDRB     R1,[R4, #+0]
   \       0x52   0x1C49             ADDS     R1,R1,#+1
   \       0x54   0x7021             STRB     R1,[R4, #+0]
   \       0x56   0x....'....        BL       CPU_SR_Restore
   2510                       p_tcb->TaskState  =  OS_TASK_STATE_SUSPENDED;
   \       0x5A   0x2004             MOVS     R0,#+4
   \       0x5C   0x2136             MOVS     R1,#+54
   \       0x5E   0x5468             STRB     R0,[R5, R1]
   2511                       p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
   \       0x60   0x2001             MOVS     R0,#+1
   \       0x62   0x218A             MOVS     R1,#+138
   \       0x64   0x5468             STRB     R0,[R5, R1]
   2512                       OS_RdyListRemove(p_tcb);
   \       0x66   0x0028             MOVS     R0,R5
   \       0x68   0x....'....        BL       OS_RdyListRemove
   2513                       OS_CRITICAL_EXIT_NO_SCHED();
   \       0x6C   0x....'....        BL       CPU_SR_Save
   \       0x70   0x7821             LDRB     R1,[R4, #+0]
   \       0x72   0x1E49             SUBS     R1,R1,#+1
   \       0x74   0x7021             STRB     R1,[R4, #+0]
   \       0x76   0x....'....        BL       CPU_SR_Restore
   2514                       break;
   2515          
   2516                  case OS_TASK_STATE_DLY:
   2517                       p_tcb->TaskState  = OS_TASK_STATE_DLY_SUSPENDED;
   2518                       p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
   2519                       CPU_CRITICAL_EXIT();
   2520                       break;
   2521          
   2522                  case OS_TASK_STATE_PEND:
   2523                       p_tcb->TaskState  = OS_TASK_STATE_PEND_SUSPENDED;
   2524                       p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
   2525                       CPU_CRITICAL_EXIT();
   2526                       break;
   2527          
   2528                  case OS_TASK_STATE_PEND_TIMEOUT:
   2529                       p_tcb->TaskState  = OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED;
   2530                       p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
   2531                       CPU_CRITICAL_EXIT();
   2532                       break;
   2533          
   2534                  case OS_TASK_STATE_SUSPENDED:
   2535                  case OS_TASK_STATE_DLY_SUSPENDED:
   2536                  case OS_TASK_STATE_PEND_SUSPENDED:
   2537                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   2538                       p_tcb->SuspendCtr++;
   2539                       CPU_CRITICAL_EXIT();
   2540                       break;
   2541          
   2542                  default:
   2543                       CPU_CRITICAL_EXIT();
   2544                      *p_err = OS_ERR_STATE_INVALID;
   2545                       return;
   2546              }
   2547          
   2548              OSSched();
   \                     ??OS_TaskSuspend_9: (+1)
   \       0x7A   0x....'....        BL       OSSched
   2549          }
   \                     ??OS_TaskSuspend_2: (+1)
   \       0x7E   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??OS_TaskSuspend_4: (+1)
   \       0x80   0x2105             MOVS     R1,#+5
   \       0x82   0x2236             MOVS     R2,#+54
   \       0x84   0x54A9             STRB     R1,[R5, R2]
   \       0x86   0x2101             MOVS     R1,#+1
   \       0x88   0x228A             MOVS     R2,#+138
   \       0x8A   0x54A9             STRB     R1,[R5, R2]
   \       0x8C   0x....'....        BL       CPU_SR_Restore
   \       0x90   0xE7F3             B        ??OS_TaskSuspend_9
   \                     ??OS_TaskSuspend_5: (+1)
   \       0x92   0x2106             MOVS     R1,#+6
   \       0x94   0x2236             MOVS     R2,#+54
   \       0x96   0x54A9             STRB     R1,[R5, R2]
   \       0x98   0x2101             MOVS     R1,#+1
   \       0x9A   0x228A             MOVS     R2,#+138
   \       0x9C   0x54A9             STRB     R1,[R5, R2]
   \       0x9E   0x....'....        BL       CPU_SR_Restore
   \       0xA2   0xE7EA             B        ??OS_TaskSuspend_9
   \                     ??OS_TaskSuspend_6: (+1)
   \       0xA4   0x2107             MOVS     R1,#+7
   \       0xA6   0x2236             MOVS     R2,#+54
   \       0xA8   0x54A9             STRB     R1,[R5, R2]
   \       0xAA   0x2101             MOVS     R1,#+1
   \       0xAC   0x228A             MOVS     R2,#+138
   \       0xAE   0x54A9             STRB     R1,[R5, R2]
   \       0xB0   0x....'....        BL       CPU_SR_Restore
   \       0xB4   0xE7E1             B        ??OS_TaskSuspend_9
   \                     ??OS_TaskSuspend_7: (+1)
   \       0xB6   0x218A             MOVS     R1,#+138
   \       0xB8   0x5C69             LDRB     R1,[R5, R1]
   \       0xBA   0x1C49             ADDS     R1,R1,#+1
   \       0xBC   0x228A             MOVS     R2,#+138
   \       0xBE   0x54A9             STRB     R1,[R5, R2]
   \       0xC0   0x....'....        BL       CPU_SR_Restore
   \       0xC4   0xE7D9             B        ??OS_TaskSuspend_9
   \                     ??OS_TaskSuspend_8: (+1)
   \       0xC6   0x....'....        BL       CPU_SR_Restore
   \       0xCA   0x....             LDR      R0,??DataTable25_5  ;; 0x6e2d
   \       0xCC   0x8020             STRH     R0,[R4, #+0]
   \       0xCE   0xE7D6             B        ??OS_TaskSuspend_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \        0x0   0x....'....        DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \        0x0   0x0000'7149        DC32     0x7149

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \        0x0   0x0000'6273        DC32     0x6273

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_3:
   \        0x0   0x....'....        DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x....'....        DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x....'....        DC32     OSIntQNbrEntries

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \        0x0   0x0000'6E2D        DC32     0x6e2d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \        0x0   0x....'....        DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \        0x0   0x0000'714A        DC32     0x714a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \        0x0   0x0000'71AD        DC32     0x71ad

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \        0x0   0x0000'714F        DC32     0x714f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_7:
   \        0x0   0x0000'6E2F        DC32     0x6e2f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_8:
   \        0x0   0x....'....        DC32     OSCfg_StkSizeMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_9:
   \        0x0   0x0000'6E30        DC32     0x6e30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_10:
   \        0x0   0x0000'6E31        DC32     0x6e31

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x0000'6273        DC32     0x6273

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x....'....        DC32     OSIntQTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x....'....        DC32     OSIdleTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x....'....        DC32     OSSchedRoundRobinDfltTimeQuanta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     OSTaskQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x....'....        DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x....'....        DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \        0x0   0x0000'714E        DC32     0x714e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \        0x0   0x0000'714C        DC32     0x714c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \        0x0   0x0000'714D        DC32     0x714d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \        0x0   0x....'....        DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \        0x0   0x....'....        DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x....'....        DC32     OSIntQNbrEntries

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x0000'6E2D        DC32     0x6e2d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x0000'61AE        DC32     0x61ae

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x0000'62D5        DC32     0x62d5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x....'....        DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x0000'5E25        DC32     0x5e25

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \        0x0   0x0000'61B0        DC32     0x61b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \        0x0   0x....'....        DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \        0x0   0x0000'6D63        DC32     0x6d63

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \        0x0   0x0000'61A9        DC32     0x61a9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \        0x0   0x0000'72D9        DC32     0x72d9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \        0x0   0x0000'7FF0        DC32     0x7ff0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x4753'4D54        DC32     0x47534d54

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x0000'6979        DC32     0x6979

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0x....'....        DC32     OSTaskRegNextAvailID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x0000'59DA        DC32     0x59da

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x0000'7157        DC32     0x7157

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x....'....        DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x5345'5254        DC32     0x53455254

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0x0000'61AE        DC32     0x61ae

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0x....'....        DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \        0x0   0x0000'5E25        DC32     0x5e25

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x0000'61B0        DC32     0x61b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x....'....        DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0x0000'6D63        DC32     0x6d63

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0x0000'61A9        DC32     0x61a9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0x0000'72D9        DC32     0x72d9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0x0000'61AA        DC32     0x61aa

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x0000'6E2E        DC32     0x6e2e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \        0x0   0x0000'61AC        DC32     0x61ac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0x0000'61AB        DC32     0x61ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0x....'....        DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \        0x0   0x0000'6DC6        DC32     0x6dc6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0x4749'5354        DC32     0x47495354

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \        0x0   0x....'....        DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \        0x0   0x0000'7159        DC32     0x7159

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \        0x0   0x0000'62D5        DC32     0x62d5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \        0x0   0x0000'7152        DC32     0x7152

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \        0x0   0x0000'7154        DC32     0x7154

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \        0x0   0x....'....        DC32     OSIdleTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_7:
   \        0x0   0x0000'715B        DC32     0x715b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_8:
   \        0x0   0x....'....        DC32     OSIntQTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_9:
   \        0x0   0x0000'715C        DC32     0x715c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_10:
   \        0x0   0x5355'5354        DC32     0x53555354

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \        0x0   0x....'....        DC32     OSSchedRoundRobinDfltTimeQuanta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \        0x0   0x....'....        DC32     OSTaskDbgListPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \        0x0   0x....'....        DC32     OSTaskQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0x....'....        DC32     OSTaskCtxSwCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \        0x0   0x20 0x00          DC8      " ",0x0,0x0

   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \        0x0   0x....'....        DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \        0x0   0x....'....        DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \        0x0   0x....'....        DC32     OSIntQNbrEntries

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0x0000'6E2D        DC32     0x6e2d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \        0x0   0x0000'7153        DC32     0x7153

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \        0x0   0x....'....        DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \        0x0   0x....'....        DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \        0x0   0x....'....        DC32     OSIntQNbrEntries

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_3:
   \        0x0   0x0000'6DC5        DC32     0x6dc5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_4:
   \        0x0   0x0000'6D63        DC32     0x6d63

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_5:
   \        0x0   0x0000'6E2D        DC32     0x6e2d

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x3F 0x54          DC8 "?Task"

   \              0x61 0x73    

   \              0x6B 0x00
   \        0x6                      DS8 2

   \                                 In section .rodata, align 2
   \        0x0   0x20 0x00          DC8 " "
   2550          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSTaskChangePrio
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_PendListChangePrio
        24   -> OS_PrioInsert
        24   -> OS_RdyListInsertHead
        24   -> OS_RdyListInsertTail
        24   -> OS_RdyListRemove
        24   -> OS_Sched0
      48   OSTaskCreate
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> OSSched
        48   -> OSTaskCreateHook
        48   -> OSTaskStkInit
        48   -> OS_MsgQInit
        48   -> OS_PrioInsert
        48   -> OS_RdyListInsertTail
        48   -> OS_Sched0
        48   -> OS_TaskDbgListAdd
        48   -> OS_TaskInitTCB
      24   OSTaskDel
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OSTaskDelHook
        24   -> OS_MsgQFreeAll
        24   -> OS_PendListRemove
        24   -> OS_RdyListRemove
        24   -> OS_Sched0
        24   -> OS_TaskDbgListRemove
        24   -> OS_TaskInitTCB
        24   -> OS_TickListRemove
      24   OSTaskQFlush
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_MsgQFreeAll
        24   -> OS_Sched0
      40   OSTaskQPend
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> OSSched
        40   -> OS_MsgQGet
        40   -> OS_Pend
      32   OSTaskQPost
        32   -> OS_IntQPost
        32   -> OS_TaskQPost
      24   OSTaskRegGet
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      16   OSTaskRegGetID
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      24   OSTaskRegSet
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      32   OSTaskResume
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OS_IntQPost
        32   -> OS_TaskResume
      32   OSTaskSemPend
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_Pend
      24   OSTaskSemPendAbort
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_PendAbort
      24   OSTaskSemPost
        24   -> OS_IntQPost
        24   -> OS_TaskSemPost
      24   OSTaskSemSet
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      24   OSTaskStkChk
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      24   OSTaskSuspend
        24   -> OS_IntQPost
        24   -> OS_TaskSuspend
      24   OSTaskTimeQuantaSet
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
       4   OS_TaskDbgListAdd
       4   OS_TaskDbgListRemove
       0   OS_TaskInit
      16   OS_TaskInitTCB
        16   -> OS_MsgQInit
      40   OS_TaskQPost
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> OSSched
        40   -> OS_MsgQPut
        40   -> OS_Post
        40   -> OS_Sched0
      16   OS_TaskResume
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
        16   -> OS_TaskRdy
       8   OS_TaskReturn
         8   -> OSTaskDel
         8   -> OSTaskReturnHook
      32   OS_TaskSemPost
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_Post
        32   -> OS_Sched0
      16   OS_TaskSuspend
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
        16   -> OS_RdyListRemove


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       4  ??DataTable0_3
       4  ??DataTable1
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable16
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable18
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable1_1
       4  ??DataTable1_10
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
       4  ??DataTable1_9
       4  ??DataTable2
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_10
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
       4  ??DataTable20_9
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable22
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable25_4
       4  ??DataTable25_5
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable5
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       8  ?_0
       2  ?_1
     288  OSTaskChangePrio
     440  OSTaskCreate
     284  OSTaskDel
     122  OSTaskQFlush
     374  OSTaskQPend
      84  OSTaskQPost
      60  OSTaskRegGet
      52  OSTaskRegGetID
      60  OSTaskRegSet
      88  OSTaskResume
     366  OSTaskSemPend
     164  OSTaskSemPendAbort
      76  OSTaskSemPost
      56  OSTaskSemSet
     142  OSTaskStkChk
      70  OSTaskSuspend
      72  OSTaskTimeQuantaSet
      38  OS_TaskDbgListAdd
      72  OS_TaskDbgListRemove
      20  OS_TaskInit
     216  OS_TaskInitTCB
     310  OS_TaskQPost
     216  OS_TaskResume
      20  OS_TaskReturn
     422  OS_TaskSemPost
     208  OS_TaskSuspend

 
    10 bytes in section .rodata
 4'676 bytes in section .text
 
 4'676 bytes of CODE  memory
    10 bytes of CONST memory

Errors: none
Warnings: none
