###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.4.261/W32 for ARM         10/Jan/2021  16:10:26
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Source\FWLib\src\stm32f0xx_spi.c
#    Command line      =
#        -f C:\Users\macanlin\AppData\Local\Temp\EWEA.tmp
#        ("C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Source\FWLib\src\stm32f0xx_spi.c" -D USE_STDPERIPH_DRIVER -D
#        STM32F072 -lC
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\List" -o
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        C:\rj\IAR\arm\inc\c\DLib_Config_Normal.h -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\BSP\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\FWLib\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\CMSIS\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\OS_Cfg\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-CPU\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-LIB\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uCOS-III\Ports\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uCOS-III\Source\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\APP\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\FWLib\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-LIB\\" -Ol -I
#        C:\rj\IAR\arm\CMSIS\Core\Include\\ -I
#        C:\rj\IAR\arm\CMSIS\DSP\Include\\)
#    Locale            =  C
#    List file         =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\List\stm32f0xx_spi.lst
#    Object file       =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\Obj\stm32f0xx_spi.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345 -1-9\Source\FWLib\src\stm32f0xx_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f0xx_spi.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    16-January-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Serial peripheral interface (SPI):
      9            *           + Initialization and Configuration
     10            *           + Data transfers functions
     11            *           + Hardware CRC Calculation
     12            *           + DMA transfers management
     13            *           + Interrupts and flags management
     14            *
     15            *  @verbatim
     16          
     17           ===============================================================================
     18                                 ##### How to use this driver #####
     19           ===============================================================================
     20              [..]
     21                  (#) Enable peripheral clock using RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE)
     22                      function for SPI1 or using RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE)
     23                      function for SPI2.
     24            
     25                  (#) Enable SCK, MOSI, MISO and NSS GPIO clocks using 
     26                      RCC_AHBPeriphClockCmd() function. 
     27            
     28                  (#) Peripherals alternate function: 
     29                      (++) Connect the pin to the desired peripherals' Alternate 
     30                           Function (AF) using GPIO_PinAFConfig() function.
     31                      (++) Configure the desired pin in alternate function by:
     32                           GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF.
     33                      (++) Select the type, pull-up/pull-down and output speed via 
     34                           GPIO_PuPd, GPIO_OType and GPIO_Speed members.
     35                      (++) Call GPIO_Init() function.
     36            
     37                  (#) Program the Polarity, Phase, First Data, Baud Rate Prescaler, Slave 
     38                      Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
     39                      function.In I2S mode, program the Mode, Standard, Data Format, MCLK 
     40                      Output, Audio frequency and Polarity using I2S_Init() function.
     41            
     42                  (#) Configure the FIFO threshold using SPI_RxFIFOThresholdConfig() to select 
     43                      at which threshold the RXNE event is generated.
     44                      
     45                  (#) Enable the NVIC and the corresponding interrupt using the function 
     46                      SPI_ITConfig() if you need to use interrupt mode. 
     47            
     48                  (#) When using the DMA mode 
     49                      (++) Configure the DMA using DMA_Init() function.
     50                      (++) Active the needed channel Request using SPI_I2S_DMACmd() function.
     51             
     52                  (#) Enable the SPI using the SPI_Cmd() function or enable the I2S using
     53                      I2S_Cmd().
     54             
     55                  (#) Enable the DMA using the DMA_Cmd() function when using DMA mode. 
     56            
     57                  (#) Optionally, you can enable/configure the following parameters without
     58                      re-initialization (i.e there is no need to call again SPI_Init() function):
     59                      (++) When bidirectional mode (SPI_Direction_1Line_Rx or SPI_Direction_1Line_Tx)
     60                           is programmed as Data direction parameter using the SPI_Init() 
     61                           function it can be possible to switch between SPI_Direction_Tx 
     62                           or SPI_Direction_Rx using the SPI_BiDirectionalLineConfig() function.
     63                      (++) When SPI_NSS_Soft is selected as Slave Select Management parameter 
     64                           using the SPI_Init() function it can be possible to manage the 
     65                           NSS internal signal using the SPI_NSSInternalSoftwareConfig() function.
     66                      (++) Reconfigure the data size using the SPI_DataSizeConfig() function.
     67                      (++) Enable or disable the SS output using the SPI_SSOutputCmd() function.  
     68            
     69                  (#) To use the CRC Hardware calculation feature refer to the Peripheral 
     70                      CRC hardware Calculation subsection.
     71            
     72              @endverbatim 
     73            ******************************************************************************
     74            * @attention
     75            *
     76            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     77            *
     78            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     79            * You may not use this file except in compliance with the License.
     80            * You may obtain a copy of the License at:
     81            *
     82            *        http://www.st.com/software_license_agreement_liberty_v2
     83            *
     84            * Unless required by applicable law or agreed to in writing, software 
     85            * distributed under the License is distributed on an "AS IS" BASIS, 
     86            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     87            * See the License for the specific language governing permissions and
     88            * limitations under the License.
     89            *
     90            ******************************************************************************
     91            */
     92          
     93          /* Includes ------------------------------------------------------------------*/
     94          #include "stm32f0xx_spi.h"
     95          #include "stm32f0xx_rcc.h"
     96          
     97          /** @addtogroup STM32F0xx_StdPeriph_Driver
     98            * @{
     99            */
    100          
    101          /** @defgroup SPI
    102            * @brief SPI driver modules
    103            * @{
    104            */
    105          
    106          /* Private typedef -----------------------------------------------------------*/
    107          /* Private define ------------------------------------------------------------*/
    108          /* SPI registers Masks */
    109          #define CR1_CLEAR_MASK       ((uint16_t)0x3040)
    110          #define CR1_CLEAR_MASK2      ((uint16_t)0xFFFB)
    111          #define CR2_LDMA_MASK        ((uint16_t)0x9FFF)
    112          
    113          #define I2SCFGR_CLEAR_Mask   ((uint16_t)0xF040)
    114          
    115          /* Private macro -------------------------------------------------------------*/
    116          /* Private variables ---------------------------------------------------------*/
    117          /* Private function prototypes -----------------------------------------------*/
    118          /* Private functions ---------------------------------------------------------*/
    119          
    120          /** @defgroup SPI_Private_Functions
    121            * @{
    122            */
    123          
    124          /** @defgroup SPI_Group1 Initialization and Configuration functions
    125           *  @brief   Initialization and Configuration functions 
    126           *
    127          @verbatim   
    128           ===============================================================================
    129                     ##### Initialization and Configuration functions #####
    130           ===============================================================================
    131              [..] This section provides a set of functions allowing to initialize the SPI Direction,
    132                   SPI Mode, SPI Data Size, SPI Polarity, SPI Phase, SPI NSS Management, SPI Baud
    133                   Rate Prescaler, SPI First Bit and SPI CRC Polynomial.
    134          
    135              [..] The SPI_Init() function follows the SPI configuration procedures for Master mode
    136                   and Slave mode (details for these procedures are available in reference manual).
    137                   
    138              [..] When the Software NSS management (SPI_InitStruct->SPI_NSS = SPI_NSS_Soft) is selected,
    139                   use the following function to manage the NSS bit:
    140                   void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft);
    141          
    142              [..] In Master mode, when the Hardware NSS management (SPI_InitStruct->SPI_NSS = SPI_NSS_Hard)
    143                   is selected, use the follwoing function to enable the NSS output feature.
    144                   void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
    145          
    146              [..] The NSS pulse mode can be managed by the SPI TI mode when enabling it using the following function:
    147                   void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
    148                   And it can be managed by software in the SPI Motorola mode using this function: 
    149                   void SPI_NSSPulseModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
    150          
    151              [..] This section provides also functions to initialize the I2S Mode, Standard, 
    152                   Data Format, MCLK Output, Audio frequency and Polarity.
    153            
    154              [..] The I2S_Init() function follows the I2S configuration procedures for Master mode
    155                   and Slave mode.
    156            
    157          @endverbatim
    158            * @{
    159            */
    160          
    161          /**
    162            * @brief  Deinitializes the SPIx peripheral registers to their default
    163            *         reset values.
    164            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    165            * @note   SPI2 is not available for STM32F031 devices.
    166            *         I2S mode is not supported for STM32F030 devices.      
    167            * @retval None
    168            */

   \                                 In section .text, align 2, keep-with-next
    169          void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
    170          {
   \                     SPI_I2S_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    171            /* Check the parameters */
    172            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    173          
    174            if (SPIx == SPI1)
   \        0x2   0x....             LDR      R1,??DataTable14  ;; 0x40013000
   \        0x4   0x4288             CMP      R0,R1
   \        0x6   0xD10A             BNE      ??SPI_I2S_DeInit_0
    175            {
    176              /* Enable SPI1 reset state */
    177              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
   \        0x8   0x2480             MOVS     R4,#+128
   \        0xA   0x0164             LSLS     R4,R4,#+5        ;; #+4096
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0x....'....        BL       RCC_APB2PeriphResetCmd
    178              /* Release SPI1 from reset state */
    179              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x....'....        BL       RCC_APB2PeriphResetCmd
   \       0x1C   0xE00C             B        ??SPI_I2S_DeInit_1
    180            }
    181            else
    182            {
    183              if (SPIx == SPI2)
   \                     ??SPI_I2S_DeInit_0: (+1)
   \       0x1E   0x....             LDR      R1,??DataTable14_1  ;; 0x40003800
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD109             BNE      ??SPI_I2S_DeInit_1
    184              {
    185                /* Enable SPI2 reset state */
    186                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
   \       0x24   0x2480             MOVS     R4,#+128
   \       0x26   0x01E4             LSLS     R4,R4,#+7        ;; #+16384
   \       0x28   0x2101             MOVS     R1,#+1
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0x....'....        BL       RCC_APB1PeriphResetCmd
    187                /* Release SPI2 from reset state */
    188                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x....'....        BL       RCC_APB1PeriphResetCmd
    189              }
    190            }
    191          }
   \                     ??SPI_I2S_DeInit_1: (+1)
   \       0x38   0xBD10             POP      {R4,PC}          ;; return
    192          
    193          /**
    194            * @brief  Fills each SPI_InitStruct member with its default value.
    195            * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure which will be initialized.
    196            * @retval None
    197            */

   \                                 In section .text, align 2, keep-with-next
    198          void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
    199          {
    200          /*--------------- Reset SPI init structure parameters values -----------------*/
    201            /* Initialize the SPI_Direction member */
    202            SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
   \                     SPI_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x8001             STRH     R1,[R0, #+0]
    203            /* Initialize the SPI_Mode member */
    204            SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
   \        0x4   0x8041             STRH     R1,[R0, #+2]
    205            /* Initialize the SPI_DataSize member */
    206            SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
   \        0x6   0x22E0             MOVS     R2,#+224
   \        0x8   0x00D2             LSLS     R2,R2,#+3        ;; #+1792
   \        0xA   0x8082             STRH     R2,[R0, #+4]
    207            /* Initialize the SPI_CPOL member */
    208            SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
   \        0xC   0x80C1             STRH     R1,[R0, #+6]
    209            /* Initialize the SPI_CPHA member */
    210            SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
   \        0xE   0x8101             STRH     R1,[R0, #+8]
    211            /* Initialize the SPI_NSS member */
    212            SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
   \       0x10   0x8141             STRH     R1,[R0, #+10]
    213            /* Initialize the SPI_BaudRatePrescaler member */
    214            SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
   \       0x12   0x8181             STRH     R1,[R0, #+12]
    215            /* Initialize the SPI_FirstBit member */
    216            SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
   \       0x14   0x81C1             STRH     R1,[R0, #+14]
    217            /* Initialize the SPI_CRCPolynomial member */
    218            SPI_InitStruct->SPI_CRCPolynomial = 7;
   \       0x16   0x2107             MOVS     R1,#+7
   \       0x18   0x8201             STRH     R1,[R0, #+16]
    219          }
   \       0x1A   0x4770             BX       LR               ;; return
    220          
    221          /**
    222            * @brief  Initializes the SPIx peripheral according to the specified 
    223            *         parameters in the SPI_InitStruct.
    224            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    225            * @note   SPI2 is not available for STM32F031 devices. 
    226            * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
    227            *         contains the configuration information for the specified SPI peripheral.
    228            * @retval None
    229            */

   \                                 In section .text, align 2, keep-with-next
    230          void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
    231          {
   \                     SPI_Init: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    232            uint16_t tmpreg = 0;
   \        0x2   0x2200             MOVS     R2,#+0
    233          
    234            /* check the parameters */
    235            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    236          
    237            /* Check the SPI parameters */
    238            assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
    239            assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
    240            assert_param(IS_SPI_DATA_SIZE(SPI_InitStruct->SPI_DataSize));
    241            assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
    242            assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
    243            assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
    244            assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
    245            assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
    246            assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
    247          
    248            /*---------------------------- SPIx CR1 Configuration ------------------------*/
    249            /* Get the SPIx CR1 value */
    250            tmpreg = SPIx->CR1;
   \        0x4   0x8803             LDRH     R3,[R0, #+0]
    251            /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, CPOL and CPHA bits */
    252            tmpreg &= CR1_CLEAR_MASK;
   \        0x6   0x22C1             MOVS     R2,#+193
   \        0x8   0x0192             LSLS     R2,R2,#+6        ;; #+12352
   \        0xA   0x401A             ANDS     R2,R2,R3
    253            /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
    254            master/slave mode, CPOL and CPHA */
    255            /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
    256            /* Set SSM, SSI bit according to SPI_NSS values */
    257            /* Set LSBFirst bit according to SPI_FirstBit value */
    258            /* Set BR bits according to SPI_BaudRatePrescaler value */
    259            /* Set CPOL bit according to SPI_CPOL value */
    260            /* Set CPHA bit according to SPI_CPHA value */
    261            tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_FirstBit |
    262                                SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA |
    263                                SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler);  
   \        0xC   0x880B             LDRH     R3,[R1, #+0]
   \        0xE   0x89CC             LDRH     R4,[R1, #+14]
   \       0x10   0x431C             ORRS     R4,R4,R3
   \       0x12   0x88CB             LDRH     R3,[R1, #+6]
   \       0x14   0x4323             ORRS     R3,R3,R4
   \       0x16   0x890C             LDRH     R4,[R1, #+8]
   \       0x18   0x431C             ORRS     R4,R4,R3
   \       0x1A   0x894D             LDRH     R5,[R1, #+10]
   \       0x1C   0x4325             ORRS     R5,R5,R4
   \       0x1E   0x898B             LDRH     R3,[R1, #+12]
   \       0x20   0x432B             ORRS     R3,R3,R5
   \       0x22   0x4313             ORRS     R3,R3,R2
    264            /* Write to SPIx CR1 */
    265            SPIx->CR1 = tmpreg;
   \       0x24   0x8003             STRH     R3,[R0, #+0]
    266            /*-------------------------Data Size Configuration -----------------------*/
    267            /* Get the SPIx CR2 value */
    268            tmpreg = SPIx->CR2;
   \       0x26   0x8882             LDRH     R2,[R0, #+4]
    269            /* Clear DS[3:0] bits */
    270            tmpreg &=(uint16_t)~SPI_CR2_DS;
   \       0x28   0x....             LDR      R3,??DataTable14_2  ;; 0xf0ff
   \       0x2A   0x4013             ANDS     R3,R3,R2
    271            /* Configure SPIx: Data Size */
    272            tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
   \       0x2C   0x888A             LDRH     R2,[R1, #+4]
   \       0x2E   0x431A             ORRS     R2,R2,R3
    273            /* Write to SPIx CR2 */
    274            SPIx->CR2 = tmpreg;
   \       0x30   0x8082             STRH     R2,[R0, #+4]
    275            
    276            /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
    277            /* Write to SPIx CRCPOLY */
    278            SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
   \       0x32   0x8A0A             LDRH     R2,[R1, #+16]
   \       0x34   0x8202             STRH     R2,[R0, #+16]
    279            
    280            /*---------------------------- SPIx CR1 Configuration ------------------------*/
    281            /* Get the SPIx CR1 value */
    282            tmpreg = SPIx->CR1;
   \       0x36   0x8802             LDRH     R2,[R0, #+0]
    283            /* Clear MSTR bit */
    284            tmpreg &= CR1_CLEAR_MASK2;
   \       0x38   0x....             LDR      R3,??DataTable14_3  ;; 0xfffb
   \       0x3A   0x4013             ANDS     R3,R3,R2
    285            /* Configure SPIx: master/slave mode */  
    286            /* Set MSTR bit according to SPI_Mode */
    287            tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Mode);  
   \       0x3C   0x8849             LDRH     R1,[R1, #+2]
   \       0x3E   0x4319             ORRS     R1,R1,R3
    288            /* Write to SPIx CR1 */
    289            SPIx->CR1 = tmpreg;  
   \       0x40   0x8001             STRH     R1,[R0, #+0]
    290            
    291            /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
    292            SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
   \       0x42   0x8B81             LDRH     R1,[R0, #+28]
   \       0x44   0x....             LDR      R2,??DataTable14_4  ;; 0xf7ff
   \       0x46   0x400A             ANDS     R2,R2,R1
   \       0x48   0x8382             STRH     R2,[R0, #+28]
    293          }
   \       0x4A   0xBC30             POP      {R4,R5}
   \       0x4C   0x4770             BX       LR               ;; return
    294          
    295          /**
    296            * @brief  Fills each I2S_InitStruct member with its default value.
    297            * @note   This mode is not supported for STM32F030 devices.  
    298            * @param  I2S_InitStruct: pointer to a I2S_InitTypeDef structure which will be initialized.
    299            * @retval None
    300            */

   \                                 In section .text, align 2, keep-with-next
    301          void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
    302          {
    303          /*--------------- Reset I2S init structure parameters values -----------------*/
    304            /* Initialize the I2S_Mode member */
    305            I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
   \                     I2S_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x8001             STRH     R1,[R0, #+0]
    306          
    307            /* Initialize the I2S_Standard member */
    308            I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
   \        0x4   0x8041             STRH     R1,[R0, #+2]
    309          
    310            /* Initialize the I2S_DataFormat member */
    311            I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
   \        0x6   0x8081             STRH     R1,[R0, #+4]
    312          
    313            /* Initialize the I2S_MCLKOutput member */
    314            I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
   \        0x8   0x80C1             STRH     R1,[R0, #+6]
    315          
    316            /* Initialize the I2S_AudioFreq member */
    317            I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
   \        0xA   0x2202             MOVS     R2,#+2
   \        0xC   0x6082             STR      R2,[R0, #+8]
    318          
    319            /* Initialize the I2S_CPOL member */
    320            I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
   \        0xE   0x8181             STRH     R1,[R0, #+12]
    321          }
   \       0x10   0x4770             BX       LR               ;; return
    322          
    323          /**
    324            * @brief  Initializes the SPIx peripheral according to the specified 
    325            *         parameters in the I2S_InitStruct.
    326            * @note   This mode is not supported for STM32F030 devices.  
    327            * @param  SPIx: where x can be 1 to select the SPI peripheral (configured in I2S mode).  
    328            * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
    329            *         contains the configuration information for the specified SPI peripheral
    330            *         configured in I2S mode.
    331            * @note   This function calculates the optimal prescaler needed to obtain the most 
    332            *         accurate audio frequency (depending on the I2S clock source, the PLL values 
    333            *         and the product configuration). But in case the prescaler value is greater 
    334            *         than 511, the default value (0x02) will be configured instead.
    335            * @retval None
    336            */

   \                                 In section .text, align 2, keep-with-next
    337          void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
    338          {
   \                     I2S_Init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB08A             SUB      SP,SP,#+40
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000C             MOVS     R4,R1
    339            uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
   \        0x8   0x2700             MOVS     R7,#+0
   \        0xA   0x0038             MOVS     R0,R7
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0x0038             MOVS     R0,R7
   \       0x10   0x2001             MOVS     R0,#+1
    340            uint32_t tmp = 0;
   \       0x12   0x0038             MOVS     R0,R7
    341            RCC_ClocksTypeDef RCC_Clocks;
    342            uint32_t sourceclock = 0;
   \       0x14   0x0038             MOVS     R0,R7
    343          
    344            /* Check the I2S parameters */
    345            assert_param(IS_SPI_1_PERIPH(SPIx));
    346            assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
    347            assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
    348            assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
    349            assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
    350            assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
    351            assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
    352          
    353          /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    354            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    355            SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask; 
   \       0x16   0x8BA8             LDRH     R0,[R5, #+28]
   \       0x18   0x....             LDR      R1,??DataTable14_5  ;; 0xf040
   \       0x1A   0x4001             ANDS     R1,R1,R0
   \       0x1C   0x83A9             STRH     R1,[R5, #+28]
    356            SPIx->I2SPR = 0x0002;
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0x8428             STRH     R0,[R5, #+32]
    357          
    358            /* Get the I2SCFGR register value */
    359            tmpreg = SPIx->I2SCFGR;
   \       0x22   0x8BA8             LDRH     R0,[R5, #+28]
   \       0x24   0x4669             MOV      R1,SP
   \       0x26   0x8008             STRH     R0,[R1, #+0]
    360          
    361            /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
    362            if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
   \       0x28   0x68A0             LDR      R0,[R4, #+8]
   \       0x2A   0x2802             CMP      R0,#+2
   \       0x2C   0xD102             BNE      ??I2S_Init_0
    363            {
    364              i2sodd = (uint16_t)0;
   \       0x2E   0x0039             MOVS     R1,R7
    365              i2sdiv = (uint16_t)2;   
   \       0x30   0x2002             MOVS     R0,#+2
   \       0x32   0xE02F             B        ??I2S_Init_1
    366            }
    367            /* If the requested audio frequency is not the default, compute the prescaler */
    368            else
    369            {
    370              /* Check the frame length (For the Prescaler computing) */
    371              if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
   \                     ??I2S_Init_0: (+1)
   \       0x34   0x88A0             LDRH     R0,[R4, #+4]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD101             BNE      ??I2S_Init_2
    372              {
    373                /* Packet length is 16 bits */
    374                packetlength = 1;
   \       0x3A   0x2601             MOVS     R6,#+1
   \       0x3C   0xE000             B        ??I2S_Init_3
    375              }
    376              else
    377              {
    378                /* Packet length is 32 bits */
    379                packetlength = 2;
   \                     ??I2S_Init_2: (+1)
   \       0x3E   0x2602             MOVS     R6,#+2
    380              }
    381          
    382              /* I2S Clock source is System clock: Get System Clock frequency */
    383              RCC_GetClocksFreq(&RCC_Clocks);      
   \                     ??I2S_Init_3: (+1)
   \       0x40   0xA801             ADD      R0,SP,#+4
   \       0x42   0x....'....        BL       RCC_GetClocksFreq
    384          
    385              /* Get the source clock value: based on System Clock value */
    386              sourceclock = RCC_Clocks.SYSCLK_Frequency;    
   \       0x46   0x9801             LDR      R0,[SP, #+4]
    387          
    388              /* Compute the Real divider depending on the MCLK output state with a floating point */
    389              if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
   \       0x48   0x88E1             LDRH     R1,[R4, #+6]
   \       0x4A   0x2280             MOVS     R2,#+128
   \       0x4C   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \       0x4E   0x4291             CMP      R1,R2
   \       0x50   0xD108             BNE      ??I2S_Init_4
    390              {
    391                /* MCLK output is enabled */
    392                tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
   \       0x52   0x0A00             LSRS     R0,R0,#+8
   \       0x54   0x210A             MOVS     R1,#+10
   \       0x56   0x4348             MULS     R0,R1,R0
   \       0x58   0x68A1             LDR      R1,[R4, #+8]
   \       0x5A   0x....'....        BL       __aeabi_uidiv
   \       0x5E   0x1D40             ADDS     R0,R0,#+5
   \       0x60   0xB280             UXTH     R0,R0
   \       0x62   0xE00B             B        ??I2S_Init_5
    393              }
    394              else
    395              {
    396                /* MCLK output is disabled */
    397                tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
   \                     ??I2S_Init_4: (+1)
   \       0x64   0xB2B6             UXTH     R6,R6
   \       0x66   0x2120             MOVS     R1,#+32
   \       0x68   0x4371             MULS     R1,R6,R1
   \       0x6A   0x....'....        BL       __aeabi_uidiv
   \       0x6E   0x210A             MOVS     R1,#+10
   \       0x70   0x4348             MULS     R0,R1,R0
   \       0x72   0x68A1             LDR      R1,[R4, #+8]
   \       0x74   0x....'....        BL       __aeabi_uidiv
   \       0x78   0x1D40             ADDS     R0,R0,#+5
   \       0x7A   0xB280             UXTH     R0,R0
    398              }
    399              
    400              /* Remove the floating point */
    401              tmp = tmp / 10;
   \                     ??I2S_Init_5: (+1)
   \       0x7C   0x210A             MOVS     R1,#+10
   \       0x7E   0x....'....        BL       __aeabi_uidiv
    402          
    403              /* Check the parity of the divider */
    404              i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
   \       0x82   0x0002             MOVS     R2,R0
   \       0x84   0x0011             MOVS     R1,R2
   \       0x86   0x07C9             LSLS     R1,R1,#+31       ;; ZeroExtS R1,R1,#+31,#+31
   \       0x88   0x0FC9             LSRS     R1,R1,#+31
    405          
    406              /* Compute the i2sdiv prescaler */
    407              i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
   \       0x8A   0x000A             MOVS     R2,R1
   \       0x8C   0xB292             UXTH     R2,R2
   \       0x8E   0x1A80             SUBS     R0,R0,R2
   \       0x90   0x0840             LSRS     R0,R0,#+1
    408          
    409              /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    410              i2sodd = (uint16_t) (i2sodd << 8);
   \       0x92   0x0209             LSLS     R1,R1,#+8
    411            }
    412          
    413            /* Test if the divider is 1 or 0 or greater than 0xFF */
    414            if ((i2sdiv < 2) || (i2sdiv > 0xFF))
   \                     ??I2S_Init_1: (+1)
   \       0x94   0x0002             MOVS     R2,R0
   \       0x96   0xB292             UXTH     R2,R2
   \       0x98   0x1E92             SUBS     R2,R2,#+2
   \       0x9A   0x2AFE             CMP      R2,#+254
   \       0x9C   0xD301             BCC      ??I2S_Init_6
    415            {
    416              /* Set the default values */
    417              i2sdiv = 2;
   \       0x9E   0x2002             MOVS     R0,#+2
    418              i2sodd = 0;
   \       0xA0   0x0039             MOVS     R1,R7
    419            }
    420          
    421            /* Write to SPIx I2SPR register the computed value */
    422            SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
   \                     ??I2S_Init_6: (+1)
   \       0xA2   0x88E2             LDRH     R2,[R4, #+6]
   \       0xA4   0x430A             ORRS     R2,R2,R1
   \       0xA6   0x4302             ORRS     R2,R2,R0
   \       0xA8   0x842A             STRH     R2,[R5, #+32]
    423          
    424            /* Configure the I2S with the SPI_InitStruct values */
    425            tmpreg |= (uint16_t)(SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
    426                            (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
    427                            (uint16_t)I2S_InitStruct->I2S_CPOL))));
   \       0xAA   0x4668             MOV      R0,SP
   \       0xAC   0x8801             LDRH     R1,[R0, #+0]
   \       0xAE   0x8820             LDRH     R0,[R4, #+0]
   \       0xB0   0x8862             LDRH     R2,[R4, #+2]
   \       0xB2   0x88A3             LDRH     R3,[R4, #+4]
   \       0xB4   0x89A4             LDRH     R4,[R4, #+12]
   \       0xB6   0x431C             ORRS     R4,R4,R3
   \       0xB8   0x4314             ORRS     R4,R4,R2
   \       0xBA   0x4304             ORRS     R4,R4,R0
   \       0xBC   0x2080             MOVS     R0,#+128
   \       0xBE   0x0100             LSLS     R0,R0,#+4        ;; #+2048
   \       0xC0   0x4320             ORRS     R0,R0,R4
   \       0xC2   0x4308             ORRS     R0,R0,R1
    428          
    429            /* Write to SPIx I2SCFGR */
    430            SPIx->I2SCFGR = tmpreg;
   \       0xC4   0x83A8             STRH     R0,[R5, #+28]
    431          }
   \       0xC6   0xB00B             ADD      SP,SP,#+44
   \       0xC8   0xBDF0             POP      {R4-R7,PC}       ;; return
    432          
    433          /**
    434            * @brief  Enables or disables the specified SPI peripheral.
    435            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    436            * @note   SPI2 is not available for STM32F031 devices.
    437            * @param  NewState: new state of the SPIx peripheral. 
    438            *          This parameter can be: ENABLE or DISABLE.
    439            * @retval None
    440            */

   \                                 In section .text, align 2, keep-with-next
    441          void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    442          {
   \                     SPI_Cmd: (+1)
   \        0x0   0xB500             PUSH     {LR}
    443            /* Check the parameters */
    444            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    445            assert_param(IS_FUNCTIONAL_STATE(NewState));
    446          
    447            if (NewState != DISABLE)
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD004             BEQ      ??SPI_Cmd_0
    448            {
    449              /* Enable the selected SPI peripheral */
    450              SPIx->CR1 |= SPI_CR1_SPE;
   \        0x8   0x8801             LDRH     R1,[R0, #+0]
   \        0xA   0x2240             MOVS     R2,#+64
   \        0xC   0x430A             ORRS     R2,R2,R1
   \        0xE   0x8002             STRH     R2,[R0, #+0]
   \       0x10   0xE003             B        ??SPI_Cmd_1
    451            }
    452            else
    453            {
    454              /* Disable the selected SPI peripheral */
    455              SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
   \                     ??SPI_Cmd_0: (+1)
   \       0x12   0x8801             LDRH     R1,[R0, #+0]
   \       0x14   0x....             LDR      R2,??DataTable14_6  ;; 0xffbf
   \       0x16   0x400A             ANDS     R2,R2,R1
   \       0x18   0x8002             STRH     R2,[R0, #+0]
    456            }
    457          }
   \                     ??SPI_Cmd_1: (+1)
   \       0x1A   0xBD00             POP      {PC}             ;; return
    458          
    459          /**
    460            * @brief  Enables or disables the TI Mode.
    461            *   
    462            * @note   This function can be called only after the SPI_Init() function has 
    463            *         been called. 
    464            * @note   When TI mode is selected, the control bits SSM, SSI, CPOL and CPHA 
    465            *         are not taken into consideration and are configured by hardware 
    466            *         respectively to the TI mode requirements.
    467            *    
    468            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    469            * @note   SPI2 is not available for STM32F031 devices.
    470            * @param  NewState: new state of the selected SPI TI communication mode.
    471            *          This parameter can be: ENABLE or DISABLE.
    472            * @retval None
    473            */

   \                                 In section .text, align 2, keep-with-next
    474          void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    475          {
   \                     SPI_TIModeCmd: (+1)
   \        0x0   0xB500             PUSH     {LR}
    476            /* Check the parameters */
    477            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    478            assert_param(IS_FUNCTIONAL_STATE(NewState));
    479          
    480            if (NewState != DISABLE)
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD004             BEQ      ??SPI_TIModeCmd_0
    481            {
    482              /* Enable the TI mode for the selected SPI peripheral */
    483              SPIx->CR2 |= SPI_CR2_FRF;
   \        0x8   0x8881             LDRH     R1,[R0, #+4]
   \        0xA   0x2210             MOVS     R2,#+16
   \        0xC   0x430A             ORRS     R2,R2,R1
   \        0xE   0x8082             STRH     R2,[R0, #+4]
   \       0x10   0xE003             B        ??SPI_TIModeCmd_1
    484            }
    485            else
    486            {
    487              /* Disable the TI mode for the selected SPI peripheral */
    488              SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_FRF);
   \                     ??SPI_TIModeCmd_0: (+1)
   \       0x12   0x8881             LDRH     R1,[R0, #+4]
   \       0x14   0x....             LDR      R2,??DataTable14_7  ;; 0xffef
   \       0x16   0x400A             ANDS     R2,R2,R1
   \       0x18   0x8082             STRH     R2,[R0, #+4]
    489            }
    490          }
   \                     ??SPI_TIModeCmd_1: (+1)
   \       0x1A   0xBD00             POP      {PC}             ;; return
    491          
    492          /**
    493            * @brief  Enables or disables the specified SPI peripheral (in I2S mode).
    494            * @note   This mode is not supported for STM32F030 devices.    
    495            * @param  SPIx: where x can be 1 to select the SPI peripheral.
    496            * @param  NewState: new state of the SPIx peripheral. 
    497            *          This parameter can be: ENABLE or DISABLE.
    498            * @retval None
    499            */

   \                                 In section .text, align 2, keep-with-next
    500          void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    501          {
   \                     I2S_Cmd: (+1)
   \        0x0   0xB500             PUSH     {LR}
    502            /* Check the parameters */
    503            assert_param(IS_SPI_1_PERIPH(SPIx));
    504            assert_param(IS_FUNCTIONAL_STATE(NewState));
    505            if (NewState != DISABLE)
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD005             BEQ      ??I2S_Cmd_0
    506            {
    507              /* Enable the selected SPI peripheral in I2S mode */
    508              SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
   \        0x8   0x8B81             LDRH     R1,[R0, #+28]
   \        0xA   0x2280             MOVS     R2,#+128
   \        0xC   0x00D2             LSLS     R2,R2,#+3        ;; #+1024
   \        0xE   0x430A             ORRS     R2,R2,R1
   \       0x10   0x8382             STRH     R2,[R0, #+28]
   \       0x12   0xE003             B        ??I2S_Cmd_1
    509            }
    510            else
    511            {
    512              /* Disable the selected SPI peripheral in I2S mode */
    513              SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
   \                     ??I2S_Cmd_0: (+1)
   \       0x14   0x8B81             LDRH     R1,[R0, #+28]
   \       0x16   0x....             LDR      R2,??DataTable14_8  ;; 0xfbff
   \       0x18   0x400A             ANDS     R2,R2,R1
   \       0x1A   0x8382             STRH     R2,[R0, #+28]
    514            }
    515          }
   \                     ??I2S_Cmd_1: (+1)
   \       0x1C   0xBD00             POP      {PC}             ;; return
    516          
    517          /**
    518            * @brief  Configures the data size for the selected SPI.
    519            * @param  SPIx: where x can be 1 or 2  to select the SPI peripheral.
    520            * @note   SPI2 is not available for STM32F031 devices. 
    521            * @param  SPI_DataSize: specifies the SPI data size.
    522            *         For the SPIx peripheral this parameter can be one of the following values:
    523            *            @arg SPI_DataSize_4b: Set data size to 4 bits
    524            *            @arg SPI_DataSize_5b: Set data size to 5 bits
    525            *            @arg SPI_DataSize_6b: Set data size to 6 bits
    526            *            @arg SPI_DataSize_7b: Set data size to 7 bits
    527            *            @arg SPI_DataSize_8b: Set data size to 8 bits
    528            *            @arg SPI_DataSize_9b: Set data size to 9 bits
    529            *            @arg SPI_DataSize_10b: Set data size to 10 bits
    530            *            @arg SPI_DataSize_11b: Set data size to 11 bits
    531            *            @arg SPI_DataSize_12b: Set data size to 12 bits
    532            *            @arg SPI_DataSize_13b: Set data size to 13 bits
    533            *            @arg SPI_DataSize_14b: Set data size to 14 bits
    534            *            @arg SPI_DataSize_15b: Set data size to 15 bits
    535            *            @arg SPI_DataSize_16b: Set data size to 16 bits
    536            * @retval None
    537            */

   \                                 In section .text, align 2, keep-with-next
    538          void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
    539          {
    540            uint16_t tmpreg = 0;
   \                     SPI_DataSizeConfig: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
    541            
    542            /* Check the parameters */
    543            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    544            assert_param(IS_SPI_DATA_SIZE(SPI_DataSize));
    545            /* Read the CR2 register */
    546            tmpreg = SPIx->CR2;
   \        0x2   0x8882             LDRH     R2,[R0, #+4]
    547            /* Clear DS[3:0] bits */
    548            tmpreg &= (uint16_t)~SPI_CR2_DS;
   \        0x4   0x....             LDR      R3,??DataTable14_2  ;; 0xf0ff
   \        0x6   0x4013             ANDS     R3,R3,R2
    549            /* Set new DS[3:0] bits value */
    550            tmpreg |= SPI_DataSize;
   \        0x8   0x4319             ORRS     R1,R1,R3
    551            SPIx->CR2 = tmpreg;
   \        0xA   0x8081             STRH     R1,[R0, #+4]
    552          }
   \        0xC   0x4770             BX       LR               ;; return
    553          
    554          /**
    555            * @brief  Configures the FIFO reception threshold for the selected SPI.
    556            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    557            * @note   SPI2 is not available for STM32F031 devices. 
    558            * @param  SPI_RxFIFOThreshold: specifies the FIFO reception threshold.
    559            *          This parameter can be one of the following values:
    560            *            @arg SPI_RxFIFOThreshold_HF: RXNE event is generated if the FIFO 
    561            *                                         level is greater or equal to 1/2. 
    562            *            @arg SPI_RxFIFOThreshold_QF: RXNE event is generated if the FIFO 
    563            *                                         level is greater or equal to 1/4. 
    564            * @retval None
    565            */

   \                                 In section .text, align 2, keep-with-next
    566          void SPI_RxFIFOThresholdConfig(SPI_TypeDef* SPIx, uint16_t SPI_RxFIFOThreshold)
    567          {
    568            /* Check the parameters */
    569            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    570            assert_param(IS_SPI_RX_FIFO_THRESHOLD(SPI_RxFIFOThreshold));
    571          
    572            /* Clear FRXTH bit */
    573            SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_FRXTH);
   \                     SPI_RxFIFOThresholdConfig: (+1)
   \        0x0   0x8882             LDRH     R2,[R0, #+4]
   \        0x2   0x....             LDR      R3,??DataTable14_9  ;; 0xefff
   \        0x4   0x4013             ANDS     R3,R3,R2
   \        0x6   0x8083             STRH     R3,[R0, #+4]
    574          
    575            /* Set new FRXTH bit value */
    576            SPIx->CR2 |= SPI_RxFIFOThreshold;
   \        0x8   0x8882             LDRH     R2,[R0, #+4]
   \        0xA   0x4311             ORRS     R1,R1,R2
   \        0xC   0x8081             STRH     R1,[R0, #+4]
    577          }
   \        0xE   0x4770             BX       LR               ;; return
    578          
    579          /**
    580            * @brief  Selects the data transfer direction in bidirectional mode for the specified SPI.
    581            * @param  SPIx: where x can be 1 or 2  to select the SPI peripheral.
    582            * @note   SPI2 is not available for STM32F031 devices. 
    583            * @param  SPI_Direction: specifies the data transfer direction in bidirectional mode. 
    584            *          This parameter can be one of the following values:
    585            *            @arg SPI_Direction_Tx: Selects Tx transmission direction
    586            *            @arg SPI_Direction_Rx: Selects Rx receive direction
    587            * @retval None
    588            */

   \                                 In section .text, align 2, keep-with-next
    589          void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
    590          {
   \                     SPI_BiDirectionalLineConfig: (+1)
   \        0x0   0xB500             PUSH     {LR}
    591            /* Check the parameters */
    592            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    593            assert_param(IS_SPI_DIRECTION(SPI_Direction));
    594            if (SPI_Direction == SPI_Direction_Tx)
   \        0x2   0x2280             MOVS     R2,#+128
   \        0x4   0x01D2             LSLS     R2,R2,#+7        ;; #+16384
   \        0x6   0x0013             MOVS     R3,R2
   \        0x8   0xB289             UXTH     R1,R1
   \        0xA   0x4299             CMP      R1,R3
   \        0xC   0xD103             BNE      ??SPI_BiDirectionalLineConfig_0
    595            {
    596              /* Set the Tx only mode */
    597              SPIx->CR1 |= SPI_Direction_Tx;
   \        0xE   0x8801             LDRH     R1,[R0, #+0]
   \       0x10   0x430A             ORRS     R2,R2,R1
   \       0x12   0x8002             STRH     R2,[R0, #+0]
   \       0x14   0xE003             B        ??SPI_BiDirectionalLineConfig_1
    598            }
    599            else
    600            {
    601              /* Set the Rx only mode */
    602              SPIx->CR1 &= SPI_Direction_Rx;
   \                     ??SPI_BiDirectionalLineConfig_0: (+1)
   \       0x16   0x8801             LDRH     R1,[R0, #+0]
   \       0x18   0x....             LDR      R2,??DataTable14_10  ;; 0xbfff
   \       0x1A   0x400A             ANDS     R2,R2,R1
   \       0x1C   0x8002             STRH     R2,[R0, #+0]
    603            }
    604          }
   \                     ??SPI_BiDirectionalLineConfig_1: (+1)
   \       0x1E   0xBD00             POP      {PC}             ;; return
    605          
    606          /**
    607            * @brief  Configures internally by software the NSS pin for the selected SPI.
    608            * @note   This function can be called only after the SPI_Init() function has 
    609            *         been called.  
    610            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    611            * @note   SPI2 is not available for STM32F031 devices.  
    612            * @param  SPI_NSSInternalSoft: specifies the SPI NSS internal state.
    613            *          This parameter can be one of the following values:
    614            *            @arg SPI_NSSInternalSoft_Set: Set NSS pin internally
    615            *            @arg SPI_NSSInternalSoft_Reset: Reset NSS pin internally
    616            * @retval None
    617            */

   \                                 In section .text, align 2, keep-with-next
    618          void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
    619          {
   \                     SPI_NSSInternalSoftwareConfig: (+1)
   \        0x0   0xB500             PUSH     {LR}
    620            /* Check the parameters */
    621            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    622            assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
    623          
    624            if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
   \        0x2   0x....             LDR      R2,??DataTable14_11  ;; 0xfeff
   \        0x4   0xB289             UXTH     R1,R1
   \        0x6   0x4291             CMP      R1,R2
   \        0x8   0xD005             BEQ      ??SPI_NSSInternalSoftwareConfig_0
    625            {
    626              /* Set NSS pin internally by software */
    627              SPIx->CR1 |= SPI_NSSInternalSoft_Set;
   \        0xA   0x8801             LDRH     R1,[R0, #+0]
   \        0xC   0x2280             MOVS     R2,#+128
   \        0xE   0x0052             LSLS     R2,R2,#+1        ;; #+256
   \       0x10   0x430A             ORRS     R2,R2,R1
   \       0x12   0x8002             STRH     R2,[R0, #+0]
   \       0x14   0xE002             B        ??SPI_NSSInternalSoftwareConfig_1
    628            }
    629            else
    630            {
    631              /* Reset NSS pin internally by software */
    632              SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
   \                     ??SPI_NSSInternalSoftwareConfig_0: (+1)
   \       0x16   0x8801             LDRH     R1,[R0, #+0]
   \       0x18   0x400A             ANDS     R2,R2,R1
   \       0x1A   0x8002             STRH     R2,[R0, #+0]
    633            }
    634          }
   \                     ??SPI_NSSInternalSoftwareConfig_1: (+1)
   \       0x1C   0xBD00             POP      {PC}             ;; return
    635          
    636          /**
    637            * @brief  Enables or disables the SS output for the selected SPI.
    638            * @note   This function can be called only after the SPI_Init() function has 
    639            *         been called and the NSS hardware management mode is selected. 
    640            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    641            * @note   SPI2 is not available for STM32F031 devices.  
    642            * @param  NewState: new state of the SPIx SS output. 
    643            *          This parameter can be: ENABLE or DISABLE.
    644            * @retval None
    645            */

   \                                 In section .text, align 2, keep-with-next
    646          void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    647          {
   \                     SPI_SSOutputCmd: (+1)
   \        0x0   0xB500             PUSH     {LR}
    648            /* Check the parameters */
    649            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    650            assert_param(IS_FUNCTIONAL_STATE(NewState));
    651            if (NewState != DISABLE)
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD004             BEQ      ??SPI_SSOutputCmd_0
    652            {
    653              /* Enable the selected SPI SS output */
    654              SPIx->CR2 |= SPI_CR2_SSOE;
   \        0x8   0x8881             LDRH     R1,[R0, #+4]
   \        0xA   0x2204             MOVS     R2,#+4
   \        0xC   0x430A             ORRS     R2,R2,R1
   \        0xE   0x8082             STRH     R2,[R0, #+4]
   \       0x10   0xE003             B        ??SPI_SSOutputCmd_1
    655            }
    656            else
    657            {
    658              /* Disable the selected SPI SS output */
    659              SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
   \                     ??SPI_SSOutputCmd_0: (+1)
   \       0x12   0x8881             LDRH     R1,[R0, #+4]
   \       0x14   0x....             LDR      R2,??DataTable14_3  ;; 0xfffb
   \       0x16   0x400A             ANDS     R2,R2,R1
   \       0x18   0x8082             STRH     R2,[R0, #+4]
    660            }
    661          }
   \                     ??SPI_SSOutputCmd_1: (+1)
   \       0x1A   0xBD00             POP      {PC}             ;; return
    662          
    663          /**
    664            * @brief  Enables or disables the NSS pulse management mode.
    665            * @note   This function can be called only after the SPI_Init() function has 
    666            *         been called. 
    667            * @note   When TI mode is selected, the control bits NSSP is not taken into 
    668            *         consideration and are configured by hardware respectively to the 
    669            *         TI mode requirements. 
    670            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    671            * @note   SPI2 is not available for STM32F031 devices.
    672            * @param  NewState: new state of the NSS pulse management mode.
    673            *          This parameter can be: ENABLE or DISABLE.
    674            * @retval None
    675            */

   \                                 In section .text, align 2, keep-with-next
    676          void SPI_NSSPulseModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    677          {
   \                     SPI_NSSPulseModeCmd: (+1)
   \        0x0   0xB500             PUSH     {LR}
    678            /* Check the parameters */
    679            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    680            assert_param(IS_FUNCTIONAL_STATE(NewState));
    681          
    682            if (NewState != DISABLE)
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD004             BEQ      ??SPI_NSSPulseModeCmd_0
    683            {
    684              /* Enable the NSS pulse management mode */
    685              SPIx->CR2 |= SPI_CR2_NSSP;
   \        0x8   0x8881             LDRH     R1,[R0, #+4]
   \        0xA   0x2208             MOVS     R2,#+8
   \        0xC   0x430A             ORRS     R2,R2,R1
   \        0xE   0x8082             STRH     R2,[R0, #+4]
   \       0x10   0xE003             B        ??SPI_NSSPulseModeCmd_1
    686            }
    687            else
    688            {
    689              /* Disable the NSS pulse management mode */
    690              SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_NSSP);    
   \                     ??SPI_NSSPulseModeCmd_0: (+1)
   \       0x12   0x8881             LDRH     R1,[R0, #+4]
   \       0x14   0x....             LDR      R2,??DataTable14_12  ;; 0xfff7
   \       0x16   0x400A             ANDS     R2,R2,R1
   \       0x18   0x8082             STRH     R2,[R0, #+4]
    691            }
    692          }
   \                     ??SPI_NSSPulseModeCmd_1: (+1)
   \       0x1A   0xBD00             POP      {PC}             ;; return
    693          
    694          /**
    695            * @}
    696            */
    697          
    698          /** @defgroup SPI_Group2 Data transfers functions
    699           *  @brief   Data transfers functions
    700           *
    701          @verbatim
    702           ===============================================================================
    703                              ##### Data transfers functions #####
    704           ===============================================================================
    705              [..] This section provides a set of functions allowing to manage the SPI or I2S
    706                   data transfers.
    707          
    708              [..] In reception, data are received and then stored into an internal Rx buffer while 
    709                   In transmission, data are first stored into an internal Tx buffer before being 
    710                   transmitted.
    711          
    712              [..] The read access of the SPI_DR register can be done using 
    713                   SPI_ReceiveData8() (when data size is equal or inferior than 8bits) and.
    714                   SPI_I2S_ReceiveData16() (when data size is superior than 8bits)function
    715                   and returns the Rx buffered value. Whereas a write access to the SPI_DR 
    716                   can be done using SPI_SendData8() (when data size is equal or inferior than 8bits)
    717                   and SPI_I2S_SendData16() (when data size is superior than 8bits) function 
    718                   and stores the written data into Tx buffer.
    719          
    720          @endverbatim
    721            * @{
    722            */
    723          
    724          /**
    725            * @brief  Transmits a Data through the SPIx/I2Sx peripheral.
    726            * @param  SPIx: where x can be 1 or 2 in SPI mode to select the SPI peripheral.
    727            * @note   SPI2 is not available for STM32F031 devices.
    728            * @param  Data: Data to be transmitted.
    729            * @retval None
    730            */

   \                                 In section .text, align 2, keep-with-next
    731          void SPI_SendData8(SPI_TypeDef* SPIx, uint8_t Data)
    732          {
    733            uint32_t spixbase = 0x00;
   \                     SPI_SendData8: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
    734          
    735            /* Check the parameters */
    736            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    737          
    738            spixbase = (uint32_t)SPIx; 
    739            spixbase += 0x0C;
   \        0x2   0x300C             ADDS     R0,R0,#+12
    740            
    741            *(__IO uint8_t *) spixbase = Data;
   \        0x4   0x7001             STRB     R1,[R0, #+0]
    742          }
   \        0x6   0x4770             BX       LR               ;; return
    743          
    744          /**
    745            * @brief  Transmits a Data through the SPIx/I2Sx peripheral.
    746            * @param  SPIx: where x can be 1 or 2 in SPI mode or 1 in I2S mode to select 
    747            *         the SPI peripheral. 
    748            * @note   SPI2 is not available for STM32F031 devices. 
    749            * @param  Data: Data to be transmitted.
    750            * @retval None
    751            */

   \                                 In section .text, align 2, keep-with-next
    752          void SPI_I2S_SendData16(SPI_TypeDef* SPIx, uint16_t Data)
    753          {
    754            /* Check the parameters */
    755            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    756            
    757            SPIx->DR = (uint16_t)Data;
   \                     SPI_I2S_SendData16: (+1)
   \        0x0   0x8181             STRH     R1,[R0, #+12]
    758          }
   \        0x2   0x4770             BX       LR               ;; return
    759          
    760          /**
    761            * @brief  Returns the most recent received data by the SPIx/I2Sx peripheral. 
    762            * @param  SPIx: where x can be 1 or 2 in SPI mode to select the SPI peripheral. 
    763            * @note   SPI2 is not available for STM32F031 devices.
    764            * @retval The value of the received data.
    765            */

   \                                 In section .text, align 2, keep-with-next
    766          uint8_t SPI_ReceiveData8(SPI_TypeDef* SPIx)
    767          {
    768            uint32_t spixbase = 0x00;
   \                     SPI_ReceiveData8: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
    769            
    770            spixbase = (uint32_t)SPIx; 
    771            spixbase += 0x0C;
   \        0x2   0x300C             ADDS     R0,R0,#+12
    772            
    773            return *(__IO uint8_t *) spixbase;
   \        0x4   0x7800             LDRB     R0,[R0, #+0]
   \        0x6   0x4770             BX       LR               ;; return
    774          }
    775          
    776          /**
    777            * @brief  Returns the most recent received data by the SPIx peripheral. 
    778            * @param  SPIx: where x can be 1 or 2 in SPI mode or 1 in I2S mode to select
    779            * @note   SPI2 is not available for STM32F031 devices.
    780            *         the SPI peripheral.  
    781            * @retval The value of the received data.
    782            */

   \                                 In section .text, align 2, keep-with-next
    783          uint16_t SPI_I2S_ReceiveData16(SPI_TypeDef* SPIx)
    784          {
    785            return SPIx->DR;
   \                     SPI_I2S_ReceiveData16: (+1)
   \        0x0   0x8980             LDRH     R0,[R0, #+12]
   \        0x2   0x4770             BX       LR               ;; return
    786          }
    787          /**
    788            * @}
    789            */
    790          
    791          /** @defgroup SPI_Group3 Hardware CRC Calculation functions
    792           *  @brief   Hardware CRC Calculation functions
    793           *
    794          @verbatim   
    795           ===============================================================================
    796                          ##### Hardware CRC Calculation functions #####
    797           ===============================================================================
    798              [..] This section provides a set of functions allowing to manage the SPI CRC hardware 
    799                   calculation.SPI communication using CRC is possible through the following procedure:
    800          
    801                   (#) Program the Data direction, Polarity, Phase, First Data, Baud Rate Prescaler,
    802                       Slave Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
    803                       function.
    804                   (#) Enable the CRC calculation using the SPI_CalculateCRC() function.
    805                   (#) Enable the SPI using the SPI_Cmd() function
    806                   (#) Before writing the last data to the TX buffer, set the CRCNext bit using the 
    807                       SPI_TransmitCRC() function to indicate that after transmission of the last 
    808                       data, the CRC should be transmitted.
    809                   (#) After transmitting the last data, the SPI transmits the CRC. The SPI_CR1_CRCNEXT
    810                       bit is reset. The CRC is also received and compared against the SPI_RXCRCR 
    811                       value. 
    812                       If the value does not match, the SPI_FLAG_CRCERR flag is set and an interrupt
    813                       can be generated when the SPI_I2S_IT_ERR interrupt is enabled.
    814          
    815              -@-
    816                 (+@) It is advised to don't read the calculate CRC values during the communication.
    817                 (+@) When the SPI is in slave mode, be careful to enable CRC calculation only
    818                 when the clock is stable, that is, when the clock is in the steady state. 
    819                 If not, a wrong CRC calculation may be done. In fact, the CRC is sensitive 
    820                 to the SCK slave input clock as soon as CRCEN is set, and this, whatever 
    821                 the value of the SPE bit.
    822                 (+@) With high bitrate frequencies, be careful when transmitting the CRC.
    823                 As the number of used CPU cycles has to be as low as possible in the CRC 
    824                 transfer phase, it is forbidden to call software functions in the CRC 
    825                 transmission sequence to avoid errors in the last data and CRC reception. 
    826                 In fact, CRCNEXT bit has to be written before the end of the transmission/reception 
    827                 of the last data.
    828                 (+@) For high bit rate frequencies, it is advised to use the DMA mode to avoid the
    829                 degradation of the SPI speed performance due to CPU accesses impacting the 
    830                 SPI bandwidth.
    831                 (+@) When the STM32F0xx are configured as slaves and the NSS hardware mode is 
    832                 used, the NSS pin needs to be kept low between the data phase and the CRC 
    833                 phase.
    834                 (+@) When the SPI is configured in slave mode with the CRC feature enabled, CRC
    835                 calculation takes place even if a high level is applied on the NSS pin. 
    836                 This may happen for example in case of a multislave environment where the 
    837                 communication master addresses slaves alternately.
    838                 (+@) Between a slave deselection (high level on NSS) and a new slave selection
    839                 (low level on NSS), the CRC value should be cleared on both master and slave
    840                 sides in order to resynchronize the master and slave for their respective 
    841                 CRC calculation.
    842          
    843              -@- To clear the CRC, follow the procedure below:
    844                 (#@) Disable SPI using the SPI_Cmd() function
    845                 (#@) Disable the CRC calculation using the SPI_CalculateCRC() function.
    846                 (#@) Enable the CRC calculation using the SPI_CalculateCRC() function.
    847                 (#@) Enable SPI using the SPI_Cmd() function.
    848          
    849          @endverbatim
    850            * @{
    851            */
    852          
    853          /**
    854            * @brief  Configures the CRC calculation length for the selected SPI.
    855            * @note   This function can be called only after the SPI_Init() function has 
    856            *         been called.  
    857            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    858            * @note   SPI2 is not available for STM32F031 devices.  
    859            * @param  SPI_CRCLength: specifies the SPI CRC calculation length.
    860            *          This parameter can be one of the following values:
    861            *            @arg SPI_CRCLength_8b: Set CRC Calculation to 8 bits
    862            *            @arg SPI_CRCLength_16b: Set CRC Calculation to 16 bits
    863            * @retval None
    864            */

   \                                 In section .text, align 2, keep-with-next
    865          void SPI_CRCLengthConfig(SPI_TypeDef* SPIx, uint16_t SPI_CRCLength)
    866          {
    867            /* Check the parameters */
    868            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    869            assert_param(IS_SPI_CRC_LENGTH(SPI_CRCLength));
    870          
    871            /* Clear CRCL bit */
    872            SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCL);
   \                     SPI_CRCLengthConfig: (+1)
   \        0x0   0x8802             LDRH     R2,[R0, #+0]
   \        0x2   0x....             LDR      R3,??DataTable14_4  ;; 0xf7ff
   \        0x4   0x4013             ANDS     R3,R3,R2
   \        0x6   0x8003             STRH     R3,[R0, #+0]
    873          
    874            /* Set new CRCL bit value */
    875            SPIx->CR1 |= SPI_CRCLength;
   \        0x8   0x8802             LDRH     R2,[R0, #+0]
   \        0xA   0x4311             ORRS     R1,R1,R2
   \        0xC   0x8001             STRH     R1,[R0, #+0]
    876          }
   \        0xE   0x4770             BX       LR               ;; return
    877          
    878          /**
    879            * @brief  Enables or disables the CRC value calculation of the transferred bytes.
    880            * @note   This function can be called only after the SPI_Init() function has 
    881            *         been called.   
    882            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    883            * @note   SPI2 is not available for STM32F031 devices.
    884            * @param  NewState: new state of the SPIx CRC value calculation.
    885            *          This parameter can be: ENABLE or DISABLE.
    886            * @retval None
    887            */

   \                                 In section .text, align 2, keep-with-next
    888          void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
    889          {
   \                     SPI_CalculateCRC: (+1)
   \        0x0   0xB500             PUSH     {LR}
    890            /* Check the parameters */
    891            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    892            assert_param(IS_FUNCTIONAL_STATE(NewState));
    893          
    894            if (NewState != DISABLE)
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD005             BEQ      ??SPI_CalculateCRC_0
    895            {
    896              /* Enable the selected SPI CRC calculation */
    897              SPIx->CR1 |= SPI_CR1_CRCEN;
   \        0x8   0x8801             LDRH     R1,[R0, #+0]
   \        0xA   0x2280             MOVS     R2,#+128
   \        0xC   0x0192             LSLS     R2,R2,#+6        ;; #+8192
   \        0xE   0x430A             ORRS     R2,R2,R1
   \       0x10   0x8002             STRH     R2,[R0, #+0]
   \       0x12   0xE003             B        ??SPI_CalculateCRC_1
    898            }
    899            else
    900            {
    901              /* Disable the selected SPI CRC calculation */
    902              SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
   \                     ??SPI_CalculateCRC_0: (+1)
   \       0x14   0x8801             LDRH     R1,[R0, #+0]
   \       0x16   0x....             LDR      R2,??DataTable14_13  ;; 0xdfff
   \       0x18   0x400A             ANDS     R2,R2,R1
   \       0x1A   0x8002             STRH     R2,[R0, #+0]
    903            }
    904          }
   \                     ??SPI_CalculateCRC_1: (+1)
   \       0x1C   0xBD00             POP      {PC}             ;; return
    905          
    906          /**
    907            * @brief  Transmit the SPIx CRC value.
    908            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    909            * @note   SPI2 is not available for STM32F031 devices. 
    910            * @retval None
    911            */

   \                                 In section .text, align 2, keep-with-next
    912          void SPI_TransmitCRC(SPI_TypeDef* SPIx)
    913          {
    914            /* Check the parameters */
    915            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    916          
    917            /* Enable the selected SPI CRC transmission */
    918            SPIx->CR1 |= SPI_CR1_CRCNEXT;
   \                     SPI_TransmitCRC: (+1)
   \        0x0   0x8801             LDRH     R1,[R0, #+0]
   \        0x2   0x2280             MOVS     R2,#+128
   \        0x4   0x0152             LSLS     R2,R2,#+5        ;; #+4096
   \        0x6   0x430A             ORRS     R2,R2,R1
   \        0x8   0x8002             STRH     R2,[R0, #+0]
    919          }
   \        0xA   0x4770             BX       LR               ;; return
    920          
    921          /**
    922            * @brief  Returns the transmit or the receive CRC register value for the specified SPI.
    923            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    924            * @note   SPI2 is not available for STM32F031 devices. 
    925            * @param  SPI_CRC: specifies the CRC register to be read.
    926            *          This parameter can be one of the following values:
    927            *            @arg SPI_CRC_Tx: Selects Tx CRC register
    928            *            @arg SPI_CRC_Rx: Selects Rx CRC register
    929            * @retval The selected CRC register value..
    930            */

   \                                 In section .text, align 2, keep-with-next
    931          uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
    932          {
   \                     SPI_GetCRC: (+1)
   \        0x0   0xB500             PUSH     {LR}
    933            uint16_t crcreg = 0;
   \        0x2   0x2200             MOVS     R2,#+0
    934            /* Check the parameters */
    935            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    936            assert_param(IS_SPI_CRC(SPI_CRC));
    937          
    938            if (SPI_CRC != SPI_CRC_Rx)
   \        0x4   0xB2C9             UXTB     R1,R1
   \        0x6   0x2901             CMP      R1,#+1
   \        0x8   0xD001             BEQ      ??SPI_GetCRC_0
    939            {
    940              /* Get the Tx CRC register */
    941              crcreg = SPIx->TXCRCR;
   \        0xA   0x8B00             LDRH     R0,[R0, #+24]
   \        0xC   0xE000             B        ??SPI_GetCRC_1
    942            }
    943            else
    944            {
    945              /* Get the Rx CRC register */
    946              crcreg = SPIx->RXCRCR;
   \                     ??SPI_GetCRC_0: (+1)
   \        0xE   0x8A80             LDRH     R0,[R0, #+20]
    947            }
    948            /* Return the selected CRC register */
    949            return crcreg;
   \                     ??SPI_GetCRC_1: (+1)
   \       0x10   0xB280             UXTH     R0,R0
   \       0x12   0xBD00             POP      {PC}             ;; return
    950          }
    951          
    952          /**
    953            * @brief  Returns the CRC Polynomial register value for the specified SPI.
    954            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    955            * @note   SPI2 is not available for STM32F031 devices. 
    956            * @retval The CRC Polynomial register value.
    957            */

   \                                 In section .text, align 2, keep-with-next
    958          uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
    959          {
    960            /* Check the parameters */
    961            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    962          
    963            /* Return the CRC polynomial register */
    964            return SPIx->CRCPR;
   \                     SPI_GetCRCPolynomial: (+1)
   \        0x0   0x8A00             LDRH     R0,[R0, #+16]
   \        0x2   0x4770             BX       LR               ;; return
    965          }
    966          
    967          /**
    968            * @}
    969            */
    970          
    971          /** @defgroup SPI_Group4 DMA transfers management functions
    972           *  @brief   DMA transfers management functions
    973            *
    974          @verbatim   
    975           ===============================================================================
    976                          ##### DMA transfers management functions #####
    977           ===============================================================================
    978              [..] This section provides two functions that can be used only in DMA mode.
    979          
    980          @endverbatim
    981            * @{
    982            */
    983          
    984          /**
    985            * @brief  Enables or disables the SPIx/I2Sx DMA interface.
    986            * @param  SPIx: where x can be 1 or 2 in SPI mode or 1 in I2S mode to select 
    987            *         the SPI peripheral.
    988            * @note   SPI2 is not available for STM32F031 devices.
    989            *         I2S mode is not supported for STM32F030 devices.  
    990            * @param  SPI_I2S_DMAReq: specifies the SPI DMA transfer request to be enabled or disabled. 
    991            *          This parameter can be any combination of the following values:
    992            *            @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
    993            *            @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
    994            * @param  NewState: new state of the selected SPI DMA transfer request.
    995            *          This parameter can be: ENABLE or DISABLE.
    996            * @retval None
    997            */

   \                                 In section .text, align 2, keep-with-next
    998          void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
    999          {
   \                     SPI_I2S_DMACmd: (+1)
   \        0x0   0xB500             PUSH     {LR}
   1000            /* Check the parameters */
   1001            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1002            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1003            assert_param(IS_SPI_I2S_DMA_REQ(SPI_I2S_DMAReq));
   1004          
   1005            if (NewState != DISABLE)
   \        0x2   0xB2D2             UXTB     R2,R2
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD003             BEQ      ??SPI_I2S_DMACmd_0
   1006            {
   1007              /* Enable the selected SPI DMA requests */
   1008              SPIx->CR2 |= SPI_I2S_DMAReq;
   \        0x8   0x8882             LDRH     R2,[R0, #+4]
   \        0xA   0x4311             ORRS     R1,R1,R2
   \        0xC   0x8081             STRH     R1,[R0, #+4]
   \        0xE   0xE002             B        ??SPI_I2S_DMACmd_1
   1009            }
   1010            else
   1011            {
   1012              /* Disable the selected SPI DMA requests */
   1013              SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
   \                     ??SPI_I2S_DMACmd_0: (+1)
   \       0x10   0x8882             LDRH     R2,[R0, #+4]
   \       0x12   0x438A             BICS     R2,R2,R1
   \       0x14   0x8082             STRH     R2,[R0, #+4]
   1014            }
   1015          }
   \                     ??SPI_I2S_DMACmd_1: (+1)
   \       0x16   0xBD00             POP      {PC}             ;; return
   1016          
   1017          /**
   1018            * @brief  Configures the number of data to transfer type(Even/Odd) for the DMA
   1019            *         last transfers and for the selected SPI.
   1020            * @note   This function have a meaning only if DMA mode is selected and if 
   1021            *         the packing mode is used (data length <= 8 and DMA transfer size halfword)  
   1022            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
   1023            * @note   SPI2 is not available for STM32F031 devices.
   1024            * @param  SPI_LastDMATransfer: specifies the SPI last DMA transfers state.
   1025            *          This parameter can be one of the following values:
   1026            *            @arg SPI_LastDMATransfer_TxEvenRxEven: Number of data for transmission Even
   1027            *                                                   and number of data for reception Even.
   1028            *            @arg SPI_LastDMATransfer_TxOddRxEven: Number of data for transmission Odd
   1029            *                                                  and number of data for reception Even.
   1030            *            @arg SPI_LastDMATransfer_TxEvenRxOdd: Number of data for transmission Even
   1031            *                                                  and number of data for reception Odd.
   1032            *            @arg SPI_LastDMATransfer_TxOddRxOdd: Number of data for transmission Odd
   1033            *                                                 and number of data for reception Odd.
   1034            * @retval None
   1035            */

   \                                 In section .text, align 2, keep-with-next
   1036          void SPI_LastDMATransferCmd(SPI_TypeDef* SPIx, uint16_t SPI_LastDMATransfer)
   1037          {
   1038            /* Check the parameters */
   1039            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1040            assert_param(IS_SPI_LAST_DMA_TRANSFER(SPI_LastDMATransfer));
   1041          
   1042            /* Clear LDMA_TX and LDMA_RX bits */
   1043            SPIx->CR2 &= CR2_LDMA_MASK;
   \                     SPI_LastDMATransferCmd: (+1)
   \        0x0   0x8882             LDRH     R2,[R0, #+4]
   \        0x2   0x....             LDR      R3,??DataTable14_14  ;; 0x9fff
   \        0x4   0x4013             ANDS     R3,R3,R2
   \        0x6   0x8083             STRH     R3,[R0, #+4]
   1044          
   1045            /* Set new LDMA_TX and LDMA_RX bits value */
   1046            SPIx->CR2 |= SPI_LastDMATransfer; 
   \        0x8   0x8882             LDRH     R2,[R0, #+4]
   \        0xA   0x4311             ORRS     R1,R1,R2
   \        0xC   0x8081             STRH     R1,[R0, #+4]
   1047          }
   \        0xE   0x4770             BX       LR               ;; return
   1048          
   1049          /**
   1050            * @}
   1051            */
   1052          
   1053          /** @defgroup SPI_Group5 Interrupts and flags management functions
   1054           *  @brief   Interrupts and flags management functions
   1055            *
   1056          @verbatim   
   1057           ===============================================================================
   1058                       ##### Interrupts and flags management functions #####
   1059           ===============================================================================
   1060              [..] This section provides a set of functions allowing to configure the SPI/I2S Interrupts 
   1061                   sources and check or clear the flags or pending bits status.
   1062                   The user should identify which mode will be used in his application to manage 
   1063                   the communication: Polling mode, Interrupt mode or DMA mode. 
   1064          
   1065            *** Polling Mode ***
   1066            ====================
   1067              [..] In Polling Mode, the SPI/I2S communication can be managed by 9 flags:
   1068                  (#) SPI_I2S_FLAG_TXE : to indicate the status of the transmit buffer register
   1069                  (#) SPI_I2S_FLAG_RXNE : to indicate the status of the receive buffer register
   1070                  (#) SPI_I2S_FLAG_BSY : to indicate the state of the communication layer of the SPI.
   1071                  (#) SPI_FLAG_CRCERR : to indicate if a CRC Calculation error occur              
   1072                  (#) SPI_FLAG_MODF : to indicate if a Mode Fault error occur
   1073                  (#) SPI_I2S_FLAG_OVR : to indicate if an Overrun error occur
   1074                  (#) SPI_I2S_FLAG_FRE: to indicate a Frame Format error occurs.
   1075                  (#) I2S_FLAG_UDR: to indicate an Underrun error occurs.
   1076                  (#) I2S_FLAG_CHSIDE: to indicate Channel Side.
   1077          
   1078              [..]
   1079                  (@)Do not use the BSY flag to handle each data transmission or reception. It is better 
   1080                     to use the TXE and RXNE flags instead.
   1081          
   1082              [..] In this Mode it is advised to use the following functions:
   1083                  (+) FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
   1084                  (+) void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
   1085          
   1086            *** Interrupt Mode ***
   1087            ======================
   1088              [..] In Interrupt Mode, the SPI/I2S communication can be managed by 3 interrupt sources
   1089                   and 5 pending bits: 
   1090              [..] Pending Bits:
   1091                  (#) SPI_I2S_IT_TXE : to indicate the status of the transmit buffer register
   1092                  (#) SPI_I2S_IT_RXNE : to indicate the status of the receive buffer register
   1093                  (#) SPI_I2S_IT_OVR : to indicate if an Overrun error occur
   1094                  (#) I2S_IT_UDR : to indicate an Underrun Error occurs.
   1095                  (#) SPI_I2S_FLAG_FRE : to indicate a Frame Format error occurs.
   1096          
   1097              [..] Interrupt Source:
   1098                  (#) SPI_I2S_IT_TXE: specifies the interrupt source for the Tx buffer empty 
   1099                      interrupt.  
   1100                  (#) SPI_I2S_IT_RXNE : specifies the interrupt source for the Rx buffer not 
   1101                      empty interrupt.
   1102                  (#) SPI_I2S_IT_ERR : specifies the interrupt source for the errors interrupt.
   1103          
   1104              [..] In this Mode it is advised to use the following functions:
   1105                   (+) void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
   1106                   (+) ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
   1107          
   1108            *** FIFO Status ***
   1109            ===================
   1110              [..] It is possible to monitor the FIFO status when a transfer is ongoing using the
   1111                   following function:
   1112                   (+) uint32_t SPI_GetFIFOStatus(uint8_t SPI_FIFO_Direction); 
   1113          
   1114            *** DMA Mode ***
   1115            ================
   1116              [..] In DMA Mode, the SPI communication can be managed by 2 DMA Channel 
   1117                   requests:
   1118                  (#) SPI_I2S_DMAReq_Tx: specifies the Tx buffer DMA transfer request.
   1119                  (#) SPI_I2S_DMAReq_Rx: specifies the Rx buffer DMA transfer request.
   1120          
   1121              [..] In this Mode it is advised to use the following function:
   1122                  (+) void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState).
   1123          
   1124          @endverbatim
   1125            * @{
   1126            */
   1127          
   1128          /**
   1129            * @brief  Enables or disables the specified SPI/I2S interrupts.
   1130            * @param  SPIx: where x can be 1 or 2 in SPI mode or 1 in I2S mode to select 
   1131            *         the SPI peripheral.  
   1132            * @note   SPI2 is not available for STM32F031 devices.
   1133            *         I2S mode is not supported for STM32F030 devices.  
   1134            * @param  SPI_I2S_IT: specifies the SPI interrupt source to be enabled or disabled. 
   1135            *          This parameter can be one of the following values:
   1136            *            @arg SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
   1137            *            @arg SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
   1138            *            @arg SPI_I2S_IT_ERR: Error interrupt mask
   1139            * @param  NewState: new state of the specified SPI interrupt.
   1140            *          This parameter can be: ENABLE or DISABLE.
   1141            * @retval None
   1142            */

   \                                 In section .text, align 2, keep-with-next
   1143          void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
   1144          {
   \                     SPI_I2S_ITConfig: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1145            uint16_t itpos = 0, itmask = 0 ;
   \        0x2   0x2300             MOVS     R3,#+0
   \        0x4   0x001C             MOVS     R4,R3
   1146          
   1147            /* Check the parameters */
   1148            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1149            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1150            assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
   1151          
   1152            /* Get the SPI IT index */
   1153            itpos = SPI_I2S_IT >> 4;
   \        0x6   0x000B             MOVS     R3,R1
   \        0x8   0xB2DB             UXTB     R3,R3
   \        0xA   0x091B             LSRS     R3,R3,#+4
   \        0xC   0xB2DB             UXTB     R3,R3
   1154          
   1155            /* Set the IT mask */
   1156            itmask = (uint16_t)1 << (uint16_t)itpos;
   \        0xE   0x2101             MOVS     R1,#+1
   \       0x10   0x4099             LSLS     R1,R1,R3
   1157          
   1158            if (NewState != DISABLE)
   \       0x12   0xB2D2             UXTB     R2,R2
   \       0x14   0x2A00             CMP      R2,#+0
   \       0x16   0xD003             BEQ      ??SPI_I2S_ITConfig_0
   1159            {
   1160              /* Enable the selected SPI interrupt */
   1161              SPIx->CR2 |= itmask;
   \       0x18   0x8882             LDRH     R2,[R0, #+4]
   \       0x1A   0x4311             ORRS     R1,R1,R2
   \       0x1C   0x8081             STRH     R1,[R0, #+4]
   \       0x1E   0xE002             B        ??SPI_I2S_ITConfig_1
   1162            }
   1163            else
   1164            {
   1165              /* Disable the selected SPI interrupt */
   1166              SPIx->CR2 &= (uint16_t)~itmask;
   \                     ??SPI_I2S_ITConfig_0: (+1)
   \       0x20   0x8882             LDRH     R2,[R0, #+4]
   \       0x22   0x438A             BICS     R2,R2,R1
   \       0x24   0x8082             STRH     R2,[R0, #+4]
   1167            }
   1168          }
   \                     ??SPI_I2S_ITConfig_1: (+1)
   \       0x26   0xBD10             POP      {R4,PC}          ;; return
   1169          
   1170          /**
   1171            * @brief  Returns the current SPIx Transmission FIFO filled level.
   1172            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
   1173            * @note   SPI2 is not available for STM32F031 devices.
   1174            * @retval The Transmission FIFO filling state.
   1175            *          - SPI_TransmissionFIFOStatus_Empty: when FIFO is empty
   1176            *          - SPI_TransmissionFIFOStatus_1QuarterFull: if more than 1 quarter-full.
   1177            *          - SPI_TransmissionFIFOStatus_HalfFull: if more than 1 half-full.
   1178            *          - SPI_TransmissionFIFOStatus_Full: when FIFO is full.
   1179            */

   \                                 In section .text, align 2, keep-with-next
   1180          uint16_t SPI_GetTransmissionFIFOStatus(SPI_TypeDef* SPIx)
   1181          {
   1182            /* Get the SPIx Transmission FIFO level bits */
   1183            return (uint16_t)((SPIx->SR & SPI_SR_FTLVL));
   \                     SPI_GetTransmissionFIFOStatus: (+1)
   \        0x0   0x8901             LDRH     R1,[R0, #+8]
   \        0x2   0x20C0             MOVS     R0,#+192
   \        0x4   0x0140             LSLS     R0,R0,#+5        ;; #+6144
   \        0x6   0x4008             ANDS     R0,R0,R1
   \        0x8   0x4770             BX       LR               ;; return
   1184          }
   1185          
   1186          /**
   1187            * @brief  Returns the current SPIx Reception FIFO filled level.
   1188            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
   1189            * @note   SPI2 is not available for STM32F031 devices.
   1190            * @retval The Reception FIFO filling state.
   1191            *          - SPI_ReceptionFIFOStatus_Empty: when FIFO is empty
   1192            *          - SPI_ReceptionFIFOStatus_1QuarterFull: if more than 1 quarter-full.
   1193            *          - SPI_ReceptionFIFOStatus_HalfFull: if more than 1 half-full.
   1194            *          - SPI_ReceptionFIFOStatus_Full: when FIFO is full.
   1195            */

   \                                 In section .text, align 2, keep-with-next
   1196          uint16_t SPI_GetReceptionFIFOStatus(SPI_TypeDef* SPIx)
   1197          {
   1198            /* Get the SPIx Reception FIFO level bits */
   1199            return (uint16_t)((SPIx->SR & SPI_SR_FRLVL));
   \                     SPI_GetReceptionFIFOStatus: (+1)
   \        0x0   0x8901             LDRH     R1,[R0, #+8]
   \        0x2   0x20C0             MOVS     R0,#+192
   \        0x4   0x00C0             LSLS     R0,R0,#+3        ;; #+1536
   \        0x6   0x4008             ANDS     R0,R0,R1
   \        0x8   0x4770             BX       LR               ;; return
   1200          }
   1201          
   1202          /**
   1203            * @brief  Checks whether the specified SPI flag is set or not.
   1204            * @param  SPIx: where x can be 1 or 2 in SPI mode or 1 in I2S mode to select 
   1205            *         the SPI peripheral.    
   1206            * @note   SPI2 is not available for STM32F031 devices.
   1207            *         I2S mode is not supported for STM32F030 devices.  
   1208            * @param  SPI_I2S_FLAG: specifies the SPI flag to check. 
   1209            *          This parameter can be one of the following values:
   1210            *            @arg SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
   1211            *            @arg SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
   1212            *            @arg SPI_I2S_FLAG_BSY: Busy flag.
   1213            *            @arg SPI_I2S_FLAG_OVR: Overrun flag.
   1214            *            @arg SPI_FLAG_MODF: Mode Fault flag.
   1215            *            @arg SPI_FLAG_CRCERR: CRC Error flag.
   1216            *            @arg SPI_I2S_FLAG_FRE: TI frame format error flag.
   1217            *            @arg I2S_FLAG_UDR: Underrun Error flag.
   1218            *            @arg I2S_FLAG_CHSIDE: Channel Side flag.   
   1219            * @retval The new state of SPI_I2S_FLAG (SET or RESET).
   1220            */

   \                                 In section .text, align 2, keep-with-next
   1221          FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
   1222          {
   \                     SPI_I2S_GetFlagStatus: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0002             MOVS     R2,R0
   1223            FlagStatus bitstatus = RESET;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x0003             MOVS     R3,R0
   1224            /* Check the parameters */
   1225            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1226            assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
   1227          
   1228            /* Check the status of the specified SPI flag */
   1229            if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
   \        0x8   0x8912             LDRH     R2,[R2, #+8]
   \        0xA   0x420A             TST      R2,R1
   \        0xC   0xD001             BEQ      ??SPI_I2S_GetFlagStatus_0
   1230            {
   1231              /* SPI_I2S_FLAG is set */
   1232              bitstatus = SET;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xE7FF             B        ??SPI_I2S_GetFlagStatus_1
   1233            }
   1234            else
   1235            {
   1236              /* SPI_I2S_FLAG is reset */
   1237              bitstatus = RESET;
   1238            }
   1239            /* Return the SPI_I2S_FLAG status */
   1240            return  bitstatus;
   \                     ??SPI_I2S_GetFlagStatus_0: (+1)
   \                     ??SPI_I2S_GetFlagStatus_1: (+1)
   \       0x12   0xB2C0             UXTB     R0,R0
   \       0x14   0xBD00             POP      {PC}             ;; return
   1241          }
   1242          
   1243          /**
   1244            * @brief  Clears the SPIx CRC Error (CRCERR) flag.
   1245            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
   1246            * @note   SPI2 is not available for STM32F031 devices.
   1247            *         I2S mode is not supported for STM32F030 devices.  
   1248            * @param  SPI_I2S_FLAG: specifies the SPI flag to clear. 
   1249            *         This function clears only CRCERR flag.
   1250            * @note   OVR (OverRun error) flag is cleared by software sequence: a read 
   1251            *         operation to SPI_DR register (SPI_I2S_ReceiveData()) followed by  
   1252            *         a read operation to SPI_SR register (SPI_I2S_GetFlagStatus()).
   1253            * @note   MODF (Mode Fault) flag is cleared by software sequence: a read/write 
   1254            *         operation to SPI_SR register (SPI_I2S_GetFlagStatus()) followed by
   1255            *         a write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
   1256            * @retval None
   1257            */

   \                                 In section .text, align 2, keep-with-next
   1258          void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
   1259          {
   1260            /* Check the parameters */
   1261            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1262            assert_param(IS_SPI_CLEAR_FLAG(SPI_I2S_FLAG));
   1263          
   1264            /* Clear the selected SPI CRC Error (CRCERR) flag */
   1265            SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
   \                     SPI_I2S_ClearFlag: (+1)
   \        0x0   0xB289             UXTH     R1,R1
   \        0x2   0x43CA             MVNS     R2,R1
   \        0x4   0x8102             STRH     R2,[R0, #+8]
   1266          }
   \        0x6   0x4770             BX       LR               ;; return
   1267          
   1268          /**
   1269            * @brief  Checks whether the specified SPI/I2S interrupt has occurred or not.
   1270            * @param  SPIx: where x can be 1 or 2 in SPI mode or 1 in I2S mode to select 
   1271            *         the SPI peripheral.
   1272            * @param  SPI_I2S_IT: specifies the SPI interrupt source to check. 
   1273            *          This parameter can be one of the following values:
   1274            *            @arg SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
   1275            *            @arg SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
   1276            *            @arg SPI_IT_MODF: Mode Fault interrupt.
   1277            *            @arg SPI_I2S_IT_OVR: Overrun interrupt.
   1278            *            @arg I2S_IT_UDR: Underrun interrupt.  
   1279            *            @arg SPI_I2S_IT_FRE: Format Error interrupt.  
   1280            * @retval The new state of SPI_I2S_IT (SET or RESET).
   1281            */

   \                                 In section .text, align 2, keep-with-next
   1282          ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
   1283          {
   \                     SPI_I2S_GetITStatus: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0x0002             MOVS     R2,R0
   1284            ITStatus bitstatus = RESET;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x0003             MOVS     R3,R0
   1285            uint16_t itpos = 0, itmask = 0, enablestatus = 0;
   \        0x8   0x0003             MOVS     R3,R0
   \        0xA   0x0003             MOVS     R3,R0
   \        0xC   0x0003             MOVS     R3,R0
   1286          
   1287            /* Check the parameters */
   1288            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1289            assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
   1290          
   1291            /* Get the SPI_I2S_IT index */
   1292            itpos = 0x01 << (SPI_I2S_IT & 0x0F);
   \        0xE   0x2301             MOVS     R3,#+1
   \       0x10   0x001C             MOVS     R4,R3
   \       0x12   0x070D             LSLS     R5,R1,#+28       ;; ZeroExtS R5,R1,#+28,#+28
   \       0x14   0x0F2D             LSRS     R5,R5,#+28
   \       0x16   0x40AC             LSLS     R4,R4,R5
   1293          
   1294            /* Get the SPI_I2S_IT IT mask */
   1295            itmask = SPI_I2S_IT >> 4;
   \       0x18   0x000D             MOVS     R5,R1
   \       0x1A   0xB2ED             UXTB     R5,R5
   \       0x1C   0x092D             LSRS     R5,R5,#+4
   \       0x1E   0xB2ED             UXTB     R5,R5
   1296          
   1297            /* Set the IT mask */
   1298            itmask = 0x01 << itmask;
   \       0x20   0x0019             MOVS     R1,R3
   \       0x22   0x40A9             LSLS     R1,R1,R5
   1299          
   1300            /* Get the SPI_I2S_IT enable bit status */
   1301            enablestatus = (SPIx->CR2 & itmask) ;
   \       0x24   0x8895             LDRH     R5,[R2, #+4]
   \       0x26   0x4029             ANDS     R1,R1,R5
   1302          
   1303            /* Check the status of the specified SPI interrupt */
   1304            if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
   \       0x28   0x8912             LDRH     R2,[R2, #+8]
   \       0x2A   0x4222             TST      R2,R4
   \       0x2C   0xD004             BEQ      ??SPI_I2S_GetITStatus_0
   \       0x2E   0xB289             UXTH     R1,R1
   \       0x30   0x2900             CMP      R1,#+0
   \       0x32   0xD001             BEQ      ??SPI_I2S_GetITStatus_0
   1305            {
   1306              /* SPI_I2S_IT is set */
   1307              bitstatus = SET;
   \       0x34   0x0018             MOVS     R0,R3
   \       0x36   0xE7FF             B        ??SPI_I2S_GetITStatus_1
   1308            }
   1309            else
   1310            {
   1311              /* SPI_I2S_IT is reset */
   1312              bitstatus = RESET;
   1313            }
   1314            /* Return the SPI_I2S_IT status */
   1315            return bitstatus;
   \                     ??SPI_I2S_GetITStatus_0: (+1)
   \                     ??SPI_I2S_GetITStatus_1: (+1)
   \       0x38   0xB2C0             UXTB     R0,R0
   \       0x3A   0xBD30             POP      {R4,R5,PC}       ;; return
   1316          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x4001'3000        DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x4000'3800        DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0x0000'F0FF        DC32     0xf0ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0x0000'FFFB        DC32     0xfffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \        0x0   0x0000'F7FF        DC32     0xf7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \        0x0   0x0000'F040        DC32     0xf040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \        0x0   0x0000'FFBF        DC32     0xffbf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \        0x0   0x0000'FFEF        DC32     0xffef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \        0x0   0x0000'FBFF        DC32     0xfbff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \        0x0   0x0000'EFFF        DC32     0xefff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \        0x0   0x0000'BFFF        DC32     0xbfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \        0x0   0x0000'FEFF        DC32     0xfeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \        0x0   0x0000'FFF7        DC32     0xfff7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_13:
   \        0x0   0x0000'DFFF        DC32     0xdfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_14:
   \        0x0   0x0000'9FFF        DC32     0x9fff
   1317          
   1318          /**
   1319            * @}
   1320            */
   1321          
   1322          /**
   1323            * @}
   1324            */
   1325          
   1326          /**
   1327            * @}
   1328            */ 
   1329          
   1330          /**
   1331            * @}
   1332            */
   1333          
   1334          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   I2S_Cmd
      64   I2S_Init
        64   -> RCC_GetClocksFreq
        64 __aeabi_uidiv
       0   I2S_StructInit
       4   SPI_BiDirectionalLineConfig
       0   SPI_CRCLengthConfig
       4   SPI_CalculateCRC
       4   SPI_Cmd
       0   SPI_DataSizeConfig
       4   SPI_GetCRC
       0   SPI_GetCRCPolynomial
       0   SPI_GetReceptionFIFOStatus
       0   SPI_GetTransmissionFIFOStatus
       0   SPI_I2S_ClearFlag
       4   SPI_I2S_DMACmd
       8   SPI_I2S_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       4   SPI_I2S_GetFlagStatus
      12   SPI_I2S_GetITStatus
       8   SPI_I2S_ITConfig
       0   SPI_I2S_ReceiveData16
       0   SPI_I2S_SendData16
       8   SPI_Init
       0   SPI_LastDMATransferCmd
       4   SPI_NSSInternalSoftwareConfig
       4   SPI_NSSPulseModeCmd
       0   SPI_ReceiveData8
       0   SPI_RxFIFOThresholdConfig
       4   SPI_SSOutputCmd
       0   SPI_SendData8
       0   SPI_StructInit
       4   SPI_TIModeCmd
       0   SPI_TransmitCRC


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      30  I2S_Cmd
     202  I2S_Init
      18  I2S_StructInit
      32  SPI_BiDirectionalLineConfig
      16  SPI_CRCLengthConfig
      30  SPI_CalculateCRC
      28  SPI_Cmd
      14  SPI_DataSizeConfig
      20  SPI_GetCRC
       4  SPI_GetCRCPolynomial
      10  SPI_GetReceptionFIFOStatus
      10  SPI_GetTransmissionFIFOStatus
       8  SPI_I2S_ClearFlag
      24  SPI_I2S_DMACmd
      58  SPI_I2S_DeInit
      22  SPI_I2S_GetFlagStatus
      60  SPI_I2S_GetITStatus
      40  SPI_I2S_ITConfig
       4  SPI_I2S_ReceiveData16
       4  SPI_I2S_SendData16
      78  SPI_Init
      16  SPI_LastDMATransferCmd
      30  SPI_NSSInternalSoftwareConfig
      28  SPI_NSSPulseModeCmd
       8  SPI_ReceiveData8
      16  SPI_RxFIFOThresholdConfig
      28  SPI_SSOutputCmd
       8  SPI_SendData8
      28  SPI_StructInit
      28  SPI_TIModeCmd
      12  SPI_TransmitCRC

 
 974 bytes in section .text
 
 974 bytes of CODE memory

Errors: none
Warnings: none
