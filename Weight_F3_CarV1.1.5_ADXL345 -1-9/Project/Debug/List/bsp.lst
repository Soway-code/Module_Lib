###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.4.261/W32 for ARM         10/Jan/2021  16:10:14
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Source\BSP\bsp.c
#    Command line                 =
#        -f C:\Users\macanlin\AppData\Local\Temp\EWD07C.tmp
#        ("C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Source\BSP\bsp.c" -D USE_STDPERIPH_DRIVER -D STM32F072 -lC
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\List" -o
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        C:\rj\IAR\arm\inc\c\DLib_Config_Normal.h -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\BSP\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\FWLib\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\CMSIS\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\OS_Cfg\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-CPU\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-LIB\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uCOS-III\Ports\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uCOS-III\Source\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\APP\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\FWLib\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-LIB\\" -Ol -I
#        C:\rj\IAR\arm\CMSIS\Core\Include\\ -I
#        C:\rj\IAR\arm\CMSIS\DSP\Include\\)
#    Locale                       =  C
#    List file                    =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\List\bsp.lst
#    Object file                  =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\Obj\bsp.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345 -1-9\Source\BSP\bsp.c
      1          
      2          /*
      3          *********************************************************************************************************
      4          *                                     MICIRUM BOARD SUPPORT PACKAGE
      5          *
      6          *                             (c) Copyright 2012; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *               Knowledge of the source code may NOT be used to develop a similar product.
     10          *               Please help us continue to provide the Embedded community with the finest
     11          *               software available.  Your honesty is greatly appreciated.
     12          *********************************************************************************************************
     13          */
     14          
     15          /*
     16          *********************************************************************************************************
     17          *
     18          *                                        BOARD SUPPORT PACKAGE
     19          *
     20          *                                     ST Microelectronics STM32
     21          *                                              on the
     22          *
     23          *                                           STM32F0518-EVAL
     24          *                                          Evaluation Board
     25          *
     26          * Filename      : bsp.c
     27          * Version       : V1.00
     28          * Programmer(s) : FF
     29          *                 MD
     30          *********************************************************************************************************
     31          */
     32          
     33          /*
     34          *********************************************************************************************************
     35          *                                             INCLUDE FILES
     36          *********************************************************************************************************
     37          */
     38          
     39          #define   BSP_MODULE
     40          #include  <bsp.h>
     41          #include "weight.h"
     42          
     43          #if IWDG_EN > 0
     44          void IWDG_Init(void)
     45          {
     46              /*!< LSI Enable */
     47              RCC_LSICmd(ENABLE);
     48          
     49              /*!< Wait till LSI is ready */
     50          
     51              while (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
     52              {}
     53          
     54              /* IWDG timeout equal to 250 ms (the timeout may varies due to LSI frequency
     55               dispersion) */
     56              /* Enable write access to IWDG_PR and IWDG_RLR registers */
     57              IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
     58          
     59              /* IWDG counter clock: LSI/32 */
     60              IWDG_SetPrescaler(IWDG_Prescaler_64);   // 40K / 64 = 625 -> 1.6ms per tick
     61          
     62              /* Set counter reload value*/
     63          
     64              IWDG_SetReload(125);         // 1.6ms * 125 = 200ms
     65          
     66              /* Reload IWDG counter */
     67              IWDG_ReloadCounter();
     68          
     69              /* Enable IWDG (the LSI oscillator will be enabled by hardware) */
     70              IWDG_Enable();
     71          }
     72          
     73          #endif
     74          

   \                                 In section .text, align 2, keep-with-next
     75          void RunVar_Init(void)
     76          {
     77          
     78          }
   \                     RunVar_Init: (+1)
   \        0x0   0x4770             BX       LR               ;; return
     79          
     80          /*
     81          *********************************************************************************************************
     82          *                                               BSP_Init()
     83          *
     84          * Description : Initialize the Board Support Package (BSP).
     85          *
     86          * Argument(s) : none.
     87          *
     88          * Return(s)   : none.
     89          *
     90          * Caller(s)   : Application.
     91          *
     92          * Note(s)     : (1) This function SHOULD be called before any other BSP function is called.
     93          *
     94          *               (2) CPU instruction / data tracing requires the use of the following pins :
     95          *                   (a) (1) Aysynchronous     :  PB[3]
     96          *                       (2) Synchronous 1-bit :  PE[3:2]
     97          *                       (3) Synchronous 2-bit :  PE[4:2]
     98          *                       (4) Synchronous 4-bit :  PE[6:2]
     99          *
    100          *                   (c) The application may wish to adjust the trace bus width depending on I/O
    101          *                       requirements.
    102          *********************************************************************************************************
    103          */
    104          

   \                                 In section .text, align 2, keep-with-next
    105          void  BSP_Init(void)
    106          {
   \                     BSP_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    107              BSP_ISRInit();
   \        0x2   0x....'....        BL       BSP_ISRInit
    108          
    109              EEProm_Init();//EEPROM初始化 配置IIC引脚
   \        0x6   0x....'....        BL       EEProm_Init
    110              
    111              Rd_Dev_Param();//读取设备出厂值
   \        0xA   0x....'....        BL       Rd_Dev_Param
    112              
    113              RunVar_Init();
   \        0xE   0x....'....        BL       RunVar_Init
    114              
    115              Init_xx();      //初始化flash数据
   \       0x12   0x....'....        BL       Init_xx
    116              
    117          #if IWDG_EN > 0
    118              IWDG_Init();
    119          #endif
    120          }
   \       0x16   0xBD01             POP      {R0,PC}          ;; return
    121          
    122          /*
    123          *********************************************************************************************************
    124          *                                            BSP_CPU_ClkFreq()
    125          *
    126          * Description : Read CPU registers to determine the CPU clock frequency of the chip.
    127          *
    128          * Argument(s) : none.
    129          *
    130          * Return(s)   : The CPU clock frequency, in Hz.
    131          *
    132          * Caller(s)   : Application.
    133          *
    134          * Note(s)     : none.
    135          *********************************************************************************************************
    136          */
    137          

   \                                 In section .text, align 2, keep-with-next
    138          CPU_INT32U  BSP_CPU_ClkFreq(void)
    139          {
   \                     BSP_CPU_ClkFreq: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
    140          
    141              RCC_ClocksTypeDef  rcc_clocks;
    142              RCC_GetClocksFreq(&rcc_clocks);
   \        0x4   0x4668             MOV      R0,SP
   \        0x6   0x....'....        BL       RCC_GetClocksFreq
    143              return ((CPU_INT32U)rcc_clocks.HCLK_Frequency);
   \        0xA   0x9801             LDR      R0,[SP, #+4]
   \        0xC   0xB009             ADD      SP,SP,#+36
   \        0xE   0xBD00             POP      {PC}             ;; return
    144          }
    145          
    146          
    147          /*$PAGE*/
    148          /*
    149          *********************************************************************************************************
    150          *                                          CPU_TS_TmrInit()
    151          *
    152          * Description : Initialize & start CPU timestamp timer.
    153          *
    154          * Argument(s) : none.
    155          *
    156          * Return(s)   : none.
    157          *
    158          * Caller(s)   : CPU_TS_Init().
    159          *
    160          *               This function is an INTERNAL CPU module function & MUST be implemented by application/
    161          *               BSP function(s) [see Note #1] but MUST NOT be called by application function(s).
    162          *
    163          * Note(s)     : (1) CPU_TS_TmrInit() is an application/BSP function that MUST be defined by the developer
    164          *                   if either of the following CPU features is enabled :
    165          *
    166          *                   (a) CPU timestamps
    167          *                   (b) CPU interrupts disabled time measurements
    168          *
    169          *                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
    170          *                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
    171          *
    172          *               (2) (a) Timer count values MUST be returned via word-size-configurable 'CPU_TS_TMR'
    173          *                       data type.
    174          *
    175          *                       (1) If timer has more bits, truncate timer values' higher-order bits greater
    176          *                           than the configured 'CPU_TS_TMR' timestamp timer data type word size.
    177          *
    178          *                       (2) Since the timer MUST NOT have less bits than the configured 'CPU_TS_TMR'
    179          *                           timestamp timer data type word size; 'CPU_CFG_TS_TMR_SIZE' MUST be
    180          *                           configured so that ALL bits in 'CPU_TS_TMR' data type are significant.
    181          *
    182          *                           In other words, if timer size is not a binary-multiple of 8-bit octets
    183          *                           (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple
    184          *                           octet word size SHOULD be configured (e.g. to 16-bits).  However, the
    185          *                           minimum supported word size for CPU timestamp timers is 8-bits.
    186          *
    187          *                       See also 'cpu_cfg.h   CPU TIMESTAMP CONFIGURATION  Note #2'
    188          *                              & 'cpu_core.h  CPU TIMESTAMP DATA TYPES     Note #1'.
    189          *
    190          *                   (b) Timer SHOULD be an 'up'  counter whose values increase with each time count.
    191          *
    192          *                   (c) When applicable, timer period SHOULD be less than the typical measured time
    193          *                       but MUST be less than the maximum measured time; otherwise, timer resolution
    194          *                       inadequate to measure desired times.
    195          *
    196          *                   See also 'CPU_TS_TmrRd()  Note #2'.
    197          *********************************************************************************************************
    198          */
    199          
    200          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    201          void  CPU_TS_TmrInit(void)
    202          {
    203          
    204          }
   \                     CPU_TS_TmrInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    205          
    206          #endif
    207          
    208          
    209          /*$PAGE*/
    210          /*
    211          *********************************************************************************************************
    212          *                                           CPU_TS_TmrRd()
    213          *
    214          * Description : Get current CPU timestamp timer count value.
    215          *
    216          * Argument(s) : none.
    217          *
    218          * Return(s)   : Timestamp timer count (see Notes #2a & #2b).
    219          *
    220          * Caller(s)   : CPU_TS_Init(),
    221          *               CPU_TS_Get32(),
    222          *               CPU_TS_Get64(),
    223          *               CPU_IntDisMeasStart(),
    224          *               CPU_IntDisMeasStop().
    225          *
    226          *               This function is an INTERNAL CPU module function & MUST be implemented by application/
    227          *               BSP function(s) [see Note #1] but SHOULD NOT be called by application function(s).
    228          *
    229          * Note(s)     : (1) CPU_TS_TmrRd() is an application/BSP function that MUST be defined by the developer
    230          *                   if either of the following CPU features is enabled :
    231          *
    232          *                   (a) CPU timestamps
    233          *                   (b) CPU interrupts disabled time measurements
    234          *
    235          *                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
    236          *                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
    237          *
    238          *               (2) (a) Timer count values MUST be returned via word-size-configurable 'CPU_TS_TMR'
    239          *                       data type.
    240          *
    241          *                       (1) If timer has more bits, truncate timer values' higher-order bits greater
    242          *                           than the configured 'CPU_TS_TMR' timestamp timer data type word size.
    243          *
    244          *                       (2) Since the timer MUST NOT have less bits than the configured 'CPU_TS_TMR'
    245          *                           timestamp timer data type word size; 'CPU_CFG_TS_TMR_SIZE' MUST be
    246          *                           configured so that ALL bits in 'CPU_TS_TMR' data type are significant.
    247          *
    248          *                           In other words, if timer size is not a binary-multiple of 8-bit octets
    249          *                           (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple
    250          *                           octet word size SHOULD be configured (e.g. to 16-bits).  However, the
    251          *                           minimum supported word size for CPU timestamp timers is 8-bits.
    252          *
    253          *                       See also 'cpu_cfg.h   CPU TIMESTAMP CONFIGURATION  Note #2'
    254          *                              & 'cpu_core.h  CPU TIMESTAMP DATA TYPES     Note #1'.
    255          *
    256          *                   (b) Timer SHOULD be an 'up'  counter whose values increase with each time count.
    257          *
    258          *                       (1) If timer is a 'down' counter whose values decrease with each time count,
    259          *                           then the returned timer value MUST be ones-complemented.
    260          *
    261          *                   (c) (1) When applicable, the amount of time measured by CPU timestamps is
    262          *                           calculated by either of the following equations :
    263          *
    264          *                           (A) Time measured  =  Number timer counts  *  Timer period
    265          *
    266          *                                   where
    267          *
    268          *                                       Number timer counts     Number of timer counts measured
    269          *                                       Timer period            Timer's period in some units of
    270          *                                                                   (fractional) seconds
    271          *                                       Time measured           Amount of time measured, in same
    272          *                                                                   units of (fractional) seconds
    273          *                                                                   as the Timer period
    274          *
    275          *                                                  Number timer counts
    276          *                           (B) Time measured  =  ---------------------
    277          *                                                    Timer frequency
    278          *
    279          *                                   where
    280          *
    281          *                                       Number timer counts     Number of timer counts measured
    282          *                                       Timer frequency         Timer's frequency in some units
    283          *                                                                   of counts per second
    284          *                                       Time measured           Amount of time measured, in seconds
    285          *
    286          *                       (2) Timer period SHOULD be less than the typical measured time but MUST be less
    287          *                           than the maximum measured time; otherwise, timer resolution inadequate to
    288          *                           measure desired times.
    289          *********************************************************************************************************
    290          */
    291          
    292          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    293          CPU_TS_TMR  CPU_TS_TmrRd(void)
    294          {
    295              CPU_TS_TMR  ts_tmr_cnts;
    296              
    297              ts_tmr_cnts = 0u;
   \                     CPU_TS_TmrRd: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
    298          
    299              return (ts_tmr_cnts);
   \        0x2   0x4770             BX       LR               ;; return
    300          }
    301          
    302          #endif
    303          
    304          
    305          /*$PAGE*/
    306          /*
    307          *********************************************************************************************************
    308          *                                         CPU_TSxx_to_uSec()
    309          *
    310          * Description : Convert a 32-/64-bit CPU timestamp from timer counts to microseconds.
    311          *
    312          * Argument(s) : ts_cnts   CPU timestamp (in timestamp timer counts [see Note #2aA]).
    313          *
    314          * Return(s)   : Converted CPU timestamp (in microseconds           [see Note #2aD]).
    315          *
    316          * Caller(s)   : Application.
    317          *
    318          *               This function is an (optional) CPU module application programming interface (API)
    319          *               function which MAY be implemented by application/BSP function(s) [see Note #1] &
    320          *               MAY be called by application function(s).
    321          *
    322          * Note(s)     : (1) CPU_TS32_to_uSec()/CPU_TS64_to_uSec() are application/BSP functions that MAY be
    323          *                   optionally defined by the developer when either of the following CPU features is
    324          *                   enabled :
    325          *
    326          *                   (a) CPU timestamps
    327          *                   (b) CPU interrupts disabled time measurements
    328          *
    329          *                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
    330          *                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
    331          *
    332          *               (2) (a) The amount of time measured by CPU timestamps is calculated by either of
    333          *                       the following equations :
    334          *
    335          *                                                                        10^6 microseconds
    336          *                       (1) Time measured  =   Number timer counts   *  -------------------  *  Timer period
    337          *                                                                            1 second
    338          *
    339          *                                              Number timer counts       10^6 microseconds
    340          *                       (2) Time measured  =  ---------------------  *  -------------------
    341          *                                                Timer frequency             1 second
    342          *
    343          *                               where
    344          *
    345          *                                   (A) Number timer counts     Number of timer counts measured
    346          *                                   (B) Timer frequency         Timer's frequency in some units
    347          *                                                                   of counts per second
    348          *                                   (C) Timer period            Timer's period in some units of
    349          *                                                                   (fractional)  seconds
    350          *                                   (D) Time measured           Amount of time measured,
    351          *                                                                   in microseconds
    352          *
    353          *                   (b) Timer period SHOULD be less than the typical measured time but MUST be less
    354          *                       than the maximum measured time; otherwise, timer resolution inadequate to
    355          *                       measure desired times.
    356          *
    357          *                   (c) Specific implementations may convert any number of CPU_TS32 or CPU_TS64 bits
    358          *                       -- up to 32 or 64, respectively -- into microseconds.
    359          *********************************************************************************************************
    360          */
    361          
    362          #if (CPU_CFG_TS_32_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    363          CPU_INT64U  CPU_TS32_to_uSec(CPU_TS32  ts_cnts)                 /* 32-bit conversion                                    */
    364          {
   \                     CPU_TS32_to_uSec: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    365              CPU_INT64U  ts_us;
    366              CPU_INT64U  fclk_freq;
    367          
    368          
    369              fclk_freq = BSP_CPU_ClkFreq();
   \        0x4   0x....'....        BL       BSP_CPU_ClkFreq
   \        0x8   0x2100             MOVS     R1,#+0
    370              ts_us     = ts_cnts / (fclk_freq / DEF_TIME_NBR_uS_PER_SEC);
   \        0xA   0x....             LDR      R2,??DataTable1  ;; 0xf4240
   \        0xC   0x2300             MOVS     R3,#+0
   \        0xE   0x....'....        BL       __aeabi_uldivmod
   \       0x12   0x0002             MOVS     R2,R0
   \       0x14   0x000B             MOVS     R3,R1
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x....'....        BL       __aeabi_uldivmod
    371          
    372              return (ts_us);
   \       0x1E   0xBD10             POP      {R4,PC}          ;; return
    373          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x000F'4240        DC32     0xf4240
    374          
    375          #endif
    376          
    377          
    378          #if (CPU_CFG_TS_64_EN == DEF_ENABLED)
    379          CPU_INT64U  CPU_TS64_to_uSec(CPU_TS64  ts_cnts)                 /* 64-bit conversion                                    */
    380          {
    381              CPU_INT64U  ts_us;
    382              CPU_INT64U  fclk_freq;
    383          
    384          
    385              fclk_freq = BSP_CPU_ClkFreq();
    386              ts_us     = ts_cnts / (fclk_freq / DEF_TIME_NBR_uS_PER_SEC);
    387          
    388              return (ts_us);
    389          }
    390          
    391          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   BSP_CPU_ClkFreq
        40   -> RCC_GetClocksFreq
       8   BSP_Init
         8   -> BSP_ISRInit
         8   -> EEProm_Init
         8   -> Init_xx
         8   -> Rd_Dev_Param
         8   -> RunVar_Init
       8   CPU_TS32_to_uSec
         8   -> BSP_CPU_ClkFreq
         8 __aeabi_uldivmod
       0   CPU_TS_TmrInit
       0   CPU_TS_TmrRd
       0   RunVar_Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
      16  BSP_CPU_ClkFreq
      24  BSP_Init
      32  CPU_TS32_to_uSec
       2  CPU_TS_TmrInit
       4  CPU_TS_TmrRd
       2  RunVar_Init

 
 84 bytes in section .text
 
 84 bytes of CODE memory

Errors: none
Warnings: none
