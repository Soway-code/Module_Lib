###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.4.261/W32 for ARM         10/Jan/2021  16:10:23
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Source\FWLib\src\stm32f0xx_can.c
#    Command line      =
#        -f C:\Users\macanlin\AppData\Local\Temp\EWF291.tmp
#        ("C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Source\FWLib\src\stm32f0xx_can.c" -D USE_STDPERIPH_DRIVER -D
#        STM32F072 -lC
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\List" -o
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        C:\rj\IAR\arm\inc\c\DLib_Config_Normal.h -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\BSP\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\FWLib\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\CMSIS\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\OS_Cfg\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-CPU\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-LIB\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uCOS-III\Ports\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uCOS-III\Source\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\APP\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\FWLib\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-LIB\\" -Ol -I
#        C:\rj\IAR\arm\CMSIS\Core\Include\\ -I
#        C:\rj\IAR\arm\CMSIS\DSP\Include\\)
#    Locale            =  C
#    List file         =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\List\stm32f0xx_can.lst
#    Object file       =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\Obj\stm32f0xx_can.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345 -1-9\Source\FWLib\src\stm32f0xx_can.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f0xx_can.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    16-January-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Controller area network (CAN) peripheral and 
      9            *          applicable only for STM32F072 devices :           
     10            *           + Initialization and Configuration 
     11            *           + CAN Frames Transmission 
     12            *           + CAN Frames Reception    
     13            *           + Operation modes switch  
     14            *           + Error management          
     15            *           + Interrupts and flags        
     16            *         
     17            @verbatim
     18                                         
     19           ===============================================================================      
     20                                ##### How to use this driver #####
     21           ===============================================================================                
     22              [..]
     23              (#) Enable the CAN controller interface clock using 
     24                  RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN, ENABLE);      
     25              (#) CAN pins configuration:
     26                  (++) Enable the clock for the CAN GPIOs using the following function:
     27                       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOx, ENABLE);   
     28                  (++) Connect the involved CAN pins to AF0 using the following function 
     29                       GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_CANx); 
     30                  (++) Configure these CAN pins in alternate function mode by calling
     31                       the function  GPIO_Init();
     32              (#) Initialise and configure the CAN using CAN_Init() and 
     33                  CAN_FilterInit() functions.   
     34              (#) Transmit the desired CAN frame using CAN_Transmit() function.
     35              (#) Check the transmission of a CAN frame using CAN_TransmitStatus() function.
     36              (#) Cancel the transmission of a CAN frame using CAN_CancelTransmit() function.  
     37              (#) Receive a CAN frame using CAN_Recieve() function.
     38              (#) Release the receive FIFOs using CAN_FIFORelease() function.
     39              (#) Return the number of pending received frames using CAN_MessagePending() function.            
     40              (#) To control CAN events you can use one of the following two methods:
     41                  (++) Check on CAN flags using the CAN_GetFlagStatus() function.  
     42                  (++) Use CAN interrupts through the function CAN_ITConfig() at initialization 
     43                       phase and CAN_GetITStatus() function into interrupt routines to check 
     44                       if the event has occurred or not.
     45                       After checking on a flag you should clear it using CAN_ClearFlag()
     46                       function. And after checking on an interrupt event you should clear it 
     47                       using CAN_ClearITPendingBit() function.            
     48                           
     49            @endverbatim
     50            *       
     51            ******************************************************************************
     52            * @attention
     53            *
     54            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     55            *
     56            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     57            * You may not use this file except in compliance with the License.
     58            * You may obtain a copy of the License at:
     59            *
     60            *        http://www.st.com/software_license_agreement_liberty_v2
     61            *
     62            * Unless required by applicable law or agreed to in writing, software 
     63            * distributed under the License is distributed on an "AS IS" BASIS, 
     64            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     65            * See the License for the specific language governing permissions and
     66            * limitations under the License.
     67            *
     68            ******************************************************************************
     69            */
     70          
     71          /* Includes ------------------------------------------------------------------*/
     72          #include "stm32f0xx_can.h"
     73          #include "stm32f0xx_rcc.h"
     74          
     75          /** @addtogroup STM32F0xx_StdPeriph_Driver
     76            * @{
     77            */
     78          
     79          /** @defgroup CAN 
     80            * @brief CAN driver modules
     81            * @{
     82            */ 
     83          /* Private typedef -----------------------------------------------------------*/
     84          /* Private define ------------------------------------------------------------*/
     85          
     86          /* CAN Master Control Register bits */
     87          #define MCR_DBF           ((uint32_t)0x00010000) /* software master reset */
     88          
     89          /* CAN Mailbox Transmit Request */
     90          #define TMIDxR_TXRQ       ((uint32_t)0x00000001) /* Transmit mailbox request */
     91          
     92          /* CAN Filter Master Register bits */
     93          #define FMR_FINIT         ((uint32_t)0x00000001) /* Filter init mode */
     94          
     95          /* Time out for INAK bit */
     96          #define INAK_TIMEOUT      ((uint32_t)0x00FFFFFF)
     97          /* Time out for SLAK bit */
     98          #define SLAK_TIMEOUT      ((uint32_t)0x00FFFFFF)
     99          
    100          /* Flags in TSR register */
    101          #define CAN_FLAGS_TSR     ((uint32_t)0x08000000) 
    102          /* Flags in RF1R register */
    103          #define CAN_FLAGS_RF1R    ((uint32_t)0x04000000) 
    104          /* Flags in RF0R register */
    105          #define CAN_FLAGS_RF0R    ((uint32_t)0x02000000) 
    106          /* Flags in MSR register */
    107          #define CAN_FLAGS_MSR     ((uint32_t)0x01000000) 
    108          /* Flags in ESR register */
    109          #define CAN_FLAGS_ESR     ((uint32_t)0x00F00000) 
    110          
    111          /* Mailboxes definition */
    112          #define CAN_TXMAILBOX_0   ((uint8_t)0x00)
    113          #define CAN_TXMAILBOX_1   ((uint8_t)0x01)
    114          #define CAN_TXMAILBOX_2   ((uint8_t)0x02) 
    115          
    116          #define CAN_MODE_MASK     ((uint32_t) 0x00000003)
    117          
    118          /* Private macro -------------------------------------------------------------*/
    119          /* Private variables ---------------------------------------------------------*/
    120          /* Private function prototypes -----------------------------------------------*/
    121          /* Private functions ---------------------------------------------------------*/
    122          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);
    123          
    124          /** @defgroup CAN_Private_Functions
    125            * @{
    126            */
    127          
    128          /** @defgroup CAN_Group1 Initialization and Configuration functions
    129           *  @brief    Initialization and Configuration functions 
    130           *
    131          @verbatim    
    132           ===============================================================================
    133                        ##### Initialization and Configuration functions #####
    134           ===============================================================================  
    135              [..] This section provides functions allowing to: 
    136                   (+) Initialize the CAN peripherals : Prescaler, operating mode, the maximum 
    137                       number of time quanta to perform resynchronization, the number of time 
    138                       quanta in Bit Segment 1 and 2 and many other modes. 
    139                   (+) Configure the CAN reception filter.                                      
    140                   (+) Select the start bank filter for slave CAN.
    141                   (+) Enable or disable the Debug Freeze mode for CAN.
    142                   (+) Enable or disable the CAN Time Trigger Operation communication mode.
    143             
    144          @endverbatim
    145            * @{
    146            */
    147            
    148          /**
    149            * @brief  Deinitializes the CAN peripheral registers to their default reset values.
    150            * @param  CANx: where x can be 1 to select the CAN peripheral.
    151            * @retval None.
    152            */

   \                                 In section .text, align 2, keep-with-next
    153          void CAN_DeInit(CAN_TypeDef* CANx)
    154          {
   \                     CAN_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    155            /* Check the parameters */
    156            assert_param(IS_CAN_ALL_PERIPH(CANx));
    157           
    158            /* Enable CAN reset state */
    159            RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN, ENABLE);
   \        0x2   0x2480             MOVS     R4,#+128
   \        0x4   0x04A4             LSLS     R4,R4,#+18       ;; #+33554432
   \        0x6   0x2101             MOVS     R1,#+1
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x....'....        BL       RCC_APB1PeriphResetCmd
    160            /* Release CAN from reset state */
    161            RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN, DISABLE);
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0x....'....        BL       RCC_APB1PeriphResetCmd
    162          }
   \       0x16   0xBD10             POP      {R4,PC}          ;; return
    163          
    164          /**
    165            * @brief  Initializes the CAN peripheral according to the specified
    166            *         parameters in the CAN_InitStruct.
    167            * @param  CANx: where x can be 1 to select the CAN peripheral.
    168            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that contains
    169            *         the configuration information for the CAN peripheral.
    170            * @retval Constant indicates initialization succeed which will be 
    171            *         CAN_InitStatus_Failed or CAN_InitStatus_Success.
    172            */

   \                                 In section .text, align 2, keep-with-next
    173          uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
    174          {
   \                     CAN_Init: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0x0002             MOVS     R2,R0
    175            uint8_t InitStatus = CAN_InitStatus_Failed;
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x0018             MOVS     R0,R3
    176            uint32_t wait_ack = 0x00000000;
   \        0x8   0x001C             MOVS     R4,R3
    177            
    178            /* Check the parameters */
    179            assert_param(IS_CAN_ALL_PERIPH(CANx));
    180            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
    181            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
    182            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
    183            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
    184            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
    185            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
    186            assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
    187            assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
    188            assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
    189            assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
    190            assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
    191          
    192            /* Exit from sleep mode */
    193            CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
   \        0xA   0x6810             LDR      R0,[R2, #+0]
   \        0xC   0x2502             MOVS     R5,#+2
   \        0xE   0x43A8             BICS     R0,R0,R5
   \       0x10   0x6010             STR      R0,[R2, #+0]
    194          
    195            /* Request initialisation */
    196            CANx->MCR |= CAN_MCR_INRQ ;
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x6815             LDR      R5,[R2, #+0]
   \       0x16   0x4305             ORRS     R5,R5,R0
   \       0x18   0x6015             STR      R5,[R2, #+0]
   \       0x1A   0xE000             B        ??CAN_Init_0
    197          
    198            /* Wait the acknowledge */
    199            while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    200            {
    201              wait_ack++;
   \                     ??CAN_Init_1: (+1)
   \       0x1C   0x1C64             ADDS     R4,R4,#+1
    202            }
   \                     ??CAN_Init_0: (+1)
   \       0x1E   0x6855             LDR      R5,[R2, #+4]
   \       0x20   0x4005             ANDS     R5,R5,R0
   \       0x22   0x2D00             CMP      R5,#+0
   \       0x24   0xD102             BNE      ??CAN_Init_2
   \       0x26   0x....             LDR      R5,??DataTable5  ;; 0xffffff
   \       0x28   0x42AC             CMP      R4,R5
   \       0x2A   0xD1F7             BNE      ??CAN_Init_1
    203          
    204            /* Check acknowledge */
    205            if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
   \                     ??CAN_Init_2: (+1)
   \       0x2C   0x6854             LDR      R4,[R2, #+4]
   \       0x2E   0x4004             ANDS     R4,R4,R0
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0xD101             BNE      ??CAN_Init_3
    206            {
    207              InitStatus = CAN_InitStatus_Failed;
   \       0x34   0x0018             MOVS     R0,R3
   \       0x36   0xE06A             B        ??CAN_Init_4
    208            }
    209            else 
    210            {
    211              /* Set the time triggered communication mode */
    212              if (CAN_InitStruct->CAN_TTCM == ENABLE)
   \                     ??CAN_Init_3: (+1)
   \       0x38   0x798C             LDRB     R4,[R1, #+6]
   \       0x3A   0x2C01             CMP      R4,#+1
   \       0x3C   0xD104             BNE      ??CAN_Init_5
    213              {
    214                CANx->MCR |= CAN_MCR_TTCM;
   \       0x3E   0x6814             LDR      R4,[R2, #+0]
   \       0x40   0x2580             MOVS     R5,#+128
   \       0x42   0x4325             ORRS     R5,R5,R4
   \       0x44   0x6015             STR      R5,[R2, #+0]
   \       0x46   0xE003             B        ??CAN_Init_6
    215              }
    216              else
    217              {
    218                CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
   \                     ??CAN_Init_5: (+1)
   \       0x48   0x6814             LDR      R4,[R2, #+0]
   \       0x4A   0x2580             MOVS     R5,#+128
   \       0x4C   0x43AC             BICS     R4,R4,R5
   \       0x4E   0x6014             STR      R4,[R2, #+0]
    219              }
    220          
    221              /* Set the automatic bus-off management */
    222              if (CAN_InitStruct->CAN_ABOM == ENABLE)
   \                     ??CAN_Init_6: (+1)
   \       0x50   0x79CC             LDRB     R4,[R1, #+7]
   \       0x52   0x2C01             CMP      R4,#+1
   \       0x54   0xD104             BNE      ??CAN_Init_7
    223              {
    224                CANx->MCR |= CAN_MCR_ABOM;
   \       0x56   0x6814             LDR      R4,[R2, #+0]
   \       0x58   0x2540             MOVS     R5,#+64
   \       0x5A   0x4325             ORRS     R5,R5,R4
   \       0x5C   0x6015             STR      R5,[R2, #+0]
   \       0x5E   0xE003             B        ??CAN_Init_8
    225              }
    226              else
    227              {
    228                CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
   \                     ??CAN_Init_7: (+1)
   \       0x60   0x6814             LDR      R4,[R2, #+0]
   \       0x62   0x2540             MOVS     R5,#+64
   \       0x64   0x43AC             BICS     R4,R4,R5
   \       0x66   0x6014             STR      R4,[R2, #+0]
    229              }
    230          
    231              /* Set the automatic wake-up mode */
    232              if (CAN_InitStruct->CAN_AWUM == ENABLE)
   \                     ??CAN_Init_8: (+1)
   \       0x68   0x7A0C             LDRB     R4,[R1, #+8]
   \       0x6A   0x2C01             CMP      R4,#+1
   \       0x6C   0xD104             BNE      ??CAN_Init_9
    233              {
    234                CANx->MCR |= CAN_MCR_AWUM;
   \       0x6E   0x6814             LDR      R4,[R2, #+0]
   \       0x70   0x2520             MOVS     R5,#+32
   \       0x72   0x4325             ORRS     R5,R5,R4
   \       0x74   0x6015             STR      R5,[R2, #+0]
   \       0x76   0xE003             B        ??CAN_Init_10
    235              }
    236              else
    237              {
    238                CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
   \                     ??CAN_Init_9: (+1)
   \       0x78   0x6814             LDR      R4,[R2, #+0]
   \       0x7A   0x2520             MOVS     R5,#+32
   \       0x7C   0x43AC             BICS     R4,R4,R5
   \       0x7E   0x6014             STR      R4,[R2, #+0]
    239              }
    240          
    241              /* Set the no automatic retransmission */
    242              if (CAN_InitStruct->CAN_NART == ENABLE)
   \                     ??CAN_Init_10: (+1)
   \       0x80   0x7A4C             LDRB     R4,[R1, #+9]
   \       0x82   0x2C01             CMP      R4,#+1
   \       0x84   0xD104             BNE      ??CAN_Init_11
    243              {
    244                CANx->MCR |= CAN_MCR_NART;
   \       0x86   0x6814             LDR      R4,[R2, #+0]
   \       0x88   0x2510             MOVS     R5,#+16
   \       0x8A   0x4325             ORRS     R5,R5,R4
   \       0x8C   0x6015             STR      R5,[R2, #+0]
   \       0x8E   0xE003             B        ??CAN_Init_12
    245              }
    246              else
    247              {
    248                CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
   \                     ??CAN_Init_11: (+1)
   \       0x90   0x6814             LDR      R4,[R2, #+0]
   \       0x92   0x2510             MOVS     R5,#+16
   \       0x94   0x43AC             BICS     R4,R4,R5
   \       0x96   0x6014             STR      R4,[R2, #+0]
    249              }
    250          
    251              /* Set the receive FIFO locked mode */
    252              if (CAN_InitStruct->CAN_RFLM == ENABLE)
   \                     ??CAN_Init_12: (+1)
   \       0x98   0x7A8C             LDRB     R4,[R1, #+10]
   \       0x9A   0x2C01             CMP      R4,#+1
   \       0x9C   0xD104             BNE      ??CAN_Init_13
    253              {
    254                CANx->MCR |= CAN_MCR_RFLM;
   \       0x9E   0x6814             LDR      R4,[R2, #+0]
   \       0xA0   0x2508             MOVS     R5,#+8
   \       0xA2   0x4325             ORRS     R5,R5,R4
   \       0xA4   0x6015             STR      R5,[R2, #+0]
   \       0xA6   0xE003             B        ??CAN_Init_14
    255              }
    256              else
    257              {
    258                CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
   \                     ??CAN_Init_13: (+1)
   \       0xA8   0x6814             LDR      R4,[R2, #+0]
   \       0xAA   0x2508             MOVS     R5,#+8
   \       0xAC   0x43AC             BICS     R4,R4,R5
   \       0xAE   0x6014             STR      R4,[R2, #+0]
    259              }
    260          
    261              /* Set the transmit FIFO priority */
    262              if (CAN_InitStruct->CAN_TXFP == ENABLE)
   \                     ??CAN_Init_14: (+1)
   \       0xB0   0x7ACC             LDRB     R4,[R1, #+11]
   \       0xB2   0x2C01             CMP      R4,#+1
   \       0xB4   0xD104             BNE      ??CAN_Init_15
    263              {
    264                CANx->MCR |= CAN_MCR_TXFP;
   \       0xB6   0x6814             LDR      R4,[R2, #+0]
   \       0xB8   0x2504             MOVS     R5,#+4
   \       0xBA   0x4325             ORRS     R5,R5,R4
   \       0xBC   0x6015             STR      R5,[R2, #+0]
   \       0xBE   0xE003             B        ??CAN_Init_16
    265              }
    266              else
    267              {
    268                CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
   \                     ??CAN_Init_15: (+1)
   \       0xC0   0x6814             LDR      R4,[R2, #+0]
   \       0xC2   0x2504             MOVS     R5,#+4
   \       0xC4   0x43AC             BICS     R4,R4,R5
   \       0xC6   0x6014             STR      R4,[R2, #+0]
    269              }
    270          
    271              /* Set the bit timing register */
    272              CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
    273                          ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
    274                          ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
    275                          ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
    276                         ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
   \                     ??CAN_Init_16: (+1)
   \       0xC8   0x788C             LDRB     R4,[R1, #+2]
   \       0xCA   0x07A4             LSLS     R4,R4,#+30
   \       0xCC   0x78CD             LDRB     R5,[R1, #+3]
   \       0xCE   0x062D             LSLS     R5,R5,#+24
   \       0xD0   0x4325             ORRS     R5,R5,R4
   \       0xD2   0x790C             LDRB     R4,[R1, #+4]
   \       0xD4   0x0424             LSLS     R4,R4,#+16
   \       0xD6   0x432C             ORRS     R4,R4,R5
   \       0xD8   0x794D             LDRB     R5,[R1, #+5]
   \       0xDA   0x052D             LSLS     R5,R5,#+20
   \       0xDC   0x4325             ORRS     R5,R5,R4
   \       0xDE   0x8809             LDRH     R1,[R1, #+0]
   \       0xE0   0x1E49             SUBS     R1,R1,#+1
   \       0xE2   0x4329             ORRS     R1,R1,R5
   \       0xE4   0x61D1             STR      R1,[R2, #+28]
    277          
    278              /* Request leave initialisation */
    279              CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
   \       0xE6   0x6811             LDR      R1,[R2, #+0]
   \       0xE8   0x2401             MOVS     R4,#+1
   \       0xEA   0x43A1             BICS     R1,R1,R4
   \       0xEC   0x6011             STR      R1,[R2, #+0]
    280          
    281             /* Wait the acknowledge */
    282             wait_ack = 0;
   \       0xEE   0x0019             MOVS     R1,R3
   \       0xF0   0xE000             B        ??CAN_Init_17
    283          
    284             while (((CANx->MSR & CAN_MSR_INAK) == (uint16_t)CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    285             {
    286               wait_ack++;
   \                     ??CAN_Init_18: (+1)
   \       0xF2   0x1C49             ADDS     R1,R1,#+1
    287             }
   \                     ??CAN_Init_17: (+1)
   \       0xF4   0x6854             LDR      R4,[R2, #+4]
   \       0xF6   0x4004             ANDS     R4,R4,R0
   \       0xF8   0x2C00             CMP      R4,#+0
   \       0xFA   0xD002             BEQ      ??CAN_Init_19
   \       0xFC   0x....             LDR      R4,??DataTable5  ;; 0xffffff
   \       0xFE   0x42A1             CMP      R1,R4
   \      0x100   0xD1F7             BNE      ??CAN_Init_18
    288          
    289              /* ...and check acknowledged */
    290              if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
   \                     ??CAN_Init_19: (+1)
   \      0x102   0x6851             LDR      R1,[R2, #+4]
   \      0x104   0x4001             ANDS     R1,R1,R0
   \      0x106   0x2900             CMP      R1,#+0
   \      0x108   0xD001             BEQ      ??CAN_Init_20
    291              {
    292                InitStatus = CAN_InitStatus_Failed;
   \      0x10A   0x0018             MOVS     R0,R3
   \      0x10C   0xE7FF             B        ??CAN_Init_4
    293              }
    294              else
    295              {
    296                InitStatus = CAN_InitStatus_Success ;
    297              }
    298            }
    299          
    300            /* At this step, return the status of initialization */
    301            return InitStatus;
   \                     ??CAN_Init_20: (+1)
   \                     ??CAN_Init_4: (+1)
   \      0x10E   0xB2C0             UXTB     R0,R0
   \      0x110   0xBD30             POP      {R4,R5,PC}       ;; return
    302          }
    303          
    304          /**
    305            * @brief  Configures the CAN reception filter according to the specified
    306            *         parameters in the CAN_FilterInitStruct.
    307            * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef structure that
    308            *         contains the configuration information.
    309            * @retval None
    310            */

   \                                 In section .text, align 2, keep-with-next
    311          void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
    312          {
   \                     CAN_FilterInit: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
    313            uint32_t filter_number_bit_pos = 0;
   \        0x2   0x2100             MOVS     R1,#+0
    314            /* Check the parameters */
    315            assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
    316            assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
    317            assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
    318            assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
    319            assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
    320          
    321            filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
   \        0x4   0x2301             MOVS     R3,#+1
   \        0x6   0x0019             MOVS     R1,R3
   \        0x8   0x7A82             LDRB     R2,[R0, #+10]
   \        0xA   0x4091             LSLS     R1,R1,R2
    322          
    323            /* Initialisation mode for the filter */
    324            CAN->FMR |= FMR_FINIT;
   \        0xC   0x....             LDR      R2,??DataTable5_1  ;; 0x40006600
   \        0xE   0x6814             LDR      R4,[R2, #+0]
   \       0x10   0x4323             ORRS     R3,R3,R4
   \       0x12   0x6013             STR      R3,[R2, #+0]
    325          
    326            /* Filter Deactivation */
    327            CAN->FA1R &= ~(uint32_t)filter_number_bit_pos;
   \       0x14   0x....             LDR      R3,??DataTable5_2  ;; 0x4000661c
   \       0x16   0x681C             LDR      R4,[R3, #+0]
   \       0x18   0x438C             BICS     R4,R4,R1
   \       0x1A   0x601C             STR      R4,[R3, #+0]
    328          
    329            /* Filter Scale */
    330            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
   \       0x1C   0x7B04             LDRB     R4,[R0, #+12]
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD115             BNE      ??CAN_FilterInit_0
    331            {
    332              /* 16-bit scale for the filter */
    333              CAN->FS1R &= ~(uint32_t)filter_number_bit_pos;
   \       0x22   0x....             LDR      R4,??DataTable5_3  ;; 0x4000660c
   \       0x24   0x6825             LDR      R5,[R4, #+0]
   \       0x26   0x438D             BICS     R5,R5,R1
   \       0x28   0x6025             STR      R5,[R4, #+0]
    334          
    335              /* First 16-bit identifier and First 16-bit mask */
    336              /* Or First 16-bit identifier and Second 16-bit identifier */
    337              CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    338                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
    339                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
   \       0x2A   0x....             LDR      R4,??DataTable5_4  ;; 0x40006640
   \       0x2C   0x88C5             LDRH     R5,[R0, #+6]
   \       0x2E   0x042D             LSLS     R5,R5,#+16
   \       0x30   0x8846             LDRH     R6,[R0, #+2]
   \       0x32   0x4335             ORRS     R5,R5,R6
   \       0x34   0x7A86             LDRB     R6,[R0, #+10]
   \       0x36   0x2708             MOVS     R7,#+8
   \       0x38   0x437E             MULS     R6,R7,R6
   \       0x3A   0x51A5             STR      R5,[R4, R6]
    340          
    341              /* Second 16-bit identifier and Second 16-bit mask */
    342              /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    343              CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    344                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    345                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
   \       0x3C   0x7A85             LDRB     R5,[R0, #+10]
   \       0x3E   0x2608             MOVS     R6,#+8
   \       0x40   0x4375             MULS     R5,R6,R5
   \       0x42   0x1964             ADDS     R4,R4,R5
   \       0x44   0x8885             LDRH     R5,[R0, #+4]
   \       0x46   0x042D             LSLS     R5,R5,#+16
   \       0x48   0x8806             LDRH     R6,[R0, #+0]
   \       0x4A   0x4335             ORRS     R5,R5,R6
   \       0x4C   0x6065             STR      R5,[R4, #+4]
    346            }
    347          
    348            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
   \                     ??CAN_FilterInit_0: (+1)
   \       0x4E   0x7B04             LDRB     R4,[R0, #+12]
   \       0x50   0x2C01             CMP      R4,#+1
   \       0x52   0xD115             BNE      ??CAN_FilterInit_1
    349            {
    350              /* 32-bit scale for the filter */
    351              CAN->FS1R |= filter_number_bit_pos;
   \       0x54   0x....             LDR      R4,??DataTable5_3  ;; 0x4000660c
   \       0x56   0x6825             LDR      R5,[R4, #+0]
   \       0x58   0x430D             ORRS     R5,R5,R1
   \       0x5A   0x6025             STR      R5,[R4, #+0]
    352              /* 32-bit identifier or First 32-bit identifier */
    353              CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    354                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
    355                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
   \       0x5C   0x....             LDR      R4,??DataTable5_4  ;; 0x40006640
   \       0x5E   0x8805             LDRH     R5,[R0, #+0]
   \       0x60   0x042D             LSLS     R5,R5,#+16
   \       0x62   0x8846             LDRH     R6,[R0, #+2]
   \       0x64   0x4335             ORRS     R5,R5,R6
   \       0x66   0x7A86             LDRB     R6,[R0, #+10]
   \       0x68   0x2708             MOVS     R7,#+8
   \       0x6A   0x437E             MULS     R6,R7,R6
   \       0x6C   0x51A5             STR      R5,[R4, R6]
    356              /* 32-bit mask or Second 32-bit identifier */
    357              CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    358                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    359                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
   \       0x6E   0x7A85             LDRB     R5,[R0, #+10]
   \       0x70   0x2608             MOVS     R6,#+8
   \       0x72   0x4375             MULS     R5,R6,R5
   \       0x74   0x1964             ADDS     R4,R4,R5
   \       0x76   0x8885             LDRH     R5,[R0, #+4]
   \       0x78   0x042D             LSLS     R5,R5,#+16
   \       0x7A   0x88C6             LDRH     R6,[R0, #+6]
   \       0x7C   0x4335             ORRS     R5,R5,R6
   \       0x7E   0x6065             STR      R5,[R4, #+4]
    360            }
    361          
    362            /* Filter Mode */
    363            if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
   \                     ??CAN_FilterInit_1: (+1)
   \       0x80   0x7AC4             LDRB     R4,[R0, #+11]
   \       0x82   0x2C00             CMP      R4,#+0
   \       0x84   0xD104             BNE      ??CAN_FilterInit_2
    364            {
    365              /*Id/Mask mode for the filter*/
    366              CAN->FM1R &= ~(uint32_t)filter_number_bit_pos;
   \       0x86   0x....             LDR      R4,??DataTable5_5  ;; 0x40006604
   \       0x88   0x6825             LDR      R5,[R4, #+0]
   \       0x8A   0x438D             BICS     R5,R5,R1
   \       0x8C   0x6025             STR      R5,[R4, #+0]
   \       0x8E   0xE003             B        ??CAN_FilterInit_3
    367            }
    368            else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    369            {
    370              /*Identifier list mode for the filter*/
    371              CAN->FM1R |= (uint32_t)filter_number_bit_pos;
   \                     ??CAN_FilterInit_2: (+1)
   \       0x90   0x....             LDR      R4,??DataTable5_5  ;; 0x40006604
   \       0x92   0x6825             LDR      R5,[R4, #+0]
   \       0x94   0x430D             ORRS     R5,R5,R1
   \       0x96   0x6025             STR      R5,[R4, #+0]
    372            }
    373          
    374            /* Filter FIFO assignment */
    375            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
   \                     ??CAN_FilterInit_3: (+1)
   \       0x98   0x8904             LDRH     R4,[R0, #+8]
   \       0x9A   0x2C00             CMP      R4,#+0
   \       0x9C   0xD103             BNE      ??CAN_FilterInit_4
    376            {
    377              /* FIFO 0 assignation for the filter */
    378              CAN->FFA1R &= ~(uint32_t)filter_number_bit_pos;
   \       0x9E   0x....             LDR      R4,??DataTable6  ;; 0x40006614
   \       0xA0   0x6825             LDR      R5,[R4, #+0]
   \       0xA2   0x438D             BICS     R5,R5,R1
   \       0xA4   0x6025             STR      R5,[R4, #+0]
    379            }
    380          
    381            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
   \                     ??CAN_FilterInit_4: (+1)
   \       0xA6   0x8904             LDRH     R4,[R0, #+8]
   \       0xA8   0x2C01             CMP      R4,#+1
   \       0xAA   0xD103             BNE      ??CAN_FilterInit_5
    382            {
    383              /* FIFO 1 assignation for the filter */
    384              CAN->FFA1R |= (uint32_t)filter_number_bit_pos;
   \       0xAC   0x....             LDR      R4,??DataTable6  ;; 0x40006614
   \       0xAE   0x6825             LDR      R5,[R4, #+0]
   \       0xB0   0x430D             ORRS     R5,R5,R1
   \       0xB2   0x6025             STR      R5,[R4, #+0]
    385            }
    386            
    387            /* Filter activation */
    388            if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
   \                     ??CAN_FilterInit_5: (+1)
   \       0xB4   0x7B40             LDRB     R0,[R0, #+13]
   \       0xB6   0x2801             CMP      R0,#+1
   \       0xB8   0xD102             BNE      ??CAN_FilterInit_6
    389            {
    390              CAN->FA1R |= filter_number_bit_pos;
   \       0xBA   0x6818             LDR      R0,[R3, #+0]
   \       0xBC   0x4301             ORRS     R1,R1,R0
   \       0xBE   0x6019             STR      R1,[R3, #+0]
    391            }
    392          
    393            /* Leave the initialisation mode for the filter */
    394            CAN->FMR &= ~FMR_FINIT;
   \                     ??CAN_FilterInit_6: (+1)
   \       0xC0   0x6810             LDR      R0,[R2, #+0]
   \       0xC2   0x2101             MOVS     R1,#+1
   \       0xC4   0x4388             BICS     R0,R0,R1
   \       0xC6   0x6010             STR      R0,[R2, #+0]
    395          }
   \       0xC8   0xBDF0             POP      {R4-R7,PC}       ;; return
    396          
    397          /**
    398            * @brief  Fills each CAN_InitStruct member with its default value.
    399            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which ill be initialized.
    400            * @retval None
    401            */

   \                                 In section .text, align 2, keep-with-next
    402          void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
    403          {
    404            /* Reset CAN init structure parameters values */
    405            
    406            /* Initialize the time triggered communication mode */
    407            CAN_InitStruct->CAN_TTCM = DISABLE;
   \                     CAN_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x7181             STRB     R1,[R0, #+6]
    408            
    409            /* Initialize the automatic bus-off management */
    410            CAN_InitStruct->CAN_ABOM = DISABLE;
   \        0x4   0x71C1             STRB     R1,[R0, #+7]
    411            
    412            /* Initialize the automatic wake-up mode */
    413            CAN_InitStruct->CAN_AWUM = DISABLE;
   \        0x6   0x7201             STRB     R1,[R0, #+8]
    414            
    415            /* Initialize the no automatic retransmission */
    416            CAN_InitStruct->CAN_NART = DISABLE;
   \        0x8   0x7241             STRB     R1,[R0, #+9]
    417            
    418            /* Initialize the receive FIFO locked mode */
    419            CAN_InitStruct->CAN_RFLM = DISABLE;
   \        0xA   0x7281             STRB     R1,[R0, #+10]
    420            
    421            /* Initialize the transmit FIFO priority */
    422            CAN_InitStruct->CAN_TXFP = DISABLE;
   \        0xC   0x72C1             STRB     R1,[R0, #+11]
    423            
    424            /* Initialize the CAN_Mode member */
    425            CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
   \        0xE   0x7081             STRB     R1,[R0, #+2]
    426            
    427            /* Initialize the CAN_SJW member */
    428            CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
   \       0x10   0x70C1             STRB     R1,[R0, #+3]
    429            
    430            /* Initialize the CAN_BS1 member */
    431            CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
   \       0x12   0x2103             MOVS     R1,#+3
   \       0x14   0x7101             STRB     R1,[R0, #+4]
    432            
    433            /* Initialize the CAN_BS2 member */
    434            CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
   \       0x16   0x2102             MOVS     R1,#+2
   \       0x18   0x7141             STRB     R1,[R0, #+5]
    435            
    436            /* Initialize the CAN_Prescaler member */
    437            CAN_InitStruct->CAN_Prescaler = 1;
   \       0x1A   0x2101             MOVS     R1,#+1
   \       0x1C   0x8001             STRH     R1,[R0, #+0]
    438          }
   \       0x1E   0x4770             BX       LR               ;; return
    439          
    440          /**
    441            * @brief  Select the start bank filter for slave CAN.
    442            * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
    443            * @retval None
    444            */

   \                                 In section .text, align 2, keep-with-next
    445          void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
    446          {
    447            /* Check the parameters */
    448            assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
    449            
    450            /* Enter Initialisation mode for the filter */
    451            CAN->FMR |= FMR_FINIT;
   \                     CAN_SlaveStartBank: (+1)
   \        0x0   0x....             LDR      R1,??DataTable5_1  ;; 0x40006600
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x2301             MOVS     R3,#+1
   \        0x6   0x4313             ORRS     R3,R3,R2
   \        0x8   0x600B             STR      R3,[R1, #+0]
    452            
    453            /* Select the start slave bank */
    454            CAN->FMR &= (uint32_t)0xFFFFC0F1 ;
   \        0xA   0x680A             LDR      R2,[R1, #+0]
   \        0xC   0x....             LDR      R3,??DataTable6_1  ;; 0xffffc0f1
   \        0xE   0x4013             ANDS     R3,R3,R2
   \       0x10   0x600B             STR      R3,[R1, #+0]
    455            CAN->FMR |= (uint32_t)(CAN_BankNumber)<<8;
   \       0x12   0x680A             LDR      R2,[R1, #+0]
   \       0x14   0xB2C0             UXTB     R0,R0
   \       0x16   0x0200             LSLS     R0,R0,#+8
   \       0x18   0x4310             ORRS     R0,R0,R2
   \       0x1A   0x6008             STR      R0,[R1, #+0]
    456            
    457            /* Leave Initialisation mode for the filter */
    458            CAN->FMR &= ~FMR_FINIT;
   \       0x1C   0x6808             LDR      R0,[R1, #+0]
   \       0x1E   0x2201             MOVS     R2,#+1
   \       0x20   0x4390             BICS     R0,R0,R2
   \       0x22   0x6008             STR      R0,[R1, #+0]
    459          }
   \       0x24   0x4770             BX       LR               ;; return
    460          
    461          /**
    462            * @brief  Enables or disables the DBG Freeze for CAN.
    463            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    464            * @param  NewState: new state of the CAN peripheral. 
    465            *          This parameter can be: ENABLE (CAN reception/transmission is frozen
    466            *          during debug. Reception FIFOs can still be accessed/controlled normally) 
    467            *          or DISABLE (CAN is working during debug).
    468            * @retval None
    469            */

   \                                 In section .text, align 2, keep-with-next
    470          void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
    471          {
   \                     CAN_DBGFreeze: (+1)
   \        0x0   0xB500             PUSH     {LR}
    472            /* Check the parameters */
    473            assert_param(IS_CAN_ALL_PERIPH(CANx));
    474            assert_param(IS_FUNCTIONAL_STATE(NewState));
    475            
    476            if (NewState != DISABLE)
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD005             BEQ      ??CAN_DBGFreeze_0
    477            {
    478              /* Enable Debug Freeze  */
    479              CANx->MCR |= MCR_DBF;
   \        0x8   0x6801             LDR      R1,[R0, #+0]
   \        0xA   0x2280             MOVS     R2,#+128
   \        0xC   0x0252             LSLS     R2,R2,#+9        ;; #+65536
   \        0xE   0x430A             ORRS     R2,R2,R1
   \       0x10   0x6002             STR      R2,[R0, #+0]
   \       0x12   0xE003             B        ??CAN_DBGFreeze_1
    480            }
    481            else
    482            {
    483              /* Disable Debug Freeze */
    484              CANx->MCR &= ~MCR_DBF;
   \                     ??CAN_DBGFreeze_0: (+1)
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0x....             LDR      R2,??DataTable6_2  ;; 0xfffeffff
   \       0x18   0x400A             ANDS     R2,R2,R1
   \       0x1A   0x6002             STR      R2,[R0, #+0]
    485            }
    486          }
   \                     ??CAN_DBGFreeze_1: (+1)
   \       0x1C   0xBD00             POP      {PC}             ;; return
    487          
    488          /**
    489            * @brief  Enables or disables the CAN Time TriggerOperation communication mode.
    490            * @note   DLC must be programmed as 8 in order Time Stamp (2 bytes) to be 
    491            *         sent over the CAN bus.  
    492            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    493            * @param  NewState: Mode new state. This parameter can be: ENABLE or DISABLE.
    494            *         When enabled, Time stamp (TIME[15:0]) value is  sent in the last two
    495            *         data bytes of the 8-byte message: TIME[7:0] in data byte 6 and TIME[15:8] 
    496            *         in data byte 7. 
    497            * @retval None
    498            */

   \                                 In section .text, align 2, keep-with-next
    499          void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
    500          {
   \                     CAN_TTComModeCmd: (+1)
   \        0x0   0xB500             PUSH     {LR}
    501            /* Check the parameters */
    502            assert_param(IS_CAN_ALL_PERIPH(CANx));
    503            assert_param(IS_FUNCTIONAL_STATE(NewState));
    504            if (NewState != DISABLE)
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD01B             BEQ      ??CAN_TTComModeCmd_0
    505            {
    506              /* Enable the TTCM mode */
    507              CANx->MCR |= CAN_MCR_TTCM;
   \        0x8   0x6801             LDR      R1,[R0, #+0]
   \        0xA   0x2280             MOVS     R2,#+128
   \        0xC   0x430A             ORRS     R2,R2,R1
   \        0xE   0x6002             STR      R2,[R0, #+0]
    508          
    509              /* Set TGT bits */
    510              CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
   \       0x10   0x2180             MOVS     R1,#+128
   \       0x12   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \       0x14   0x22C2             MOVS     R2,#+194
   \       0x16   0x0052             LSLS     R2,R2,#+1        ;; #+388
   \       0x18   0x5882             LDR      R2,[R0, R2]
   \       0x1A   0x430A             ORRS     R2,R2,R1
   \       0x1C   0x23C2             MOVS     R3,#+194
   \       0x1E   0x005B             LSLS     R3,R3,#+1        ;; #+388
   \       0x20   0x50C2             STR      R2,[R0, R3]
    511              CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
   \       0x22   0x22CA             MOVS     R2,#+202
   \       0x24   0x0052             LSLS     R2,R2,#+1        ;; #+404
   \       0x26   0x5882             LDR      R2,[R0, R2]
   \       0x28   0x430A             ORRS     R2,R2,R1
   \       0x2A   0x23CA             MOVS     R3,#+202
   \       0x2C   0x005B             LSLS     R3,R3,#+1        ;; #+404
   \       0x2E   0x50C2             STR      R2,[R0, R3]
    512              CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
   \       0x30   0x22D2             MOVS     R2,#+210
   \       0x32   0x0052             LSLS     R2,R2,#+1        ;; #+420
   \       0x34   0x5882             LDR      R2,[R0, R2]
   \       0x36   0x4311             ORRS     R1,R1,R2
   \       0x38   0x22D2             MOVS     R2,#+210
   \       0x3A   0x0052             LSLS     R2,R2,#+1        ;; #+420
   \       0x3C   0x5081             STR      R1,[R0, R2]
   \       0x3E   0xE019             B        ??CAN_TTComModeCmd_1
    513            }
    514            else
    515            {
    516              /* Disable the TTCM mode */
    517              CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
   \                     ??CAN_TTComModeCmd_0: (+1)
   \       0x40   0x6801             LDR      R1,[R0, #+0]
   \       0x42   0x2280             MOVS     R2,#+128
   \       0x44   0x4391             BICS     R1,R1,R2
   \       0x46   0x6001             STR      R1,[R0, #+0]
    518          
    519              /* Reset TGT bits */
    520              CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
   \       0x48   0x....             LDR      R1,??DataTable6_3  ;; 0xfffffeff
   \       0x4A   0x22C2             MOVS     R2,#+194
   \       0x4C   0x0052             LSLS     R2,R2,#+1        ;; #+388
   \       0x4E   0x5882             LDR      R2,[R0, R2]
   \       0x50   0x400A             ANDS     R2,R2,R1
   \       0x52   0x23C2             MOVS     R3,#+194
   \       0x54   0x005B             LSLS     R3,R3,#+1        ;; #+388
   \       0x56   0x50C2             STR      R2,[R0, R3]
    521              CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
   \       0x58   0x22CA             MOVS     R2,#+202
   \       0x5A   0x0052             LSLS     R2,R2,#+1        ;; #+404
   \       0x5C   0x5882             LDR      R2,[R0, R2]
   \       0x5E   0x400A             ANDS     R2,R2,R1
   \       0x60   0x23CA             MOVS     R3,#+202
   \       0x62   0x005B             LSLS     R3,R3,#+1        ;; #+404
   \       0x64   0x50C2             STR      R2,[R0, R3]
    522              CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
   \       0x66   0x22D2             MOVS     R2,#+210
   \       0x68   0x0052             LSLS     R2,R2,#+1        ;; #+420
   \       0x6A   0x5882             LDR      R2,[R0, R2]
   \       0x6C   0x4011             ANDS     R1,R1,R2
   \       0x6E   0x22D2             MOVS     R2,#+210
   \       0x70   0x0052             LSLS     R2,R2,#+1        ;; #+420
   \       0x72   0x5081             STR      R1,[R0, R2]
    523            }
    524          }
   \                     ??CAN_TTComModeCmd_1: (+1)
   \       0x74   0xBD00             POP      {PC}             ;; return
    525          /**
    526            * @}
    527            */
    528          
    529          
    530          /** @defgroup CAN_Group2 CAN Frames Transmission functions
    531           *  @brief    CAN Frames Transmission functions 
    532           *
    533          @verbatim    
    534           ===============================================================================
    535                          ##### CAN Frames Transmission functions #####
    536           ===============================================================================  
    537              [..] This section provides functions allowing to 
    538                   (+) Initiate and transmit a CAN frame message (if there is an empty mailbox).
    539                   (+) Check the transmission status of a CAN Frame.
    540                   (+) Cancel a transmit request.
    541             
    542          @endverbatim
    543            * @{
    544            */
    545          
    546          /**
    547            * @brief  Initiates and transmits a CAN frame message.
    548            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    549            * @param  TxMessage: pointer to a structure which contains CAN Id, CAN DLC and CAN data.
    550            * @retval The number of the mailbox that is used for transmission or
    551            *         CAN_TxStatus_NoMailBox if there is no empty mailbox.
    552            */

   \                                 In section .text, align 2, keep-with-next
    553          uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
    554          {
   \                     CAN_Transmit: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x000A             MOVS     R2,R1
    555            uint8_t transmit_mailbox = 0;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x000B             MOVS     R3,R1
    556            /* Check the parameters */
    557            assert_param(IS_CAN_ALL_PERIPH(CANx));
    558            assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
    559            assert_param(IS_CAN_RTR(TxMessage->RTR));
    560            assert_param(IS_CAN_DLC(TxMessage->DLC));
    561          
    562            /* Select one empty transmit mailbox */
    563            if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
   \        0x8   0x6883             LDR      R3,[R0, #+8]
   \        0xA   0x015B             LSLS     R3,R3,#+5
   \        0xC   0xD40A             BMI      ??CAN_Transmit_0
    564            {
    565              transmit_mailbox = 0;
    566            }
    567            else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
   \                     ??CAN_Transmit_1: (+1)
   \        0xE   0x6881             LDR      R1,[R0, #+8]
   \       0x10   0x0109             LSLS     R1,R1,#+4
   \       0x12   0xD501             BPL      ??CAN_Transmit_2
    568            {
    569              transmit_mailbox = 1;
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0xE005             B        ??CAN_Transmit_0
    570            }
    571            else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
   \                     ??CAN_Transmit_2: (+1)
   \       0x18   0x6881             LDR      R1,[R0, #+8]
   \       0x1A   0x00C9             LSLS     R1,R1,#+3
   \       0x1C   0xD501             BPL      ??CAN_Transmit_3
    572            {
    573              transmit_mailbox = 2;
   \       0x1E   0x2102             MOVS     R1,#+2
   \       0x20   0xE000             B        ??CAN_Transmit_0
    574            }
    575            else
    576            {
    577              transmit_mailbox = CAN_TxStatus_NoMailBox;
   \                     ??CAN_Transmit_3: (+1)
   \       0x22   0x2104             MOVS     R1,#+4
    578            }
    579          
    580            if (transmit_mailbox != CAN_TxStatus_NoMailBox)
   \                     ??CAN_Transmit_0: (+1)
   \       0x24   0x000B             MOVS     R3,R1
   \       0x26   0xB2DB             UXTB     R3,R3
   \       0x28   0x2B04             CMP      R3,#+4
   \       0x2A   0xD100             BNE      .+4
   \       0x2C   0xE09E             B        ??CAN_Transmit_4
    581            {
    582              /* Set up the Id */
    583              CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
   \       0x2E   0x2301             MOVS     R3,#+1
   \       0x30   0x000C             MOVS     R4,R1
   \       0x32   0xB2E4             UXTB     R4,R4
   \       0x34   0x2510             MOVS     R5,#+16
   \       0x36   0x436C             MULS     R4,R5,R4
   \       0x38   0x1904             ADDS     R4,R0,R4
   \       0x3A   0x25C0             MOVS     R5,#+192
   \       0x3C   0x006D             LSLS     R5,R5,#+1        ;; #+384
   \       0x3E   0x5964             LDR      R4,[R4, R5]
   \       0x40   0x401C             ANDS     R4,R4,R3
   \       0x42   0x000D             MOVS     R5,R1
   \       0x44   0xB2ED             UXTB     R5,R5
   \       0x46   0x2610             MOVS     R6,#+16
   \       0x48   0x4375             MULS     R5,R6,R5
   \       0x4A   0x1945             ADDS     R5,R0,R5
   \       0x4C   0x26C0             MOVS     R6,#+192
   \       0x4E   0x0076             LSLS     R6,R6,#+1        ;; #+384
   \       0x50   0x51AC             STR      R4,[R5, R6]
    584              if (TxMessage->IDE == CAN_Id_Standard)
   \       0x52   0x7A14             LDRB     R4,[R2, #+8]
   \       0x54   0x2C00             CMP      R4,#+0
   \       0x56   0xD115             BNE      ??CAN_Transmit_5
    585              {
    586                assert_param(IS_CAN_STDID(TxMessage->StdId));  
    587                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
    588                                                            TxMessage->RTR);
   \       0x58   0x000C             MOVS     R4,R1
   \       0x5A   0xB2E4             UXTB     R4,R4
   \       0x5C   0x2510             MOVS     R5,#+16
   \       0x5E   0x436C             MULS     R4,R5,R4
   \       0x60   0x1904             ADDS     R4,R0,R4
   \       0x62   0x25C0             MOVS     R5,#+192
   \       0x64   0x006D             LSLS     R5,R5,#+1        ;; #+384
   \       0x66   0x5965             LDR      R5,[R4, R5]
   \       0x68   0x6814             LDR      R4,[R2, #+0]
   \       0x6A   0x0566             LSLS     R6,R4,#+21
   \       0x6C   0x7A54             LDRB     R4,[R2, #+9]
   \       0x6E   0x4334             ORRS     R4,R4,R6
   \       0x70   0x432C             ORRS     R4,R4,R5
   \       0x72   0x000D             MOVS     R5,R1
   \       0x74   0xB2ED             UXTB     R5,R5
   \       0x76   0x2610             MOVS     R6,#+16
   \       0x78   0x4375             MULS     R5,R6,R5
   \       0x7A   0x1945             ADDS     R5,R0,R5
   \       0x7C   0x26C0             MOVS     R6,#+192
   \       0x7E   0x0076             LSLS     R6,R6,#+1        ;; #+384
   \       0x80   0x51AC             STR      R4,[R5, R6]
   \       0x82   0xE016             B        ??CAN_Transmit_6
    589              }
    590              else
    591              {
    592                assert_param(IS_CAN_EXTID(TxMessage->ExtId));
    593                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
    594                                                            TxMessage->IDE | \
    595                                                            TxMessage->RTR);
   \                     ??CAN_Transmit_5: (+1)
   \       0x84   0x000C             MOVS     R4,R1
   \       0x86   0xB2E4             UXTB     R4,R4
   \       0x88   0x2510             MOVS     R5,#+16
   \       0x8A   0x436C             MULS     R4,R5,R4
   \       0x8C   0x1904             ADDS     R4,R0,R4
   \       0x8E   0x25C0             MOVS     R5,#+192
   \       0x90   0x006D             LSLS     R5,R5,#+1        ;; #+384
   \       0x92   0x5964             LDR      R4,[R4, R5]
   \       0x94   0x6855             LDR      R5,[R2, #+4]
   \       0x96   0x00ED             LSLS     R5,R5,#+3
   \       0x98   0x7A16             LDRB     R6,[R2, #+8]
   \       0x9A   0x432E             ORRS     R6,R6,R5
   \       0x9C   0x7A55             LDRB     R5,[R2, #+9]
   \       0x9E   0x4335             ORRS     R5,R5,R6
   \       0xA0   0x4325             ORRS     R5,R5,R4
   \       0xA2   0x000C             MOVS     R4,R1
   \       0xA4   0xB2E4             UXTB     R4,R4
   \       0xA6   0x2610             MOVS     R6,#+16
   \       0xA8   0x4374             MULS     R4,R6,R4
   \       0xAA   0x1904             ADDS     R4,R0,R4
   \       0xAC   0x26C0             MOVS     R6,#+192
   \       0xAE   0x0076             LSLS     R6,R6,#+1        ;; #+384
   \       0xB0   0x51A5             STR      R5,[R4, R6]
    596              }
    597              
    598              /* Set up the DLC */
    599              TxMessage->DLC &= (uint8_t)0x0000000F;
   \                     ??CAN_Transmit_6: (+1)
   \       0xB2   0x7A94             LDRB     R4,[R2, #+10]
   \       0xB4   0x0724             LSLS     R4,R4,#+28       ;; ZeroExtS R4,R4,#+28,#+28
   \       0xB6   0x0F24             LSRS     R4,R4,#+28
   \       0xB8   0x7294             STRB     R4,[R2, #+10]
    600              CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
   \       0xBA   0x000C             MOVS     R4,R1
   \       0xBC   0xB2E4             UXTB     R4,R4
   \       0xBE   0x2510             MOVS     R5,#+16
   \       0xC0   0x436C             MULS     R4,R5,R4
   \       0xC2   0x1904             ADDS     R4,R0,R4
   \       0xC4   0x25C2             MOVS     R5,#+194
   \       0xC6   0x006D             LSLS     R5,R5,#+1        ;; #+388
   \       0xC8   0x5964             LDR      R4,[R4, R5]
   \       0xCA   0x250F             MOVS     R5,#+15
   \       0xCC   0x43AC             BICS     R4,R4,R5
   \       0xCE   0x000D             MOVS     R5,R1
   \       0xD0   0xB2ED             UXTB     R5,R5
   \       0xD2   0x2610             MOVS     R6,#+16
   \       0xD4   0x4375             MULS     R5,R6,R5
   \       0xD6   0x1945             ADDS     R5,R0,R5
   \       0xD8   0x26C2             MOVS     R6,#+194
   \       0xDA   0x0076             LSLS     R6,R6,#+1        ;; #+388
   \       0xDC   0x51AC             STR      R4,[R5, R6]
    601              CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
   \       0xDE   0x000C             MOVS     R4,R1
   \       0xE0   0xB2E4             UXTB     R4,R4
   \       0xE2   0x2510             MOVS     R5,#+16
   \       0xE4   0x436C             MULS     R4,R5,R4
   \       0xE6   0x1904             ADDS     R4,R0,R4
   \       0xE8   0x25C2             MOVS     R5,#+194
   \       0xEA   0x006D             LSLS     R5,R5,#+1        ;; #+388
   \       0xEC   0x5965             LDR      R5,[R4, R5]
   \       0xEE   0x7A94             LDRB     R4,[R2, #+10]
   \       0xF0   0x432C             ORRS     R4,R4,R5
   \       0xF2   0x000D             MOVS     R5,R1
   \       0xF4   0xB2ED             UXTB     R5,R5
   \       0xF6   0x2610             MOVS     R6,#+16
   \       0xF8   0x4375             MULS     R5,R6,R5
   \       0xFA   0x1945             ADDS     R5,R0,R5
   \       0xFC   0x26C2             MOVS     R6,#+194
   \       0xFE   0x0076             LSLS     R6,R6,#+1        ;; #+388
   \      0x100   0x51AC             STR      R4,[R5, R6]
    602          
    603              /* Set up the data field */
    604              CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
    605                                                       ((uint32_t)TxMessage->Data[2] << 16) |
    606                                                       ((uint32_t)TxMessage->Data[1] << 8) | 
    607                                                       ((uint32_t)TxMessage->Data[0]));
   \      0x102   0x7B94             LDRB     R4,[R2, #+14]
   \      0x104   0x0624             LSLS     R4,R4,#+24
   \      0x106   0x7B55             LDRB     R5,[R2, #+13]
   \      0x108   0x042D             LSLS     R5,R5,#+16
   \      0x10A   0x4325             ORRS     R5,R5,R4
   \      0x10C   0x7B14             LDRB     R4,[R2, #+12]
   \      0x10E   0x0226             LSLS     R6,R4,#+8
   \      0x110   0x432E             ORRS     R6,R6,R5
   \      0x112   0x7AD4             LDRB     R4,[R2, #+11]
   \      0x114   0x4334             ORRS     R4,R4,R6
   \      0x116   0x000D             MOVS     R5,R1
   \      0x118   0xB2ED             UXTB     R5,R5
   \      0x11A   0x2610             MOVS     R6,#+16
   \      0x11C   0x4375             MULS     R5,R6,R5
   \      0x11E   0x1945             ADDS     R5,R0,R5
   \      0x120   0x26C4             MOVS     R6,#+196
   \      0x122   0x0076             LSLS     R6,R6,#+1        ;; #+392
   \      0x124   0x51AC             STR      R4,[R5, R6]
    608              CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
    609                                                       ((uint32_t)TxMessage->Data[6] << 16) |
    610                                                       ((uint32_t)TxMessage->Data[5] << 8) |
    611                                                       ((uint32_t)TxMessage->Data[4]));
   \      0x126   0x7C94             LDRB     R4,[R2, #+18]
   \      0x128   0x0624             LSLS     R4,R4,#+24
   \      0x12A   0x7C55             LDRB     R5,[R2, #+17]
   \      0x12C   0x042D             LSLS     R5,R5,#+16
   \      0x12E   0x4325             ORRS     R5,R5,R4
   \      0x130   0x7C14             LDRB     R4,[R2, #+16]
   \      0x132   0x0224             LSLS     R4,R4,#+8
   \      0x134   0x432C             ORRS     R4,R4,R5
   \      0x136   0x7BD2             LDRB     R2,[R2, #+15]
   \      0x138   0x4322             ORRS     R2,R2,R4
   \      0x13A   0x000C             MOVS     R4,R1
   \      0x13C   0xB2E4             UXTB     R4,R4
   \      0x13E   0x2510             MOVS     R5,#+16
   \      0x140   0x436C             MULS     R4,R5,R4
   \      0x142   0x1904             ADDS     R4,R0,R4
   \      0x144   0x25C6             MOVS     R5,#+198
   \      0x146   0x006D             LSLS     R5,R5,#+1        ;; #+396
   \      0x148   0x5162             STR      R2,[R4, R5]
    612              /* Request transmission */
    613              CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
   \      0x14A   0x000A             MOVS     R2,R1
   \      0x14C   0xB2D2             UXTB     R2,R2
   \      0x14E   0x2410             MOVS     R4,#+16
   \      0x150   0x4362             MULS     R2,R4,R2
   \      0x152   0x1882             ADDS     R2,R0,R2
   \      0x154   0x24C0             MOVS     R4,#+192
   \      0x156   0x0064             LSLS     R4,R4,#+1        ;; #+384
   \      0x158   0x5912             LDR      R2,[R2, R4]
   \      0x15A   0x4313             ORRS     R3,R3,R2
   \      0x15C   0x000A             MOVS     R2,R1
   \      0x15E   0xB2D2             UXTB     R2,R2
   \      0x160   0x2410             MOVS     R4,#+16
   \      0x162   0x4362             MULS     R2,R4,R2
   \      0x164   0x1880             ADDS     R0,R0,R2
   \      0x166   0x22C0             MOVS     R2,#+192
   \      0x168   0x0052             LSLS     R2,R2,#+1        ;; #+384
   \      0x16A   0x5083             STR      R3,[R0, R2]
    614            }
    615            return transmit_mailbox;
   \                     ??CAN_Transmit_4: (+1)
   \      0x16C   0x0008             MOVS     R0,R1
   \      0x16E   0xB2C0             UXTB     R0,R0
   \      0x170   0xBD70             POP      {R4-R6,PC}       ;; return
    616          }
    617          
    618          /**
    619            * @brief  Checks the transmission status of a CAN Frame.
    620            * @param  CANx: where x can be 1 to select the CAN peripheral.
    621            * @param  TransmitMailbox: the number of the mailbox that is used for transmission.
    622            * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, 
    623            *         CAN_TxStatus_Failed in an other case.
    624            */

   \                                 In section .text, align 2, keep-with-next
    625          uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
    626          {
   \                     CAN_TransmitStatus: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0002             MOVS     R2,R0
    627            uint32_t state = 0;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x0003             MOVS     R3,R0
    628          
    629            /* Check the parameters */
    630            assert_param(IS_CAN_ALL_PERIPH(CANx));
    631            assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
    632           
    633            switch (TransmitMailbox)
   \        0x8   0xB2C9             UXTB     R1,R1
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD003             BEQ      ??CAN_TransmitStatus_0
   \        0xE   0x2902             CMP      R1,#+2
   \       0x10   0xD009             BEQ      ??CAN_TransmitStatus_1
   \       0x12   0xD304             BCC      ??CAN_TransmitStatus_2
   \       0x14   0xE00B             B        ??CAN_TransmitStatus_3
    634            {
    635              case (CAN_TXMAILBOX_0): 
    636                state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
   \                     ??CAN_TransmitStatus_0: (+1)
   \       0x16   0x6892             LDR      R2,[R2, #+8]
   \       0x18   0x....             LDR      R1,??DataTable7  ;; 0x4000003
   \       0x1A   0x4011             ANDS     R1,R1,R2
    637                break;
   \       0x1C   0xE008             B        ??CAN_TransmitStatus_4
    638              case (CAN_TXMAILBOX_1): 
    639                state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
   \                     ??CAN_TransmitStatus_2: (+1)
   \       0x1E   0x6892             LDR      R2,[R2, #+8]
   \       0x20   0x....             LDR      R1,??DataTable7_1  ;; 0x8000300
   \       0x22   0x4011             ANDS     R1,R1,R2
    640                break;
   \       0x24   0xE004             B        ??CAN_TransmitStatus_4
    641              case (CAN_TXMAILBOX_2): 
    642                state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
   \                     ??CAN_TransmitStatus_1: (+1)
   \       0x26   0x6892             LDR      R2,[R2, #+8]
   \       0x28   0x....             LDR      R1,??DataTable7_2  ;; 0x10030000
   \       0x2A   0x4011             ANDS     R1,R1,R2
    643                break;
   \       0x2C   0xE000             B        ??CAN_TransmitStatus_4
    644              default:
    645                state = CAN_TxStatus_Failed;
   \                     ??CAN_TransmitStatus_3: (+1)
   \       0x2E   0x0001             MOVS     R1,R0
    646                break;
    647            }
    648            switch (state)
   \                     ??CAN_TransmitStatus_4: (+1)
   \       0x30   0x2900             CMP      R1,#+0
   \       0x32   0xD013             BEQ      ??CAN_TransmitStatus_5
   \       0x34   0x....             LDR      R2,??DataTable8  ;; 0x4000001
   \       0x36   0x1A89             SUBS     R1,R1,R2
   \       0x38   0xD012             BEQ      ??CAN_TransmitStatus_6
   \       0x3A   0x1E89             SUBS     R1,R1,#+2
   \       0x3C   0xD013             BEQ      ??CAN_TransmitStatus_7
   \       0x3E   0x....             LDR      R2,??DataTable8_1  ;; 0x40000fd
   \       0x40   0x1A89             SUBS     R1,R1,R2
   \       0x42   0xD00E             BEQ      ??CAN_TransmitStatus_8
   \       0x44   0x2280             MOVS     R2,#+128
   \       0x46   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \       0x48   0x1A89             SUBS     R1,R1,R2
   \       0x4A   0xD00E             BEQ      ??CAN_TransmitStatus_9
   \       0x4C   0x....             LDR      R2,??DataTable8_2  ;; 0x800fd00
   \       0x4E   0x1A89             SUBS     R1,R1,R2
   \       0x50   0xD008             BEQ      ??CAN_TransmitStatus_10
   \       0x52   0x2280             MOVS     R2,#+128
   \       0x54   0x0292             LSLS     R2,R2,#+10       ;; #+131072
   \       0x56   0x1A89             SUBS     R1,R1,R2
   \       0x58   0xD009             BEQ      ??CAN_TransmitStatus_11
   \       0x5A   0xE00A             B        ??CAN_TransmitStatus_12
    649            {
    650                /* transmit pending  */
    651              case (0x0): state = CAN_TxStatus_Pending;
   \                     ??CAN_TransmitStatus_5: (+1)
   \       0x5C   0x2002             MOVS     R0,#+2
    652                break;
   \       0x5E   0xE008             B        ??CAN_TransmitStatus_13
    653                /* transmit failed  */
    654               case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
    655                break;
   \                     ??CAN_TransmitStatus_6: (+1)
   \       0x60   0xE007             B        ??CAN_TransmitStatus_13
    656               case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
    657                break;
   \                     ??CAN_TransmitStatus_8: (+1)
   \       0x62   0xE006             B        ??CAN_TransmitStatus_13
    658               case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
    659                break;
   \                     ??CAN_TransmitStatus_10: (+1)
   \       0x64   0xE005             B        ??CAN_TransmitStatus_13
    660                /* transmit succeeded  */
    661              case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
   \                     ??CAN_TransmitStatus_7: (+1)
   \       0x66   0x2001             MOVS     R0,#+1
    662                break;
   \       0x68   0xE003             B        ??CAN_TransmitStatus_13
    663              case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
   \                     ??CAN_TransmitStatus_9: (+1)
   \       0x6A   0x2001             MOVS     R0,#+1
    664                break;
   \       0x6C   0xE001             B        ??CAN_TransmitStatus_13
    665              case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
   \                     ??CAN_TransmitStatus_11: (+1)
   \       0x6E   0x2001             MOVS     R0,#+1
    666                break;
   \       0x70   0xE7FF             B        ??CAN_TransmitStatus_13
    667              default: state = CAN_TxStatus_Failed;
    668                break;
    669            }
    670            return (uint8_t) state;
   \                     ??CAN_TransmitStatus_12: (+1)
   \                     ??CAN_TransmitStatus_13: (+1)
   \       0x72   0xB2C0             UXTB     R0,R0
   \       0x74   0xBD00             POP      {PC}             ;; return
    671          }
    672          
    673          /**
    674            * @brief  Cancels a transmit request.
    675            * @param  CANx: where x can be 1 to select the CAN peripheral.
    676            * @param  Mailbox: Mailbox number.
    677            * @retval None
    678            */

   \                                 In section .text, align 2, keep-with-next
    679          void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
    680          {
   \                     CAN_CancelTransmit: (+1)
   \        0x0   0xB500             PUSH     {LR}
    681            /* Check the parameters */
    682            assert_param(IS_CAN_ALL_PERIPH(CANx));
    683            assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
    684            /* abort transmission */
    685            switch (Mailbox)
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD003             BEQ      ??CAN_CancelTransmit_0
   \        0x8   0x2902             CMP      R1,#+2
   \        0xA   0xD00C             BEQ      ??CAN_CancelTransmit_1
   \        0xC   0xD305             BCC      ??CAN_CancelTransmit_2
   \        0xE   0xE010             B        ??CAN_CancelTransmit_3
    686            {
    687              case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
   \                     ??CAN_CancelTransmit_0: (+1)
   \       0x10   0x6881             LDR      R1,[R0, #+8]
   \       0x12   0x2280             MOVS     R2,#+128
   \       0x14   0x430A             ORRS     R2,R2,R1
   \       0x16   0x6082             STR      R2,[R0, #+8]
    688                break;
   \       0x18   0xE00B             B        ??CAN_CancelTransmit_4
    689              case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
   \                     ??CAN_CancelTransmit_2: (+1)
   \       0x1A   0x6881             LDR      R1,[R0, #+8]
   \       0x1C   0x2280             MOVS     R2,#+128
   \       0x1E   0x0212             LSLS     R2,R2,#+8        ;; #+32768
   \       0x20   0x430A             ORRS     R2,R2,R1
   \       0x22   0x6082             STR      R2,[R0, #+8]
    690                break;
   \       0x24   0xE005             B        ??CAN_CancelTransmit_4
    691              case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
   \                     ??CAN_CancelTransmit_1: (+1)
   \       0x26   0x6881             LDR      R1,[R0, #+8]
   \       0x28   0x2280             MOVS     R2,#+128
   \       0x2A   0x0412             LSLS     R2,R2,#+16       ;; #+8388608
   \       0x2C   0x430A             ORRS     R2,R2,R1
   \       0x2E   0x6082             STR      R2,[R0, #+8]
    692                break;
   \       0x30   0xE7FF             B        ??CAN_CancelTransmit_4
    693              default:
    694                break;
    695            }
    696          }
   \                     ??CAN_CancelTransmit_3: (+1)
   \                     ??CAN_CancelTransmit_4: (+1)
   \       0x32   0xBD00             POP      {PC}             ;; return
    697          /**
    698            * @}
    699            */
    700          
    701          
    702          /** @defgroup CAN_Group3 CAN Frames Reception functions
    703           *  @brief    CAN Frames Reception functions 
    704           *
    705          @verbatim    
    706           ===============================================================================
    707                            ##### CAN Frames Reception functions #####
    708           ===============================================================================  
    709              [..] This section provides functions allowing to 
    710                   (+) Receive a correct CAN frame.
    711                   (+) Release a specified receive FIFO (2 FIFOs are available).
    712                   (+) Return the number of the pending received CAN frames.
    713             
    714          @endverbatim
    715            * @{
    716            */
    717          
    718          /**
    719            * @brief  Receives a correct CAN frame.
    720            * @param  CANx: where x can be 1 to select the CAN peripheral.
    721            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    722            * @param  RxMessage: pointer to a structure receive frame which contains CAN Id,
    723            *         CAN DLC, CAN data and FMI number.
    724            * @retval None
    725            */

   \                                 In section .text, align 2, keep-with-next
    726          void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
    727          {
   \                     CAN_Receive: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    728            /* Check the parameters */
    729            assert_param(IS_CAN_ALL_PERIPH(CANx));
    730            assert_param(IS_CAN_FIFO(FIFONumber));
    731            /* Get the Id */
    732            RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \        0x2   0x000B             MOVS     R3,R1
   \        0x4   0xB2DB             UXTB     R3,R3
   \        0x6   0x2410             MOVS     R4,#+16
   \        0x8   0x4363             MULS     R3,R4,R3
   \        0xA   0x18C3             ADDS     R3,R0,R3
   \        0xC   0x24D8             MOVS     R4,#+216
   \        0xE   0x0064             LSLS     R4,R4,#+1        ;; #+432
   \       0x10   0x591B             LDR      R3,[R3, R4]
   \       0x12   0x2404             MOVS     R4,#+4
   \       0x14   0x4023             ANDS     R3,R3,R4
   \       0x16   0x7213             STRB     R3,[R2, #+8]
    733            if (RxMessage->IDE == CAN_Id_Standard)
   \       0x18   0x7A13             LDRB     R3,[R2, #+8]
   \       0x1A   0x2B00             CMP      R3,#+0
   \       0x1C   0xD10A             BNE      ??CAN_Receive_0
    734            {
    735              RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
   \       0x1E   0x000B             MOVS     R3,R1
   \       0x20   0xB2DB             UXTB     R3,R3
   \       0x22   0x2410             MOVS     R4,#+16
   \       0x24   0x4363             MULS     R3,R4,R3
   \       0x26   0x18C3             ADDS     R3,R0,R3
   \       0x28   0x24D8             MOVS     R4,#+216
   \       0x2A   0x0064             LSLS     R4,R4,#+1        ;; #+432
   \       0x2C   0x591B             LDR      R3,[R3, R4]
   \       0x2E   0x0D5B             LSRS     R3,R3,#+21
   \       0x30   0x6013             STR      R3,[R2, #+0]
   \       0x32   0xE009             B        ??CAN_Receive_1
    736            }
    737            else
    738            {
    739              RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
   \                     ??CAN_Receive_0: (+1)
   \       0x34   0x000B             MOVS     R3,R1
   \       0x36   0xB2DB             UXTB     R3,R3
   \       0x38   0x2410             MOVS     R4,#+16
   \       0x3A   0x4363             MULS     R3,R4,R3
   \       0x3C   0x18C3             ADDS     R3,R0,R3
   \       0x3E   0x24D8             MOVS     R4,#+216
   \       0x40   0x0064             LSLS     R4,R4,#+1        ;; #+432
   \       0x42   0x591B             LDR      R3,[R3, R4]
   \       0x44   0x08DB             LSRS     R3,R3,#+3
   \       0x46   0x6053             STR      R3,[R2, #+4]
    740            }
    741            
    742            RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
   \                     ??CAN_Receive_1: (+1)
   \       0x48   0x000B             MOVS     R3,R1
   \       0x4A   0xB2DB             UXTB     R3,R3
   \       0x4C   0x2410             MOVS     R4,#+16
   \       0x4E   0x4363             MULS     R3,R4,R3
   \       0x50   0x18C3             ADDS     R3,R0,R3
   \       0x52   0x24D8             MOVS     R4,#+216
   \       0x54   0x0064             LSLS     R4,R4,#+1        ;; #+432
   \       0x56   0x591B             LDR      R3,[R3, R4]
   \       0x58   0x2402             MOVS     R4,#+2
   \       0x5A   0x4023             ANDS     R3,R3,R4
   \       0x5C   0x7253             STRB     R3,[R2, #+9]
    743            /* Get the DLC */
    744            RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
   \       0x5E   0x000B             MOVS     R3,R1
   \       0x60   0xB2DB             UXTB     R3,R3
   \       0x62   0x2410             MOVS     R4,#+16
   \       0x64   0x4363             MULS     R3,R4,R3
   \       0x66   0x18C3             ADDS     R3,R0,R3
   \       0x68   0x24DA             MOVS     R4,#+218
   \       0x6A   0x0064             LSLS     R4,R4,#+1        ;; #+436
   \       0x6C   0x591B             LDR      R3,[R3, R4]
   \       0x6E   0x071B             LSLS     R3,R3,#+28       ;; ZeroExtS R3,R3,#+28,#+28
   \       0x70   0x0F1B             LSRS     R3,R3,#+28
   \       0x72   0x7293             STRB     R3,[R2, #+10]
    745            /* Get the FMI */
    746            RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
   \       0x74   0x000B             MOVS     R3,R1
   \       0x76   0xB2DB             UXTB     R3,R3
   \       0x78   0x2410             MOVS     R4,#+16
   \       0x7A   0x4363             MULS     R3,R4,R3
   \       0x7C   0x18C3             ADDS     R3,R0,R3
   \       0x7E   0x24DA             MOVS     R4,#+218
   \       0x80   0x0064             LSLS     R4,R4,#+1        ;; #+436
   \       0x82   0x591B             LDR      R3,[R3, R4]
   \       0x84   0x0A1B             LSRS     R3,R3,#+8
   \       0x86   0x74D3             STRB     R3,[R2, #+19]
    747            /* Get the data field */
    748            RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
   \       0x88   0x000B             MOVS     R3,R1
   \       0x8A   0xB2DB             UXTB     R3,R3
   \       0x8C   0x2410             MOVS     R4,#+16
   \       0x8E   0x4363             MULS     R3,R4,R3
   \       0x90   0x18C3             ADDS     R3,R0,R3
   \       0x92   0x24DC             MOVS     R4,#+220
   \       0x94   0x0064             LSLS     R4,R4,#+1        ;; #+440
   \       0x96   0x591B             LDR      R3,[R3, R4]
   \       0x98   0x72D3             STRB     R3,[R2, #+11]
    749            RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
   \       0x9A   0x000B             MOVS     R3,R1
   \       0x9C   0xB2DB             UXTB     R3,R3
   \       0x9E   0x2410             MOVS     R4,#+16
   \       0xA0   0x4363             MULS     R3,R4,R3
   \       0xA2   0x18C3             ADDS     R3,R0,R3
   \       0xA4   0x24DC             MOVS     R4,#+220
   \       0xA6   0x0064             LSLS     R4,R4,#+1        ;; #+440
   \       0xA8   0x591B             LDR      R3,[R3, R4]
   \       0xAA   0x0A1B             LSRS     R3,R3,#+8
   \       0xAC   0x7313             STRB     R3,[R2, #+12]
    750            RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
   \       0xAE   0x000B             MOVS     R3,R1
   \       0xB0   0xB2DB             UXTB     R3,R3
   \       0xB2   0x2410             MOVS     R4,#+16
   \       0xB4   0x4363             MULS     R3,R4,R3
   \       0xB6   0x18C3             ADDS     R3,R0,R3
   \       0xB8   0x24DC             MOVS     R4,#+220
   \       0xBA   0x0064             LSLS     R4,R4,#+1        ;; #+440
   \       0xBC   0x591B             LDR      R3,[R3, R4]
   \       0xBE   0x0C1B             LSRS     R3,R3,#+16
   \       0xC0   0x7353             STRB     R3,[R2, #+13]
    751            RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
   \       0xC2   0x000B             MOVS     R3,R1
   \       0xC4   0xB2DB             UXTB     R3,R3
   \       0xC6   0x2410             MOVS     R4,#+16
   \       0xC8   0x4363             MULS     R3,R4,R3
   \       0xCA   0x18C3             ADDS     R3,R0,R3
   \       0xCC   0x24DC             MOVS     R4,#+220
   \       0xCE   0x0064             LSLS     R4,R4,#+1        ;; #+440
   \       0xD0   0x591B             LDR      R3,[R3, R4]
   \       0xD2   0x0E1B             LSRS     R3,R3,#+24
   \       0xD4   0x7393             STRB     R3,[R2, #+14]
    752            RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
   \       0xD6   0x000B             MOVS     R3,R1
   \       0xD8   0xB2DB             UXTB     R3,R3
   \       0xDA   0x2410             MOVS     R4,#+16
   \       0xDC   0x4363             MULS     R3,R4,R3
   \       0xDE   0x18C3             ADDS     R3,R0,R3
   \       0xE0   0x24DE             MOVS     R4,#+222
   \       0xE2   0x0064             LSLS     R4,R4,#+1        ;; #+444
   \       0xE4   0x591B             LDR      R3,[R3, R4]
   \       0xE6   0x73D3             STRB     R3,[R2, #+15]
    753            RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
   \       0xE8   0x000B             MOVS     R3,R1
   \       0xEA   0xB2DB             UXTB     R3,R3
   \       0xEC   0x2410             MOVS     R4,#+16
   \       0xEE   0x4363             MULS     R3,R4,R3
   \       0xF0   0x18C3             ADDS     R3,R0,R3
   \       0xF2   0x24DE             MOVS     R4,#+222
   \       0xF4   0x0064             LSLS     R4,R4,#+1        ;; #+444
   \       0xF6   0x591B             LDR      R3,[R3, R4]
   \       0xF8   0x0A1B             LSRS     R3,R3,#+8
   \       0xFA   0x7413             STRB     R3,[R2, #+16]
    754            RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
   \       0xFC   0x000B             MOVS     R3,R1
   \       0xFE   0xB2DB             UXTB     R3,R3
   \      0x100   0x2410             MOVS     R4,#+16
   \      0x102   0x4363             MULS     R3,R4,R3
   \      0x104   0x18C3             ADDS     R3,R0,R3
   \      0x106   0x24DE             MOVS     R4,#+222
   \      0x108   0x0064             LSLS     R4,R4,#+1        ;; #+444
   \      0x10A   0x591B             LDR      R3,[R3, R4]
   \      0x10C   0x0C1B             LSRS     R3,R3,#+16
   \      0x10E   0x7453             STRB     R3,[R2, #+17]
    755            RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
   \      0x110   0x000B             MOVS     R3,R1
   \      0x112   0xB2DB             UXTB     R3,R3
   \      0x114   0x2410             MOVS     R4,#+16
   \      0x116   0x4363             MULS     R3,R4,R3
   \      0x118   0x18C3             ADDS     R3,R0,R3
   \      0x11A   0x24DE             MOVS     R4,#+222
   \      0x11C   0x0064             LSLS     R4,R4,#+1        ;; #+444
   \      0x11E   0x591B             LDR      R3,[R3, R4]
   \      0x120   0x0E1B             LSRS     R3,R3,#+24
   \      0x122   0x7493             STRB     R3,[R2, #+18]
    756            /* Release the FIFO */
    757            /* Release FIFO0 */
    758            if (FIFONumber == CAN_FIFO0)
   \      0x124   0xB2C9             UXTB     R1,R1
   \      0x126   0x2900             CMP      R1,#+0
   \      0x128   0xD104             BNE      ??CAN_Receive_2
    759            {
    760              CANx->RF0R |= CAN_RF0R_RFOM0;
   \      0x12A   0x68C1             LDR      R1,[R0, #+12]
   \      0x12C   0x2220             MOVS     R2,#+32
   \      0x12E   0x430A             ORRS     R2,R2,R1
   \      0x130   0x60C2             STR      R2,[R0, #+12]
   \      0x132   0xE003             B        ??CAN_Receive_3
    761            }
    762            /* Release FIFO1 */
    763            else /* FIFONumber == CAN_FIFO1 */
    764            {
    765              CANx->RF1R |= CAN_RF1R_RFOM1;
   \                     ??CAN_Receive_2: (+1)
   \      0x134   0x6901             LDR      R1,[R0, #+16]
   \      0x136   0x2220             MOVS     R2,#+32
   \      0x138   0x430A             ORRS     R2,R2,R1
   \      0x13A   0x6102             STR      R2,[R0, #+16]
    766            }
    767          }
   \                     ??CAN_Receive_3: (+1)
   \      0x13C   0xBD10             POP      {R4,PC}          ;; return
    768          
    769          /**
    770            * @brief  Releases the specified receive FIFO.
    771            * @param  CANx: where x can be 1 to select the CAN peripheral.
    772            * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
    773            * @retval None
    774            */

   \                                 In section .text, align 2, keep-with-next
    775          void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
    776          {
   \                     CAN_FIFORelease: (+1)
   \        0x0   0xB500             PUSH     {LR}
    777            /* Check the parameters */
    778            assert_param(IS_CAN_ALL_PERIPH(CANx));
    779            assert_param(IS_CAN_FIFO(FIFONumber));
    780            /* Release FIFO0 */
    781            if (FIFONumber == CAN_FIFO0)
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD104             BNE      ??CAN_FIFORelease_0
    782            {
    783              CANx->RF0R |= CAN_RF0R_RFOM0;
   \        0x8   0x68C1             LDR      R1,[R0, #+12]
   \        0xA   0x2220             MOVS     R2,#+32
   \        0xC   0x430A             ORRS     R2,R2,R1
   \        0xE   0x60C2             STR      R2,[R0, #+12]
   \       0x10   0xE003             B        ??CAN_FIFORelease_1
    784            }
    785            /* Release FIFO1 */
    786            else /* FIFONumber == CAN_FIFO1 */
    787            {
    788              CANx->RF1R |= CAN_RF1R_RFOM1;
   \                     ??CAN_FIFORelease_0: (+1)
   \       0x12   0x6901             LDR      R1,[R0, #+16]
   \       0x14   0x2220             MOVS     R2,#+32
   \       0x16   0x430A             ORRS     R2,R2,R1
   \       0x18   0x6102             STR      R2,[R0, #+16]
    789            }
    790          }
   \                     ??CAN_FIFORelease_1: (+1)
   \       0x1A   0xBD00             POP      {PC}             ;; return
    791          
    792          /**
    793            * @brief  Returns the number of pending received messages.
    794            * @param  CANx: where x can be 1 to select the CAN peripheral.
    795            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    796            * @retval NbMessage : which is the number of pending message.
    797            */

   \                                 In section .text, align 2, keep-with-next
    798          uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
    799          {
   \                     CAN_MessagePending: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0002             MOVS     R2,R0
    800            uint8_t message_pending=0;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x0003             MOVS     R3,R0
    801            /* Check the parameters */
    802            assert_param(IS_CAN_ALL_PERIPH(CANx));
    803            assert_param(IS_CAN_FIFO(FIFONumber));
    804            if (FIFONumber == CAN_FIFO0)
   \        0x8   0x000B             MOVS     R3,R1
   \        0xA   0xB2DB             UXTB     R3,R3
   \        0xC   0x2B00             CMP      R3,#+0
   \        0xE   0xD103             BNE      ??CAN_MessagePending_0
    805            {
    806              message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
   \       0x10   0x68D0             LDR      R0,[R2, #+12]
   \       0x12   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \       0x14   0x0F80             LSRS     R0,R0,#+30
   \       0x16   0xE006             B        ??CAN_MessagePending_1
    807            }
    808            else if (FIFONumber == CAN_FIFO1)
   \                     ??CAN_MessagePending_0: (+1)
   \       0x18   0xB2C9             UXTB     R1,R1
   \       0x1A   0x2901             CMP      R1,#+1
   \       0x1C   0xD103             BNE      ??CAN_MessagePending_2
    809            {
    810              message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
   \       0x1E   0x6910             LDR      R0,[R2, #+16]
   \       0x20   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \       0x22   0x0F80             LSRS     R0,R0,#+30
   \       0x24   0xE7FF             B        ??CAN_MessagePending_1
    811            }
    812            else
    813            {
    814              message_pending = 0;
    815            }
    816            return message_pending;
   \                     ??CAN_MessagePending_2: (+1)
   \                     ??CAN_MessagePending_1: (+1)
   \       0x26   0xB2C0             UXTB     R0,R0
   \       0x28   0xBD00             POP      {PC}             ;; return
    817          }
    818          /**
    819            * @}
    820            */
    821          
    822          
    823          /** @defgroup CAN_Group4 CAN Operation modes functions
    824           *  @brief    CAN Operation modes functions 
    825           *
    826          @verbatim    
    827           ===============================================================================
    828                              ##### CAN Operation modes functions #####
    829           ===============================================================================  
    830              [..] This section provides functions allowing to select the CAN Operation modes:
    831                   (+) sleep mode.
    832                   (+) normal mode. 
    833                   (+) initialization mode.
    834             
    835          @endverbatim
    836            * @{
    837            */
    838            
    839            
    840          /**
    841            * @brief  Selects the CAN Operation mode.
    842            * @param  CAN_OperatingMode: CAN Operating Mode.
    843            *         This parameter can be one of @ref CAN_OperatingMode_TypeDef enumeration.
    844            * @retval status of the requested mode which can be: 
    845            *         - CAN_ModeStatus_Failed:  CAN failed entering the specific mode 
    846            *         - CAN_ModeStatus_Success: CAN Succeed entering the specific mode 
    847            */

   \                                 In section .text, align 2, keep-with-next
    848          uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
    849          {
   \                     CAN_OperatingModeRequest: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0x000A             MOVS     R2,R1
    850            uint8_t status = CAN_ModeStatus_Failed;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x000B             MOVS     R3,R1
    851            
    852            /* Timeout for INAK or also for SLAK bits*/
    853            uint32_t timeout = INAK_TIMEOUT; 
   \        0x8   0x....             LDR      R3,??DataTable9  ;; 0xffffff
    854          
    855            /* Check the parameters */
    856            assert_param(IS_CAN_ALL_PERIPH(CANx));
    857            assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
    858          
    859            if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
   \        0xA   0x0014             MOVS     R4,R2
   \        0xC   0xB2E4             UXTB     R4,R4
   \        0xE   0x2C00             CMP      R4,#+0
   \       0x10   0xD114             BNE      ??CAN_OperatingModeRequest_0
    860            {
    861              /* Request initialisation */
    862              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
   \       0x12   0x2201             MOVS     R2,#+1
   \       0x14   0x6804             LDR      R4,[R0, #+0]
   \       0x16   0x2502             MOVS     R5,#+2
   \       0x18   0x43AC             BICS     R4,R4,R5
   \       0x1A   0x4314             ORRS     R4,R4,R2
   \       0x1C   0x6004             STR      R4,[R0, #+0]
   \       0x1E   0xE000             B        ??CAN_OperatingModeRequest_1
    863          
    864              /* Wait the acknowledge */
    865              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
    866              {
    867                timeout--;
   \                     ??CAN_OperatingModeRequest_2: (+1)
   \       0x20   0x1E5B             SUBS     R3,R3,#+1
    868              }
   \                     ??CAN_OperatingModeRequest_1: (+1)
   \       0x22   0x2403             MOVS     R4,#+3
   \       0x24   0x6845             LDR      R5,[R0, #+4]
   \       0x26   0x4025             ANDS     R5,R5,R4
   \       0x28   0x2D01             CMP      R5,#+1
   \       0x2A   0xD001             BEQ      ??CAN_OperatingModeRequest_3
   \       0x2C   0x2B00             CMP      R3,#+0
   \       0x2E   0xD1F7             BNE      ??CAN_OperatingModeRequest_2
    869              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
   \                     ??CAN_OperatingModeRequest_3: (+1)
   \       0x30   0x6840             LDR      R0,[R0, #+4]
   \       0x32   0x4004             ANDS     R4,R4,R0
   \       0x34   0x2C01             CMP      R4,#+1
   \       0x36   0xD130             BNE      ??CAN_OperatingModeRequest_4
    870              {
    871                status = CAN_ModeStatus_Failed;
    872              }
    873              else
    874              {
    875                status = CAN_ModeStatus_Success;
   \                     ??CAN_OperatingModeRequest_5: (+1)
   \       0x38   0x0011             MOVS     R1,R2
   \       0x3A   0xE02E             B        ??CAN_OperatingModeRequest_4
    876              }
    877            }
    878            else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
   \                     ??CAN_OperatingModeRequest_0: (+1)
   \       0x3C   0x0014             MOVS     R4,R2
   \       0x3E   0xB2E4             UXTB     R4,R4
   \       0x40   0x2C01             CMP      R4,#+1
   \       0x42   0xD112             BNE      ??CAN_OperatingModeRequest_6
    879            {
    880              /* Request leave initialisation and sleep mode  and enter Normal mode */
    881              CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
   \       0x44   0x6802             LDR      R2,[R0, #+0]
   \       0x46   0x2403             MOVS     R4,#+3
   \       0x48   0x43A2             BICS     R2,R2,R4
   \       0x4A   0x6002             STR      R2,[R0, #+0]
   \       0x4C   0xE000             B        ??CAN_OperatingModeRequest_7
    882          
    883              /* Wait the acknowledge */
    884              while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
    885              {
    886                timeout--;
   \                     ??CAN_OperatingModeRequest_8: (+1)
   \       0x4E   0x1E5B             SUBS     R3,R3,#+1
    887              }
   \                     ??CAN_OperatingModeRequest_7: (+1)
   \       0x50   0x2203             MOVS     R2,#+3
   \       0x52   0x6844             LDR      R4,[R0, #+4]
   \       0x54   0x4014             ANDS     R4,R4,R2
   \       0x56   0x2C00             CMP      R4,#+0
   \       0x58   0xD001             BEQ      ??CAN_OperatingModeRequest_9
   \       0x5A   0x2B00             CMP      R3,#+0
   \       0x5C   0xD1F7             BNE      ??CAN_OperatingModeRequest_8
    888              if ((CANx->MSR & CAN_MODE_MASK) != 0)
   \                     ??CAN_OperatingModeRequest_9: (+1)
   \       0x5E   0x6840             LDR      R0,[R0, #+4]
   \       0x60   0x4002             ANDS     R2,R2,R0
   \       0x62   0x2A00             CMP      R2,#+0
   \       0x64   0xD119             BNE      ??CAN_OperatingModeRequest_4
    889              {
    890                status = CAN_ModeStatus_Failed;
    891              }
    892              else
    893              {
    894                status = CAN_ModeStatus_Success;
   \                     ??CAN_OperatingModeRequest_10: (+1)
   \       0x66   0x2101             MOVS     R1,#+1
   \       0x68   0xE017             B        ??CAN_OperatingModeRequest_4
    895              }
    896            }
    897            else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
   \                     ??CAN_OperatingModeRequest_6: (+1)
   \       0x6A   0xB2D2             UXTB     R2,R2
   \       0x6C   0x2A02             CMP      R2,#+2
   \       0x6E   0xD114             BNE      ??CAN_OperatingModeRequest_11
    898            {
    899              /* Request Sleep mode */
    900              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
   \       0x70   0x6802             LDR      R2,[R0, #+0]
   \       0x72   0x2401             MOVS     R4,#+1
   \       0x74   0x43A2             BICS     R2,R2,R4
   \       0x76   0x2402             MOVS     R4,#+2
   \       0x78   0x4314             ORRS     R4,R4,R2
   \       0x7A   0x6004             STR      R4,[R0, #+0]
   \       0x7C   0xE000             B        ??CAN_OperatingModeRequest_12
    901          
    902              /* Wait the acknowledge */
    903              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
    904              {
    905                timeout--;
   \                     ??CAN_OperatingModeRequest_13: (+1)
   \       0x7E   0x1E5B             SUBS     R3,R3,#+1
    906              }
   \                     ??CAN_OperatingModeRequest_12: (+1)
   \       0x80   0x2203             MOVS     R2,#+3
   \       0x82   0x6844             LDR      R4,[R0, #+4]
   \       0x84   0x4014             ANDS     R4,R4,R2
   \       0x86   0x2C02             CMP      R4,#+2
   \       0x88   0xD001             BEQ      ??CAN_OperatingModeRequest_14
   \       0x8A   0x2B00             CMP      R3,#+0
   \       0x8C   0xD1F7             BNE      ??CAN_OperatingModeRequest_13
    907              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
   \                     ??CAN_OperatingModeRequest_14: (+1)
   \       0x8E   0x6840             LDR      R0,[R0, #+4]
   \       0x90   0x4002             ANDS     R2,R2,R0
   \       0x92   0x2A02             CMP      R2,#+2
   \       0x94   0xD101             BNE      ??CAN_OperatingModeRequest_4
    908              {
    909                status = CAN_ModeStatus_Failed;
    910              }
    911              else
    912              {
    913                status = CAN_ModeStatus_Success;
   \                     ??CAN_OperatingModeRequest_15: (+1)
   \       0x96   0x2101             MOVS     R1,#+1
   \       0x98   0xE7FF             B        ??CAN_OperatingModeRequest_4
    914              }
    915            }
    916            else
    917            {
    918              status = CAN_ModeStatus_Failed;
    919            }
    920          
    921            return  (uint8_t) status;
   \                     ??CAN_OperatingModeRequest_11: (+1)
   \                     ??CAN_OperatingModeRequest_4: (+1)
   \       0x9A   0x0008             MOVS     R0,R1
   \       0x9C   0xB2C0             UXTB     R0,R0
   \       0x9E   0xBD30             POP      {R4,R5,PC}       ;; return
    922          }
    923          
    924          /**
    925            * @brief  Enters the Sleep (low power) mode.
    926            * @param  CANx: where x can be 1 to select the CAN peripheral.
    927            * @retval CAN_Sleep_Ok if sleep entered, CAN_Sleep_Failed otherwise.
    928            */

   \                                 In section .text, align 2, keep-with-next
    929          uint8_t CAN_Sleep(CAN_TypeDef* CANx)
    930          {
   \                     CAN_Sleep: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0001             MOVS     R1,R0
    931            uint8_t sleepstatus = CAN_Sleep_Failed;
   \        0x4   0x2000             MOVS     R0,#+0
    932            
    933            /* Check the parameters */
    934            assert_param(IS_CAN_ALL_PERIPH(CANx));
    935              
    936            /* Request Sleep mode */
    937             CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0x2301             MOVS     R3,#+1
   \        0xA   0x439A             BICS     R2,R2,R3
   \        0xC   0x2302             MOVS     R3,#+2
   \        0xE   0x4313             ORRS     R3,R3,R2
   \       0x10   0x600B             STR      R3,[R1, #+0]
    938             
    939            /* Sleep mode status */
    940            if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
   \       0x12   0x6849             LDR      R1,[R1, #+4]
   \       0x14   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \       0x16   0x0F89             LSRS     R1,R1,#+30
   \       0x18   0x2902             CMP      R1,#+2
   \       0x1A   0xD100             BNE      ??CAN_Sleep_0
    941            {
    942              /* Sleep mode not entered */
    943              sleepstatus =  CAN_Sleep_Ok;
   \       0x1C   0x2001             MOVS     R0,#+1
    944            }
    945            /* return sleep mode status */
    946             return (uint8_t)sleepstatus;
   \                     ??CAN_Sleep_0: (+1)
   \       0x1E   0xB2C0             UXTB     R0,R0
   \       0x20   0xBD00             POP      {PC}             ;; return
    947          }
    948          
    949          /**
    950            * @brief  Wakes up the CAN peripheral from sleep mode .
    951            * @param  CANx: where x can be 1 to select the CAN peripheral.
    952            * @retval CAN_WakeUp_Ok if sleep mode left, CAN_WakeUp_Failed otherwise.
    953            */

   \                                 In section .text, align 2, keep-with-next
    954          uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
    955          {
   \                     CAN_WakeUp: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0001             MOVS     R1,R0
    956            uint32_t wait_slak = SLAK_TIMEOUT;
   \        0x4   0x....             LDR      R2,??DataTable9  ;; 0xffffff
    957            uint8_t wakeupstatus = CAN_WakeUp_Failed;
   \        0x6   0x2000             MOVS     R0,#+0
    958            
    959            /* Check the parameters */
    960            assert_param(IS_CAN_ALL_PERIPH(CANx));
    961              
    962            /* Wake up request */
    963            CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
   \        0x8   0x680B             LDR      R3,[R1, #+0]
   \        0xA   0x2402             MOVS     R4,#+2
   \        0xC   0x43A3             BICS     R3,R3,R4
   \        0xE   0x600B             STR      R3,[R1, #+0]
   \       0x10   0xE000             B        ??CAN_WakeUp_0
    964              
    965            /* Sleep mode status */
    966            while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
    967            {
    968             wait_slak--;
   \                     ??CAN_WakeUp_1: (+1)
   \       0x12   0x1E52             SUBS     R2,R2,#+1
    969            }
   \                     ??CAN_WakeUp_0: (+1)
   \       0x14   0x2302             MOVS     R3,#+2
   \       0x16   0x684C             LDR      R4,[R1, #+4]
   \       0x18   0x401C             ANDS     R4,R4,R3
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD001             BEQ      ??CAN_WakeUp_2
   \       0x1E   0x2A00             CMP      R2,#+0
   \       0x20   0xD1F7             BNE      ??CAN_WakeUp_1
    970            if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
   \                     ??CAN_WakeUp_2: (+1)
   \       0x22   0x6849             LDR      R1,[R1, #+4]
   \       0x24   0x400B             ANDS     R3,R3,R1
   \       0x26   0x2B00             CMP      R3,#+0
   \       0x28   0xD100             BNE      ??CAN_WakeUp_3
    971            {
    972             /* wake up done : Sleep mode exited */
    973              wakeupstatus = CAN_WakeUp_Ok;
   \       0x2A   0x2001             MOVS     R0,#+1
    974            }
    975            /* return wakeup status */
    976            return (uint8_t)wakeupstatus;
   \                     ??CAN_WakeUp_3: (+1)
   \       0x2C   0xB2C0             UXTB     R0,R0
   \       0x2E   0xBD10             POP      {R4,PC}          ;; return
    977          }
    978          /**
    979            * @}
    980            */
    981          
    982          
    983          /** @defgroup CAN_Group5 CAN Bus Error management functions
    984           *  @brief    CAN Bus Error management functions 
    985           *
    986          @verbatim    
    987           ===============================================================================
    988                            ##### CAN Bus Error management functions #####
    989           ===============================================================================  
    990              [..] This section provides functions allowing to 
    991                   (+) Return the CANx's last error code (LEC).
    992                   (+) Return the CANx Receive Error Counter (REC).
    993                   (+) Return the LSB of the 9-bit CANx Transmit Error Counter(TEC).
    994              [..]
    995                   (@) If TEC is greater than 255, The CAN is in bus-off state.
    996                   (@) If REC or TEC are greater than 96, an Error warning flag occurs.
    997                   (@) If REC or TEC are greater than 127, an Error Passive Flag occurs.
    998                                  
    999          @endverbatim
   1000            * @{
   1001            */
   1002            
   1003          /**
   1004            * @brief  Returns the CANx's last error code (LEC).
   1005            * @param  CANx: where x can be 1 to select the CAN peripheral.
   1006            * @retval Error code: 
   1007            *          - CAN_ERRORCODE_NoErr: No Error  
   1008            *          - CAN_ERRORCODE_StuffErr: Stuff Error
   1009            *          - CAN_ERRORCODE_FormErr: Form Error
   1010            *          - CAN_ERRORCODE_ACKErr : Acknowledgment Error
   1011            *          - CAN_ERRORCODE_BitRecessiveErr: Bit Recessive Error
   1012            *          - CAN_ERRORCODE_BitDominantErr: Bit Dominant Error
   1013            *          - CAN_ERRORCODE_CRCErr: CRC Error
   1014            *          - CAN_ERRORCODE_SoftwareSetErr: Software Set Error  
   1015            */

   \                                 In section .text, align 2, keep-with-next
   1016          uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
   1017          {
   1018            uint8_t errorcode=0;
   \                     CAN_GetLastErrorCode: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   1019            
   1020            /* Check the parameters */
   1021            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1022            
   1023            /* Get the error code*/
   1024            errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
   \        0x2   0x6981             LDR      R1,[R0, #+24]
   \        0x4   0x2070             MOVS     R0,#+112
   \        0x6   0x4008             ANDS     R0,R0,R1
   1025            
   1026            /* Return the error code*/
   1027            return errorcode;
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0x4770             BX       LR               ;; return
   1028          }
   1029          
   1030          /**
   1031            * @brief  Returns the CANx Receive Error Counter (REC).
   1032            * @note   In case of an error during reception, this counter is incremented 
   1033            *         by 1 or by 8 depending on the error condition as defined by the CAN 
   1034            *         standard. After every successful reception, the counter is 
   1035            *         decremented by 1 or reset to 120 if its value was higher than 128. 
   1036            *         When the counter value exceeds 127, the CAN controller enters the 
   1037            *         error passive state.  
   1038            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.  
   1039            * @retval CAN Receive Error Counter. 
   1040            */

   \                                 In section .text, align 2, keep-with-next
   1041          uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
   1042          {
   1043            uint8_t counter=0;
   \                     CAN_GetReceiveErrorCounter: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   1044            
   1045            /* Check the parameters */
   1046            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1047            
   1048            /* Get the Receive Error Counter*/
   1049            counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
   \        0x2   0x6980             LDR      R0,[R0, #+24]
   \        0x4   0x0E00             LSRS     R0,R0,#+24
   1050            
   1051            /* Return the Receive Error Counter*/
   1052            return counter;
   \        0x6   0xB2C0             UXTB     R0,R0
   \        0x8   0x4770             BX       LR               ;; return
   1053          }
   1054          
   1055          
   1056          /**
   1057            * @brief  Returns the LSB of the 9-bit CANx Transmit Error Counter(TEC).
   1058            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1059            * @retval LSB of the 9-bit CAN Transmit Error Counter. 
   1060            */

   \                                 In section .text, align 2, keep-with-next
   1061          uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
   1062          {
   1063            uint8_t counter=0;
   \                     CAN_GetLSBTransmitErrorCounter: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   1064            
   1065            /* Check the parameters */
   1066            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1067            
   1068            /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1069            counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
   \        0x2   0x6980             LDR      R0,[R0, #+24]
   \        0x4   0x0C00             LSRS     R0,R0,#+16
   1070            
   1071            /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1072            return counter;
   \        0x6   0xB2C0             UXTB     R0,R0
   \        0x8   0x4770             BX       LR               ;; return
   1073          }
   1074          /**
   1075            * @}
   1076            */
   1077          
   1078          /** @defgroup CAN_Group6 Interrupts and flags management functions
   1079           *  @brief   Interrupts and flags management functions
   1080           *
   1081          @verbatim   
   1082           ===============================================================================
   1083                        ##### Interrupts and flags management functions #####
   1084           ===============================================================================  
   1085              [..] This section provides functions allowing to configure the CAN Interrupts 
   1086                   and to get the status and clear flags and Interrupts pending bits.
   1087              [..] The CAN provides 14 Interrupts sources and 15 Flags:
   1088             
   1089            *** Flags ***
   1090            =============
   1091              [..] The 15 flags can be divided on 4 groups: 
   1092                   (+) Transmit Flags:
   1093                       (++) CAN_FLAG_RQCP0. 
   1094                       (++) CAN_FLAG_RQCP1. 
   1095                       (++) CAN_FLAG_RQCP2: Request completed MailBoxes 0, 1 and 2  Flags
   1096                            Set when when the last request (transmit or abort) has 
   1097                            been performed. 
   1098                   (+) Receive Flags:
   1099                       (++) CAN_FLAG_FMP0.
   1100                       (++) CAN_FLAG_FMP1: FIFO 0 and 1 Message Pending Flags; 
   1101                            Set to signal that messages are pending in the receive FIFO.
   1102                            These Flags are cleared only by hardware. 
   1103                       (++) CAN_FLAG_FF0.
   1104                       (++) CAN_FLAG_FF1: FIFO 0 and 1 Full Flags; 
   1105                            Set when three messages are stored in the selected FIFO.                        
   1106                       (++) CAN_FLAG_FOV0.              
   1107                       (++) CAN_FLAG_FOV1: FIFO 0 and 1 Overrun Flags; 
   1108                            Set when a new message has been received and passed the filter 
   1109                            while the FIFO was full.         
   1110                   (+) Operating Mode Flags: 
   1111                       (++) CAN_FLAG_WKU: Wake up Flag; 
   1112                            Set to signal that a SOF bit has been detected while the CAN 
   1113                            hardware was in Sleep mode. 
   1114                       (++) CAN_FLAG_SLAK: Sleep acknowledge Flag;
   1115                            Set to signal that the CAN has entered Sleep Mode. 
   1116                   (+) Error Flags:  
   1117                       (++) CAN_FLAG_EWG: Error Warning Flag;
   1118                            Set when the warning limit has been reached (Receive Error Counter 
   1119                            or Transmit Error Counter greater than 96). 
   1120                            This Flag is cleared only by hardware.
   1121                       (++) CAN_FLAG_EPV: Error Passive Flag;
   1122                            Set when the Error Passive limit has been reached (Receive Error 
   1123                            Counter or Transmit Error Counter greater than 127).
   1124                            This Flag is cleared only by hardware.
   1125                       (++) CAN_FLAG_BOF: Bus-Off Flag;
   1126                            Set when CAN enters the bus-off state. The bus-off state is 
   1127                            entered on TEC overflow, greater than 255.
   1128                            This Flag is cleared only by hardware.
   1129                       (++) CAN_FLAG_LEC: Last error code Flag;
   1130                            Set If a message has been transferred (reception or transmission) 
   1131                            with error, and the error code is hold.                      
   1132            
   1133            *** Interrupts ***
   1134            ==================
   1135              [..] The 14 interrupts can be divided on 4 groups: 
   1136                   (+) Transmit interrupt:   
   1137                       (++) CAN_IT_TME: Transmit mailbox empty Interrupt;
   1138                            If enabled, this interrupt source is pending when no transmit 
   1139                            request are pending for Tx mailboxes.      
   1140                   (+) Receive Interrupts:   
   1141                       (++) CAN_IT_FMP0.
   1142                       (++) CAN_IT_FMP1: FIFO 0 and FIFO1 message pending Interrupts;
   1143                            If enabled, these interrupt sources are pending when messages 
   1144                            are pending in the receive FIFO.
   1145                            The corresponding interrupt pending bits are cleared only by hardware.
   1146                       (++) CAN_IT_FF0.              
   1147                       (++) CAN_IT_FF1: FIFO 0 and FIFO1 full Interrupts;
   1148                            If enabled, these interrupt sources are pending when three messages 
   1149                            are stored in the selected FIFO.
   1150                       (++) CAN_IT_FOV0.        
   1151                       (++) CAN_IT_FOV1: FIFO 0 and FIFO1 overrun Interrupts;        
   1152                            If enabled, these interrupt sources are pending when a new message 
   1153                            has been received and passed the filter while the FIFO was full.
   1154                   (+) Operating Mode Interrupts:    
   1155                       (++) CAN_IT_WKU: Wake-up Interrupt;
   1156                            If enabled, this interrupt source is pending when a SOF bit has 
   1157                            been detected while the CAN hardware was in Sleep mode.
   1158                       (++) CAN_IT_SLK: Sleep acknowledge Interrupt:
   1159                            If enabled, this interrupt source is pending when the CAN has 
   1160                            entered Sleep Mode.       
   1161                   (+) Error Interrupts:     
   1162                       (++) CAN_IT_EWG: Error warning Interrupt; 
   1163                            If enabled, this interrupt source is pending when the warning limit 
   1164                            has been reached (Receive Error Counter or Transmit Error Counter=96). 
   1165                       (++) CAN_IT_EPV: Error passive Interrupt;        
   1166                            If enabled, this interrupt source is pending when the Error Passive 
   1167                            limit has been reached (Receive Error Counter or Transmit Error Counter>127).
   1168                       (++) CAN_IT_BOF: Bus-off Interrupt;
   1169                            If enabled, this interrupt source is pending when CAN enters 
   1170                            the bus-off state. The bus-off state is entered on TEC overflow, 
   1171                            greater than 255.
   1172                            This Flag is cleared only by hardware.
   1173                       (++) CAN_IT_LEC: Last error code Interrupt;        
   1174                            If enabled, this interrupt source is pending when a message has 
   1175                            been transferred (reception or transmission) with error and the 
   1176                            error code is hold.
   1177                       (++) CAN_IT_ERR: Error Interrupt;
   1178                            If enabled, this interrupt source is pending when an error condition 
   1179                            is pending.      
   1180              [..] Managing the CAN controller events: 
   1181                   The user should identify which mode will be used in his application to manage 
   1182                   the CAN controller events: Polling mode or Interrupt mode.
   1183                   (+) In the Polling Mode it is advised to use the following functions:
   1184                       (++) CAN_GetFlagStatus() : to check if flags events occur. 
   1185                       (++) CAN_ClearFlag()     : to clear the flags events.
   1186                   (+) In the Interrupt Mode it is advised to use the following functions:
   1187                       (++) CAN_ITConfig()       : to enable or disable the interrupt source.
   1188                       (++) CAN_GetITStatus()    : to check if Interrupt occurs.
   1189                       (++) CAN_ClearITPendingBit() : to clear the Interrupt pending Bit 
   1190                            (corresponding Flag).
   1191                            This function has no impact on CAN_IT_FMP0 and CAN_IT_FMP1 Interrupts 
   1192                            pending bits since there are cleared only by hardware. 
   1193            
   1194          @endverbatim
   1195            * @{
   1196            */ 
   1197          /**
   1198            * @brief  Enables or disables the specified CANx interrupts.
   1199            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1200            * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.
   1201            *          This parameter can be: 
   1202            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1203            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1204            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1205            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1206            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1207            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1208            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1209            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1210            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1211            *            @arg CAN_IT_EWG: Error warning Interrupt
   1212            *            @arg CAN_IT_EPV: Error passive Interrupt
   1213            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1214            *            @arg CAN_IT_LEC: Last error code Interrupt
   1215            *            @arg CAN_IT_ERR: Error Interrupt
   1216            * @param  NewState: new state of the CAN interrupts.
   1217            *          This parameter can be: ENABLE or DISABLE.
   1218            * @retval None
   1219            */

   \                                 In section .text, align 2, keep-with-next
   1220          void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
   1221          {
   \                     CAN_ITConfig: (+1)
   \        0x0   0xB500             PUSH     {LR}
   1222            /* Check the parameters */
   1223            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1224            assert_param(IS_CAN_IT(CAN_IT));
   1225            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1226          
   1227            if (NewState != DISABLE)
   \        0x2   0xB2D2             UXTB     R2,R2
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD003             BEQ      ??CAN_ITConfig_0
   1228            {
   1229              /* Enable the selected CANx interrupt */
   1230              CANx->IER |= CAN_IT;
   \        0x8   0x6942             LDR      R2,[R0, #+20]
   \        0xA   0x4311             ORRS     R1,R1,R2
   \        0xC   0x6141             STR      R1,[R0, #+20]
   \        0xE   0xE002             B        ??CAN_ITConfig_1
   1231            }
   1232            else
   1233            {
   1234              /* Disable the selected CANx interrupt */
   1235              CANx->IER &= ~CAN_IT;
   \                     ??CAN_ITConfig_0: (+1)
   \       0x10   0x6942             LDR      R2,[R0, #+20]
   \       0x12   0x438A             BICS     R2,R2,R1
   \       0x14   0x6142             STR      R2,[R0, #+20]
   1236            }
   1237          }
   \                     ??CAN_ITConfig_1: (+1)
   \       0x16   0xBD00             POP      {PC}             ;; return
   1238          /**
   1239            * @brief  Checks whether the specified CAN flag is set or not.
   1240            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1241            * @param  CAN_FLAG: specifies the flag to check.
   1242            *          This parameter can be one of the following values:
   1243            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1244            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1245            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag
   1246            *            @arg CAN_FLAG_FMP0: FIFO 0 Message Pending Flag   
   1247            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1248            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag 
   1249            *            @arg CAN_FLAG_FMP1: FIFO 1 Message Pending Flag   
   1250            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1251            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1252            *            @arg CAN_FLAG_WKU: Wake up Flag
   1253            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag 
   1254            *            @arg CAN_FLAG_EWG: Error Warning Flag
   1255            *            @arg CAN_FLAG_EPV: Error Passive Flag  
   1256            *            @arg CAN_FLAG_BOF: Bus-Off Flag    
   1257            *            @arg CAN_FLAG_LEC: Last error code Flag      
   1258            * @retval The new state of CAN_FLAG (SET or RESET).
   1259            */

   \                                 In section .text, align 2, keep-with-next
   1260          FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1261          {
   \                     CAN_GetFlagStatus: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0002             MOVS     R2,R0
   1262            FlagStatus bitstatus = RESET;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x0003             MOVS     R3,R0
   1263            
   1264            /* Check the parameters */
   1265            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1266            assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
   1267            
   1268          
   1269            if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
   \        0x8   0x23F0             MOVS     R3,#+240
   \        0xA   0x041B             LSLS     R3,R3,#+16       ;; #+15728640
   \        0xC   0x400B             ANDS     R3,R3,R1
   \        0xE   0x2B00             CMP      R3,#+0
   \       0x10   0xD008             BEQ      ??CAN_GetFlagStatus_0
   1270            { 
   1271              /* Check the status of the specified CAN flag */
   1272              if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \       0x12   0x6992             LDR      R2,[R2, #+24]
   \       0x14   0x4011             ANDS     R1,R1,R2
   \       0x16   0x0309             LSLS     R1,R1,#+12       ;; ZeroExtS R1,R1,#+12,#+12
   \       0x18   0x0B09             LSRS     R1,R1,#+12
   \       0x1A   0x2900             CMP      R1,#+0
   \       0x1C   0xD001             BEQ      ??CAN_GetFlagStatus_1
   1273              { 
   1274                /* CAN_FLAG is set */
   1275                bitstatus = SET;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xE029             B        ??CAN_GetFlagStatus_2
   1276              }
   1277              else
   1278              { 
   1279                /* CAN_FLAG is reset */
   1280                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_1: (+1)
   \       0x22   0xE028             B        ??CAN_GetFlagStatus_2
   1281              }
   1282            }
   1283            else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_0: (+1)
   \       0x24   0x01CB             LSLS     R3,R1,#+7
   \       0x26   0xD508             BPL      ??CAN_GetFlagStatus_3
   1284            { 
   1285              /* Check the status of the specified CAN flag */
   1286              if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \       0x28   0x6852             LDR      R2,[R2, #+4]
   \       0x2A   0x4011             ANDS     R1,R1,R2
   \       0x2C   0x0309             LSLS     R1,R1,#+12       ;; ZeroExtS R1,R1,#+12,#+12
   \       0x2E   0x0B09             LSRS     R1,R1,#+12
   \       0x30   0x2900             CMP      R1,#+0
   \       0x32   0xD001             BEQ      ??CAN_GetFlagStatus_4
   1287              { 
   1288                /* CAN_FLAG is set */
   1289                bitstatus = SET;
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xE01E             B        ??CAN_GetFlagStatus_2
   1290              }
   1291              else
   1292              { 
   1293                /* CAN_FLAG is reset */
   1294                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_4: (+1)
   \       0x38   0xE01D             B        ??CAN_GetFlagStatus_2
   1295              }
   1296            }
   1297            else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_3: (+1)
   \       0x3A   0x010B             LSLS     R3,R1,#+4
   \       0x3C   0xD508             BPL      ??CAN_GetFlagStatus_5
   1298            { 
   1299              /* Check the status of the specified CAN flag */
   1300              if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \       0x3E   0x6892             LDR      R2,[R2, #+8]
   \       0x40   0x4011             ANDS     R1,R1,R2
   \       0x42   0x0309             LSLS     R1,R1,#+12       ;; ZeroExtS R1,R1,#+12,#+12
   \       0x44   0x0B09             LSRS     R1,R1,#+12
   \       0x46   0x2900             CMP      R1,#+0
   \       0x48   0xD001             BEQ      ??CAN_GetFlagStatus_6
   1301              { 
   1302                /* CAN_FLAG is set */
   1303                bitstatus = SET;
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0xE013             B        ??CAN_GetFlagStatus_2
   1304              }
   1305              else
   1306              { 
   1307                /* CAN_FLAG is reset */
   1308                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_6: (+1)
   \       0x4E   0xE012             B        ??CAN_GetFlagStatus_2
   1309              }
   1310            }
   1311            else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_5: (+1)
   \       0x50   0x018B             LSLS     R3,R1,#+6
   \       0x52   0xD508             BPL      ??CAN_GetFlagStatus_7
   1312            { 
   1313              /* Check the status of the specified CAN flag */
   1314              if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \       0x54   0x68D2             LDR      R2,[R2, #+12]
   \       0x56   0x4011             ANDS     R1,R1,R2
   \       0x58   0x0309             LSLS     R1,R1,#+12       ;; ZeroExtS R1,R1,#+12,#+12
   \       0x5A   0x0B09             LSRS     R1,R1,#+12
   \       0x5C   0x2900             CMP      R1,#+0
   \       0x5E   0xD001             BEQ      ??CAN_GetFlagStatus_8
   1315              { 
   1316                /* CAN_FLAG is set */
   1317                bitstatus = SET;
   \       0x60   0x2001             MOVS     R0,#+1
   \       0x62   0xE008             B        ??CAN_GetFlagStatus_2
   1318              }
   1319              else
   1320              { 
   1321                /* CAN_FLAG is reset */
   1322                bitstatus = RESET;
   \                     ??CAN_GetFlagStatus_8: (+1)
   \       0x64   0xE007             B        ??CAN_GetFlagStatus_2
   1323              }
   1324            }
   1325            else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
   1326            { 
   1327              /* Check the status of the specified CAN flag */
   1328              if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   \                     ??CAN_GetFlagStatus_7: (+1)
   \       0x66   0x6912             LDR      R2,[R2, #+16]
   \       0x68   0x4011             ANDS     R1,R1,R2
   \       0x6A   0x0309             LSLS     R1,R1,#+12       ;; ZeroExtS R1,R1,#+12,#+12
   \       0x6C   0x0B09             LSRS     R1,R1,#+12
   \       0x6E   0x2900             CMP      R1,#+0
   \       0x70   0xD001             BEQ      ??CAN_GetFlagStatus_9
   1329              { 
   1330                /* CAN_FLAG is set */
   1331                bitstatus = SET;
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0xE7FF             B        ??CAN_GetFlagStatus_2
   1332              }
   1333              else
   1334              { 
   1335                /* CAN_FLAG is reset */
   1336                bitstatus = RESET;
   1337              }
   1338            }
   1339            /* Return the CAN_FLAG status */
   1340            return  bitstatus;
   \                     ??CAN_GetFlagStatus_9: (+1)
   \                     ??CAN_GetFlagStatus_2: (+1)
   \       0x76   0xB2C0             UXTB     R0,R0
   \       0x78   0xBD00             POP      {PC}             ;; return
   1341          }
   1342          
   1343          /**
   1344            * @brief  Clears the CAN's pending flags.
   1345            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1346            * @param  CAN_FLAG: specifies the flag to clear.
   1347            *          This parameter can be one of the following values:
   1348            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1349            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1350            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag 
   1351            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1352            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag  
   1353            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1354            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1355            *            @arg CAN_FLAG_WKU: Wake up Flag
   1356            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag    
   1357            *            @arg CAN_FLAG_LEC: Last error code Flag        
   1358            * @retval None
   1359            */

   \                                 In section .text, align 2, keep-with-next
   1360          void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1361          {
   \                     CAN_ClearFlag: (+1)
   \        0x0   0xB500             PUSH     {LR}
   1362            uint32_t flagtmp=0;
   \        0x2   0x2300             MOVS     R3,#+0
   \        0x4   0x001A             MOVS     R2,R3
   1363            /* Check the parameters */
   1364            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1365            assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
   1366            
   1367            if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
   \        0x6   0x....             LDR      R2,??DataTable11  ;; 0x30f00070
   \        0x8   0x4291             CMP      R1,R2
   \        0xA   0xD101             BNE      ??CAN_ClearFlag_0
   1368            {
   1369              /* Clear the selected CAN flags */
   1370              CANx->ESR = (uint32_t)RESET;
   \        0xC   0x6183             STR      R3,[R0, #+24]
   \        0xE   0xE00E             B        ??CAN_ClearFlag_1
   1371            }
   1372            else /* MSR or TSR or RF0R or RF1R */
   1373            {
   1374              flagtmp = CAN_FLAG & 0x000FFFFF;
   \                     ??CAN_ClearFlag_0: (+1)
   \       0x10   0x030A             LSLS     R2,R1,#+12       ;; ZeroExtS R2,R1,#+12,#+12
   \       0x12   0x0B12             LSRS     R2,R2,#+12
   1375          
   1376              if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
   \       0x14   0x018B             LSLS     R3,R1,#+6
   \       0x16   0xD501             BPL      ??CAN_ClearFlag_2
   1377              {
   1378                /* Receive Flags */
   1379                CANx->RF0R = (uint32_t)(flagtmp);
   \       0x18   0x60C2             STR      R2,[R0, #+12]
   \       0x1A   0xE008             B        ??CAN_ClearFlag_1
   1380              }
   1381              else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
   \                     ??CAN_ClearFlag_2: (+1)
   \       0x1C   0x014B             LSLS     R3,R1,#+5
   \       0x1E   0xD501             BPL      ??CAN_ClearFlag_3
   1382              {
   1383                /* Receive Flags */
   1384                CANx->RF1R = (uint32_t)(flagtmp);
   \       0x20   0x6102             STR      R2,[R0, #+16]
   \       0x22   0xE004             B        ??CAN_ClearFlag_1
   1385              }
   1386              else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
   \                     ??CAN_ClearFlag_3: (+1)
   \       0x24   0x0109             LSLS     R1,R1,#+4
   \       0x26   0xD501             BPL      ??CAN_ClearFlag_4
   1387              {
   1388                /* Transmit Flags */
   1389                CANx->TSR = (uint32_t)(flagtmp);
   \       0x28   0x6082             STR      R2,[R0, #+8]
   \       0x2A   0xE000             B        ??CAN_ClearFlag_1
   1390              }
   1391              else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
   1392              {
   1393                /* Operating mode Flags */
   1394                CANx->MSR = (uint32_t)(flagtmp);
   \                     ??CAN_ClearFlag_4: (+1)
   \       0x2C   0x6042             STR      R2,[R0, #+4]
   1395              }
   1396            }
   1397          }
   \                     ??CAN_ClearFlag_1: (+1)
   \       0x2E   0xBD00             POP      {PC}             ;; return
   1398          
   1399          /**
   1400            * @brief  Checks whether the specified CANx interrupt has occurred or not.
   1401            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1402            * @param  CAN_IT: specifies the CAN interrupt source to check.
   1403            *          This parameter can be one of the following values:
   1404            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1405            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1406            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1407            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1408            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1409            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1410            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1411            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1412            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1413            *            @arg CAN_IT_EWG: Error warning Interrupt
   1414            *            @arg CAN_IT_EPV: Error passive Interrupt
   1415            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1416            *            @arg CAN_IT_LEC: Last error code Interrupt
   1417            *            @arg CAN_IT_ERR: Error Interrupt
   1418            * @retval The current state of CAN_IT (SET or RESET).
   1419            */

   \                                 In section .text, align 2, keep-with-next
   1420          ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1421          {
   \                     CAN_GetITStatus: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x0002             MOVS     R2,R0
   1422            ITStatus itstatus = RESET;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x0003             MOVS     R3,R0
   1423            /* Check the parameters */
   1424            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1425            assert_param(IS_CAN_IT(CAN_IT));
   1426            
   1427            /* check the interrupt enable bit */
   1428           if((CANx->IER & CAN_IT) != RESET)
   \        0x8   0x6953             LDR      R3,[R2, #+20]
   \        0xA   0x400B             ANDS     R3,R3,R1
   \        0xC   0x2B00             CMP      R3,#+0
   \        0xE   0xD06F             BEQ      ??CAN_GetITStatus_0
   1429           {
   1430             /* in case the Interrupt is enabled, .... */
   1431              switch (CAN_IT)
   \       0x10   0x1E49             SUBS     R1,R1,#+1
   \       0x12   0xD026             BEQ      ??CAN_GetITStatus_1
   \       0x14   0x1E49             SUBS     R1,R1,#+1
   \       0x16   0xD029             BEQ      ??CAN_GetITStatus_2
   \       0x18   0x1E89             SUBS     R1,R1,#+2
   \       0x1A   0xD02C             BEQ      ??CAN_GetITStatus_3
   \       0x1C   0x1F09             SUBS     R1,R1,#+4
   \       0x1E   0xD02F             BEQ      ??CAN_GetITStatus_4
   \       0x20   0x3908             SUBS     R1,R1,#+8
   \       0x22   0xD032             BEQ      ??CAN_GetITStatus_5
   \       0x24   0x3910             SUBS     R1,R1,#+16
   \       0x26   0xD035             BEQ      ??CAN_GetITStatus_6
   \       0x28   0x3920             SUBS     R1,R1,#+32
   \       0x2A   0xD038             BEQ      ??CAN_GetITStatus_7
   \       0x2C   0x39C0             SUBS     R1,R1,#+192
   \       0x2E   0xD045             BEQ      ??CAN_GetITStatus_8
   \       0x30   0x2380             MOVS     R3,#+128
   \       0x32   0x005B             LSLS     R3,R3,#+1        ;; #+256
   \       0x34   0x1AC9             SUBS     R1,R1,R3
   \       0x36   0xD046             BEQ      ??CAN_GetITStatus_9
   \       0x38   0x2380             MOVS     R3,#+128
   \       0x3A   0x009B             LSLS     R3,R3,#+2        ;; #+512
   \       0x3C   0x1AC9             SUBS     R1,R1,R3
   \       0x3E   0xD047             BEQ      ??CAN_GetITStatus_10
   \       0x40   0x2380             MOVS     R3,#+128
   \       0x42   0x00DB             LSLS     R3,R3,#+3        ;; #+1024
   \       0x44   0x1AC9             SUBS     R1,R1,R3
   \       0x46   0xD048             BEQ      ??CAN_GetITStatus_11
   \       0x48   0x23F0             MOVS     R3,#+240
   \       0x4A   0x01DB             LSLS     R3,R3,#+7        ;; #+30720
   \       0x4C   0x1AC9             SUBS     R1,R1,R3
   \       0x4E   0xD049             BEQ      ??CAN_GetITStatus_12
   \       0x50   0x2380             MOVS     R3,#+128
   \       0x52   0x021B             LSLS     R3,R3,#+8        ;; #+32768
   \       0x54   0x1AC9             SUBS     R1,R1,R3
   \       0x56   0xD027             BEQ      ??CAN_GetITStatus_13
   \       0x58   0x2380             MOVS     R3,#+128
   \       0x5A   0x025B             LSLS     R3,R3,#+9        ;; #+65536
   \       0x5C   0x1AC9             SUBS     R1,R1,R3
   \       0x5E   0xD028             BEQ      ??CAN_GetITStatus_14
   \       0x60   0xE045             B        ??CAN_GetITStatus_15
   1432              {
   1433                case CAN_IT_TME:
   1434                  /* Check CAN_TSR_RQCPx bits */
   1435                  itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
   \                     ??CAN_GetITStatus_1: (+1)
   \       0x62   0x....             LDR      R1,??DataTable11_1  ;; 0x10101
   \       0x64   0x6890             LDR      R0,[R2, #+8]
   \       0x66   0x....'....        BL       CheckITStatus
   1436                  break;
   \       0x6A   0xE041             B        ??CAN_GetITStatus_16
   1437                case CAN_IT_FMP0:
   1438                  /* Check CAN_RF0R_FMP0 bit */
   1439                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
   \                     ??CAN_GetITStatus_2: (+1)
   \       0x6C   0x2103             MOVS     R1,#+3
   \       0x6E   0x68D0             LDR      R0,[R2, #+12]
   \       0x70   0x....'....        BL       CheckITStatus
   1440                  break;
   \       0x74   0xE03C             B        ??CAN_GetITStatus_16
   1441                case CAN_IT_FF0:
   1442                  /* Check CAN_RF0R_FULL0 bit */
   1443                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
   \                     ??CAN_GetITStatus_3: (+1)
   \       0x76   0x2108             MOVS     R1,#+8
   \       0x78   0x68D0             LDR      R0,[R2, #+12]
   \       0x7A   0x....'....        BL       CheckITStatus
   1444                  break;
   \       0x7E   0xE037             B        ??CAN_GetITStatus_16
   1445                case CAN_IT_FOV0:
   1446                  /* Check CAN_RF0R_FOVR0 bit */
   1447                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
   \                     ??CAN_GetITStatus_4: (+1)
   \       0x80   0x2110             MOVS     R1,#+16
   \       0x82   0x68D0             LDR      R0,[R2, #+12]
   \       0x84   0x....'....        BL       CheckITStatus
   1448                  break;
   \       0x88   0xE032             B        ??CAN_GetITStatus_16
   1449                case CAN_IT_FMP1:
   1450                  /* Check CAN_RF1R_FMP1 bit */
   1451                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
   \                     ??CAN_GetITStatus_5: (+1)
   \       0x8A   0x2103             MOVS     R1,#+3
   \       0x8C   0x6910             LDR      R0,[R2, #+16]
   \       0x8E   0x....'....        BL       CheckITStatus
   1452                  break;
   \       0x92   0xE02D             B        ??CAN_GetITStatus_16
   1453                case CAN_IT_FF1:
   1454                  /* Check CAN_RF1R_FULL1 bit */
   1455                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
   \                     ??CAN_GetITStatus_6: (+1)
   \       0x94   0x2108             MOVS     R1,#+8
   \       0x96   0x6910             LDR      R0,[R2, #+16]
   \       0x98   0x....'....        BL       CheckITStatus
   1456                  break;
   \       0x9C   0xE028             B        ??CAN_GetITStatus_16
   1457                case CAN_IT_FOV1:
   1458                  /* Check CAN_RF1R_FOVR1 bit */
   1459                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
   \                     ??CAN_GetITStatus_7: (+1)
   \       0x9E   0x2110             MOVS     R1,#+16
   \       0xA0   0x6910             LDR      R0,[R2, #+16]
   \       0xA2   0x....'....        BL       CheckITStatus
   1460                  break;
   \       0xA6   0xE023             B        ??CAN_GetITStatus_16
   1461                case CAN_IT_WKU:
   1462                  /* Check CAN_MSR_WKUI bit */
   1463                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
   \                     ??CAN_GetITStatus_13: (+1)
   \       0xA8   0x2108             MOVS     R1,#+8
   \       0xAA   0x6850             LDR      R0,[R2, #+4]
   \       0xAC   0x....'....        BL       CheckITStatus
   1464                  break;
   \       0xB0   0xE01E             B        ??CAN_GetITStatus_16
   1465                case CAN_IT_SLK:
   1466                  /* Check CAN_MSR_SLAKI bit */
   1467                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
   \                     ??CAN_GetITStatus_14: (+1)
   \       0xB2   0x2110             MOVS     R1,#+16
   \       0xB4   0x6850             LDR      R0,[R2, #+4]
   \       0xB6   0x....'....        BL       CheckITStatus
   1468                  break;
   \       0xBA   0xE019             B        ??CAN_GetITStatus_16
   1469                case CAN_IT_EWG:
   1470                  /* Check CAN_ESR_EWGF bit */
   1471                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
   \                     ??CAN_GetITStatus_8: (+1)
   \       0xBC   0x2101             MOVS     R1,#+1
   \       0xBE   0x6990             LDR      R0,[R2, #+24]
   \       0xC0   0x....'....        BL       CheckITStatus
   1472                  break;
   \       0xC4   0xE014             B        ??CAN_GetITStatus_16
   1473                case CAN_IT_EPV:
   1474                  /* Check CAN_ESR_EPVF bit */
   1475                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
   \                     ??CAN_GetITStatus_9: (+1)
   \       0xC6   0x2102             MOVS     R1,#+2
   \       0xC8   0x6990             LDR      R0,[R2, #+24]
   \       0xCA   0x....'....        BL       CheckITStatus
   1476                  break;
   \       0xCE   0xE00F             B        ??CAN_GetITStatus_16
   1477                case CAN_IT_BOF:
   1478                  /* Check CAN_ESR_BOFF bit */
   1479                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
   \                     ??CAN_GetITStatus_10: (+1)
   \       0xD0   0x2104             MOVS     R1,#+4
   \       0xD2   0x6990             LDR      R0,[R2, #+24]
   \       0xD4   0x....'....        BL       CheckITStatus
   1480                  break;
   \       0xD8   0xE00A             B        ??CAN_GetITStatus_16
   1481                case CAN_IT_LEC:
   1482                  /* Check CAN_ESR_LEC bit */
   1483                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
   \                     ??CAN_GetITStatus_11: (+1)
   \       0xDA   0x2170             MOVS     R1,#+112
   \       0xDC   0x6990             LDR      R0,[R2, #+24]
   \       0xDE   0x....'....        BL       CheckITStatus
   1484                  break;
   \       0xE2   0xE005             B        ??CAN_GetITStatus_16
   1485                case CAN_IT_ERR:
   1486                  /* Check CAN_MSR_ERRI bit */ 
   1487                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
   \                     ??CAN_GetITStatus_12: (+1)
   \       0xE4   0x2104             MOVS     R1,#+4
   \       0xE6   0x6850             LDR      R0,[R2, #+4]
   \       0xE8   0x....'....        BL       CheckITStatus
   1488                  break;
   \       0xEC   0xE000             B        ??CAN_GetITStatus_16
   1489                default:
   1490                  /* in case of error, return RESET */
   1491                  itstatus = RESET;
   1492                  break;
   \                     ??CAN_GetITStatus_15: (+1)
   \       0xEE   0xE7FF             B        ??CAN_GetITStatus_16
   1493              }
   1494            }
   1495            else
   1496            {
   1497             /* in case the Interrupt is not enabled, return RESET */
   1498              itstatus  = RESET;
   1499            }
   1500            
   1501            /* Return the CAN_IT status */
   1502            return  itstatus;
   \                     ??CAN_GetITStatus_0: (+1)
   \                     ??CAN_GetITStatus_16: (+1)
   \       0xF0   0xB2C0             UXTB     R0,R0
   \       0xF2   0xBD02             POP      {R1,PC}          ;; return
   1503          }
   1504          
   1505          /**
   1506            * @brief  Clears the CANx's interrupt pending bits.
   1507            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1508            * @param  CAN_IT: specifies the interrupt pending bit to clear.
   1509            *          This parameter can be one of the following values:
   1510            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt
   1511            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1512            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1513            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1514            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1515            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1516            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1517            *            @arg CAN_IT_EWG: Error warning Interrupt
   1518            *            @arg CAN_IT_EPV: Error passive Interrupt
   1519            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1520            *            @arg CAN_IT_LEC: Last error code Interrupt
   1521            *            @arg CAN_IT_ERR: Error Interrupt 
   1522            * @retval None
   1523            */

   \                                 In section .text, align 2, keep-with-next
   1524          void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1525          {
   \                     CAN_ClearITPendingBit: (+1)
   \        0x0   0xB500             PUSH     {LR}
   1526            /* Check the parameters */
   1527            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1528            assert_param(IS_CAN_CLEAR_IT(CAN_IT));
   1529          
   1530            switch (CAN_IT)
   \        0x2   0x1E49             SUBS     R1,R1,#+1
   \        0x4   0xD022             BEQ      ??CAN_ClearITPendingBit_0
   \        0x6   0x1EC9             SUBS     R1,R1,#+3
   \        0x8   0xD023             BEQ      ??CAN_ClearITPendingBit_1
   \        0xA   0x1F09             SUBS     R1,R1,#+4
   \        0xC   0xD024             BEQ      ??CAN_ClearITPendingBit_2
   \        0xE   0x3918             SUBS     R1,R1,#+24
   \       0x10   0xD025             BEQ      ??CAN_ClearITPendingBit_3
   \       0x12   0x3920             SUBS     R1,R1,#+32
   \       0x14   0xD026             BEQ      ??CAN_ClearITPendingBit_4
   \       0x16   0x39C0             SUBS     R1,R1,#+192
   \       0x18   0xD02D             BEQ      ??CAN_ClearITPendingBit_5
   \       0x1A   0x2280             MOVS     R2,#+128
   \       0x1C   0x0052             LSLS     R2,R2,#+1        ;; #+256
   \       0x1E   0x1A89             SUBS     R1,R1,R2
   \       0x20   0xD02C             BEQ      ??CAN_ClearITPendingBit_6
   \       0x22   0x2280             MOVS     R2,#+128
   \       0x24   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \       0x26   0x1A89             SUBS     R1,R1,R2
   \       0x28   0xD02B             BEQ      ??CAN_ClearITPendingBit_7
   \       0x2A   0x2280             MOVS     R2,#+128
   \       0x2C   0x00D2             LSLS     R2,R2,#+3        ;; #+1024
   \       0x2E   0x1A89             SUBS     R1,R1,R2
   \       0x30   0xD02A             BEQ      ??CAN_ClearITPendingBit_8
   \       0x32   0x22F0             MOVS     R2,#+240
   \       0x34   0x01D2             LSLS     R2,R2,#+7        ;; #+30720
   \       0x36   0x1A89             SUBS     R1,R1,R2
   \       0x38   0xD02B             BEQ      ??CAN_ClearITPendingBit_9
   \       0x3A   0x2280             MOVS     R2,#+128
   \       0x3C   0x0212             LSLS     R2,R2,#+8        ;; #+32768
   \       0x3E   0x1A89             SUBS     R1,R1,R2
   \       0x40   0xD013             BEQ      ??CAN_ClearITPendingBit_10
   \       0x42   0x2280             MOVS     R2,#+128
   \       0x44   0x0252             LSLS     R2,R2,#+9        ;; #+65536
   \       0x46   0x1A89             SUBS     R1,R1,R2
   \       0x48   0xD012             BEQ      ??CAN_ClearITPendingBit_11
   \       0x4A   0xE027             B        ??CAN_ClearITPendingBit_12
   1531            {
   1532              case CAN_IT_TME:
   1533                /* Clear CAN_TSR_RQCPx (rc_w1)*/
   1534                CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
   \                     ??CAN_ClearITPendingBit_0: (+1)
   \       0x4C   0x....             LDR      R1,??DataTable11_1  ;; 0x10101
   \       0x4E   0x6081             STR      R1,[R0, #+8]
   1535                break;
   \       0x50   0xE024             B        ??CAN_ClearITPendingBit_13
   1536              case CAN_IT_FF0:
   1537                /* Clear CAN_RF0R_FULL0 (rc_w1)*/
   1538                CANx->RF0R = CAN_RF0R_FULL0; 
   \                     ??CAN_ClearITPendingBit_1: (+1)
   \       0x52   0x2108             MOVS     R1,#+8
   \       0x54   0x60C1             STR      R1,[R0, #+12]
   1539                break;
   \       0x56   0xE021             B        ??CAN_ClearITPendingBit_13
   1540              case CAN_IT_FOV0:
   1541                /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
   1542                CANx->RF0R = CAN_RF0R_FOVR0; 
   \                     ??CAN_ClearITPendingBit_2: (+1)
   \       0x58   0x2110             MOVS     R1,#+16
   \       0x5A   0x60C1             STR      R1,[R0, #+12]
   1543                break;
   \       0x5C   0xE01E             B        ??CAN_ClearITPendingBit_13
   1544              case CAN_IT_FF1:
   1545                /* Clear CAN_RF1R_FULL1 (rc_w1)*/
   1546                CANx->RF1R = CAN_RF1R_FULL1;  
   \                     ??CAN_ClearITPendingBit_3: (+1)
   \       0x5E   0x2108             MOVS     R1,#+8
   \       0x60   0x6101             STR      R1,[R0, #+16]
   1547                break;
   \       0x62   0xE01B             B        ??CAN_ClearITPendingBit_13
   1548              case CAN_IT_FOV1:
   1549                /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
   1550                CANx->RF1R = CAN_RF1R_FOVR1; 
   \                     ??CAN_ClearITPendingBit_4: (+1)
   \       0x64   0x2110             MOVS     R1,#+16
   \       0x66   0x6101             STR      R1,[R0, #+16]
   1551                break;
   \       0x68   0xE018             B        ??CAN_ClearITPendingBit_13
   1552              case CAN_IT_WKU:
   1553                /* Clear CAN_MSR_WKUI (rc_w1)*/
   1554                CANx->MSR = CAN_MSR_WKUI;  
   \                     ??CAN_ClearITPendingBit_10: (+1)
   \       0x6A   0x2108             MOVS     R1,#+8
   \       0x6C   0x6041             STR      R1,[R0, #+4]
   1555                break;
   \       0x6E   0xE015             B        ??CAN_ClearITPendingBit_13
   1556              case CAN_IT_SLK:
   1557                /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
   1558                CANx->MSR = CAN_MSR_SLAKI;   
   \                     ??CAN_ClearITPendingBit_11: (+1)
   \       0x70   0x2110             MOVS     R1,#+16
   \       0x72   0x6041             STR      R1,[R0, #+4]
   1559                break;
   \       0x74   0xE012             B        ??CAN_ClearITPendingBit_13
   1560              case CAN_IT_EWG:
   1561                /* Clear CAN_MSR_ERRI (rc_w1) */
   1562                CANx->MSR = CAN_MSR_ERRI;
   \                     ??CAN_ClearITPendingBit_5: (+1)
   \       0x76   0x2104             MOVS     R1,#+4
   \       0x78   0x6041             STR      R1,[R0, #+4]
   1563                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
   1564                break;
   \       0x7A   0xE00F             B        ??CAN_ClearITPendingBit_13
   1565              case CAN_IT_EPV:
   1566                /* Clear CAN_MSR_ERRI (rc_w1) */
   1567                CANx->MSR = CAN_MSR_ERRI; 
   \                     ??CAN_ClearITPendingBit_6: (+1)
   \       0x7C   0x2104             MOVS     R1,#+4
   \       0x7E   0x6041             STR      R1,[R0, #+4]
   1568                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1569                break;
   \       0x80   0xE00C             B        ??CAN_ClearITPendingBit_13
   1570              case CAN_IT_BOF:
   1571                /* Clear CAN_MSR_ERRI (rc_w1) */ 
   1572                CANx->MSR = CAN_MSR_ERRI; 
   \                     ??CAN_ClearITPendingBit_7: (+1)
   \       0x82   0x2104             MOVS     R1,#+4
   \       0x84   0x6041             STR      R1,[R0, #+4]
   1573                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1574                 break;
   \       0x86   0xE009             B        ??CAN_ClearITPendingBit_13
   1575              case CAN_IT_LEC:
   1576                /*  Clear LEC bits */
   1577                CANx->ESR = RESET; 
   \                     ??CAN_ClearITPendingBit_8: (+1)
   \       0x88   0x2100             MOVS     R1,#+0
   \       0x8A   0x6181             STR      R1,[R0, #+24]
   1578                /* Clear CAN_MSR_ERRI (rc_w1) */
   1579                CANx->MSR = CAN_MSR_ERRI; 
   \       0x8C   0x2104             MOVS     R1,#+4
   \       0x8E   0x6041             STR      R1,[R0, #+4]
   1580                break;
   \       0x90   0xE004             B        ??CAN_ClearITPendingBit_13
   1581              case CAN_IT_ERR:
   1582                /*Clear LEC bits */
   1583                CANx->ESR = RESET; 
   \                     ??CAN_ClearITPendingBit_9: (+1)
   \       0x92   0x2100             MOVS     R1,#+0
   \       0x94   0x6181             STR      R1,[R0, #+24]
   1584                /* Clear CAN_MSR_ERRI (rc_w1) */
   1585                CANx->MSR = CAN_MSR_ERRI; 
   \       0x96   0x2104             MOVS     R1,#+4
   \       0x98   0x6041             STR      R1,[R0, #+4]
   1586                 /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
   1587                 break;
   \       0x9A   0xE7FF             B        ??CAN_ClearITPendingBit_13
   1588              default:
   1589                 break;
   1590             }
   1591          }
   \                     ??CAN_ClearITPendingBit_12: (+1)
   \                     ??CAN_ClearITPendingBit_13: (+1)
   \       0x9C   0xBD00             POP      {PC}             ;; return
   1592           /**
   1593            * @}
   1594            */
   1595          
   1596          /**
   1597            * @brief  Checks whether the CAN interrupt has occurred or not.
   1598            * @param  CAN_Reg: specifies the CAN interrupt register to check.
   1599            * @param  It_Bit: specifies the interrupt source bit to check.
   1600            * @retval The new state of the CAN Interrupt (SET or RESET).
   1601            */

   \                                 In section .text, align 2, keep-with-next
   1602          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
   1603          {
   \                     CheckITStatus: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0002             MOVS     R2,R0
   1604            ITStatus pendingbitstatus = RESET;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x0003             MOVS     R3,R0
   1605            
   1606            if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
   \        0x8   0x4011             ANDS     R1,R1,R2
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD001             BEQ      ??CheckITStatus_0
   1607            {
   1608              /* CAN_IT is set */
   1609              pendingbitstatus = SET;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xE7FF             B        ??CheckITStatus_1
   1610            }
   1611            else
   1612            {
   1613              /* CAN_IT is reset */
   1614              pendingbitstatus = RESET;
   1615            }
   1616            return pendingbitstatus;
   \                     ??CheckITStatus_0: (+1)
   \                     ??CheckITStatus_1: (+1)
   \       0x12   0xB2C0             UXTB     R0,R0
   \       0x14   0xBD00             POP      {PC}             ;; return
   1617          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x00FF'FFFF        DC32     0xffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0x4000'6600        DC32     0x40006600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0x4000'661C        DC32     0x4000661c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \        0x0   0x4000'660C        DC32     0x4000660c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \        0x0   0x4000'6640        DC32     0x40006640

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \        0x0   0x4000'6604        DC32     0x40006604

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x4000'6614        DC32     0x40006614

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0xFFFF'C0F1        DC32     0xffffc0f1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0xFFFE'FFFF        DC32     0xfffeffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \        0x0   0xFFFF'FEFF        DC32     0xfffffeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x0400'0003        DC32     0x4000003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x0800'0300        DC32     0x8000300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x1003'0000        DC32     0x10030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x0400'0001        DC32     0x4000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x0400'00FD        DC32     0x40000fd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x0800'FD00        DC32     0x800fd00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x00FF'FFFF        DC32     0xffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x30F0'0070        DC32     0x30f00070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x0001'0101        DC32     0x10101
   1618          
   1619          /**
   1620            * @}
   1621            */
   1622          
   1623          /**
   1624            * @}
   1625            */
   1626          
   1627          /**
   1628            * @}
   1629            */
   1630          
   1631          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   CAN_CancelTransmit
       4   CAN_ClearFlag
       4   CAN_ClearITPendingBit
       4   CAN_DBGFreeze
       8   CAN_DeInit
         8   -> RCC_APB1PeriphResetCmd
       4   CAN_FIFORelease
      20   CAN_FilterInit
       4   CAN_GetFlagStatus
       8   CAN_GetITStatus
         8   -> CheckITStatus
       0   CAN_GetLSBTransmitErrorCounter
       0   CAN_GetLastErrorCode
       0   CAN_GetReceiveErrorCounter
       4   CAN_ITConfig
      12   CAN_Init
       4   CAN_MessagePending
      12   CAN_OperatingModeRequest
       8   CAN_Receive
       0   CAN_SlaveStartBank
       4   CAN_Sleep
       0   CAN_StructInit
       4   CAN_TTComModeCmd
      16   CAN_Transmit
       4   CAN_TransmitStatus
       8   CAN_WakeUp
       4   CheckITStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable9
      52  CAN_CancelTransmit
      48  CAN_ClearFlag
     158  CAN_ClearITPendingBit
      30  CAN_DBGFreeze
      24  CAN_DeInit
      28  CAN_FIFORelease
     202  CAN_FilterInit
     122  CAN_GetFlagStatus
     244  CAN_GetITStatus
      10  CAN_GetLSBTransmitErrorCounter
      12  CAN_GetLastErrorCode
      10  CAN_GetReceiveErrorCounter
      24  CAN_ITConfig
     274  CAN_Init
      42  CAN_MessagePending
     160  CAN_OperatingModeRequest
     318  CAN_Receive
      38  CAN_SlaveStartBank
      34  CAN_Sleep
      32  CAN_StructInit
     118  CAN_TTComModeCmd
     370  CAN_Transmit
     118  CAN_TransmitStatus
      48  CAN_WakeUp
      22  CheckITStatus

 
 2'614 bytes in section .text
 
 2'614 bytes of CODE memory

Errors: none
Warnings: none
