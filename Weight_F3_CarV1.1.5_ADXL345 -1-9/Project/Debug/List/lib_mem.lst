###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.4.261/W32 for ARM         10/Jan/2021  16:10:16
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Source\System\uC-LIB\lib_mem.c
#    Command line      =
#        -f C:\Users\macanlin\AppData\Local\Temp\EWD75A.tmp
#        ("C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Source\System\uC-LIB\lib_mem.c" -D USE_STDPERIPH_DRIVER -D
#        STM32F072 -lC
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\List" -o
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        C:\rj\IAR\arm\inc\c\DLib_Config_Normal.h -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\BSP\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\FWLib\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\CMSIS\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\OS_Cfg\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-CPU\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-LIB\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uCOS-III\Ports\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uCOS-III\Source\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\APP\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\FWLib\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-LIB\\" -Ol -I
#        C:\rj\IAR\arm\CMSIS\Core\Include\\ -I
#        C:\rj\IAR\arm\CMSIS\DSP\Include\\)
#    Locale            =  C
#    List file         =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\List\lib_mem.lst
#    Object file       =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\Obj\lib_mem.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#
###############################################################################

C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345 -1-9\Source\System\uC-LIB\lib_mem.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/LIB
      4          *                                        CUSTOM LIBRARY MODULES
      5          *
      6          *                          (c) Copyright 2004-2012; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *
     10          *               uC/LIB is provided in source form to registered licensees ONLY.  It is
     11          *               illegal to distribute this source code to any third party unless you receive
     12          *               written permission by an authorized Micrium representative.  Knowledge of
     13          *               the source code may NOT be used to develop a similar product.
     14          *
     15          *               Please help us continue to provide the Embedded community with the finest
     16          *               software available.  Your honesty is greatly appreciated.
     17          *
     18          *               You can contact us at www.micrium.com.
     19          *********************************************************************************************************
     20          */
     21          
     22          /*
     23          *********************************************************************************************************
     24          *
     25          *                                     STANDARD MEMORY OPERATIONS
     26          *
     27          * Filename      : lib_mem.c
     28          * Version       : V1.37.00
     29          * Programmer(s) : ITJ
     30          *                 FGK
     31          *                 JFD
     32          *                 FBJ
     33          *********************************************************************************************************
     34          * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
     35          *
     36          *                     (a) ALL standard library functions are implemented in the custom library modules :
     37          *
     38          *                         (1) \<Custom Library Directory>\lib_*.*
     39          *
     40          *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
     41          *
     42          *                               where
     43          *                                       <Custom Library Directory>      directory path for custom library software
     44          *                                       <cpu>                           directory name for specific processor (CPU)
     45          *                                       <compiler>                      directory name for specific compiler
     46          *
     47          *                     (b) Product-specific library functions are implemented in individual products.
     48          *********************************************************************************************************
     49          */
     50          
     51          
     52          /*
     53          *********************************************************************************************************
     54          *                                            INCLUDE FILES
     55          *********************************************************************************************************
     56          */
     57          
     58          #define    MICRIUM_SOURCE
     59          #define    LIB_MEM_MODULE
     60          #include  <lib_mem.h>
     61          
     62          
     63          /*$PAGE*/
     64          /*
     65          *********************************************************************************************************
     66          *                                            LOCAL DEFINES
     67          *********************************************************************************************************
     68          */
     69          
     70          
     71          /*
     72          *********************************************************************************************************
     73          *                                           LOCAL CONSTANTS
     74          *********************************************************************************************************
     75          */
     76          
     77          
     78          /*
     79          *********************************************************************************************************
     80          *                                          LOCAL DATA TYPES
     81          *********************************************************************************************************
     82          */
     83          
     84          
     85          /*
     86          *********************************************************************************************************
     87          *                                            LOCAL TABLES
     88          *********************************************************************************************************
     89          */
     90          
     91          
     92          /*
     93          *********************************************************************************************************
     94          *                                       LOCAL GLOBAL VARIABLES
     95          *********************************************************************************************************
     96          */
     97          
     98          #if     (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .bss, align 4
     99          MEM_POOL    *Mem_PoolTbl;                                               /* Mem      pool/seg tbl.                       */
   \                     Mem_PoolTbl:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    100          MEM_POOL     Mem_PoolHeap;                                              /* Mem heap pool/seg.                           */
   \                     Mem_PoolHeap:
   \        0x0                      DS8 72
    101          
    102          #ifndef  LIB_MEM_CFG_HEAP_BASE_ADDR

   \                                 In section .bss, align 4
    103          CPU_INT08U   Mem_Heap[LIB_MEM_CFG_HEAP_SIZE];                           /* Mem heap.                                    */
   \                     Mem_Heap:
   \        0x0                      DS8 1'024
    104          #endif
    105          #endif
    106          
    107          
    108          /*
    109          *********************************************************************************************************
    110          *                                      LOCAL FUNCTION PROTOTYPES
    111          *********************************************************************************************************
    112          */
    113          
    114          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)                               /* -------------- MEM POOL FNCTS -------------- */
    115          
    116          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    117          static  CPU_BOOLEAN   Mem_PoolBlkIsValidAddr(MEM_POOL          *pmem_pool,
    118                                                       void              *pmem_blk);
    119          #endif
    120          
    121          
    122          static  CPU_SIZE_T    Mem_SegCalcTotSize    (void              *pmem_addr,
    123                                                       MEM_POOL_BLK_QTY   blk_nbr,
    124                                                       CPU_SIZE_T         blk_size,
    125                                                       CPU_SIZE_T         blk_align);
    126          
    127          static  void         *Mem_SegAlloc          (MEM_POOL          *pmem_pool,
    128                                                       CPU_SIZE_T         size,
    129                                                       CPU_SIZE_T         align);
    130          
    131          #endif
    132          
    133          
    134          /*
    135          *********************************************************************************************************
    136          *                                     LOCAL CONFIGURATION ERRORS
    137          *********************************************************************************************************
    138          */
    139          
    140          
    141          /*$PAGE*/
    142          /*
    143          *********************************************************************************************************
    144          *                                             Mem_Init()
    145          *
    146          * Description : (1) Initialize Memory Management Module :
    147          *
    148          *                   (a) Initialize heap memory pool
    149          *                   (b) Initialize      memory pool table
    150          *
    151          *
    152          * Argument(s) : none.
    153          *
    154          * Return(s)   : none.
    155          *
    156          * Caller(s)   : Application.
    157          *
    158          * Note(s)     : (2) Mem_Init() MUST be called ... :
    159          *
    160          *                   (a) ONLY ONCE from a product's application; ...
    161          *                   (b) BEFORE product's application calls any memory library module function(s)
    162          *********************************************************************************************************
    163          */
    164          

   \                                 In section .text, align 2, keep-with-next
    165          void  Mem_Init (void)
    166          {
    167          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
    168              MEM_POOL  *pmem_pool;
    169          
    170                                                                                  /* --------- INIT MEM HEAP SEG / POOL --------- */
    171              pmem_pool                   = (MEM_POOL   *)&Mem_PoolHeap;
   \                     Mem_Init: (+1)
   \        0x0   0x....             LDR      R1,??DataTable0
   \        0x2   0x0008             MOVS     R0,R1
    172              pmem_pool->Type             = (LIB_MEM_TYPE) LIB_MEM_TYPE_HEAP;
   \        0x4   0x....             LDR      R2,??DataTable0_1  ;; 0x50414548
   \        0x6   0x6002             STR      R2,[R0, #+0]
    173              pmem_pool->SegHeadPtr       = (MEM_POOL   *)&Mem_PoolHeap;          /* Heap seg head = heap seg.                    */
   \        0x8   0x6041             STR      R1,[R0, #+4]
    174              pmem_pool->SegPrevPtr       = (MEM_POOL   *) 0;
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x6082             STR      R2,[R0, #+8]
    175              pmem_pool->SegNextPtr       = (MEM_POOL   *) 0;
   \        0xE   0x60C2             STR      R2,[R0, #+12]
    176              pmem_pool->PoolPrevPtr      = (MEM_POOL   *) 0;
   \       0x10   0x6102             STR      R2,[R0, #+16]
    177              pmem_pool->PoolNextPtr      = (MEM_POOL   *) 0;
   \       0x12   0x6142             STR      R2,[R0, #+20]
    178              pmem_pool->PoolAddrStart    = (void       *) 0;
   \       0x14   0x6182             STR      R2,[R0, #+24]
    179              pmem_pool->PoolAddrEnd      = (void       *) 0;
   \       0x16   0x61C2             STR      R2,[R0, #+28]
    180              pmem_pool->PoolPtrs         = (void      **) 0;
   \       0x18   0x6202             STR      R2,[R0, #+32]
    181              pmem_pool->BlkSize          = (CPU_SIZE_T  ) 0u;
   \       0x1A   0x6302             STR      R2,[R0, #+48]
    182              pmem_pool->BlkNbr           = (CPU_SIZE_T  ) 0u;
   \       0x1C   0x62C2             STR      R2,[R0, #+44]
    183              pmem_pool->BlkIx            = (MEM_POOL_IX ) 0u;
   \       0x1E   0x6242             STR      R2,[R0, #+36]
    184          
    185          #ifdef  LIB_MEM_CFG_HEAP_BASE_ADDR
    186              pmem_pool->SegAddr          = (void       *) LIB_MEM_CFG_HEAP_BASE_ADDR;
    187              pmem_pool->SegAddrNextAvail = (void       *) LIB_MEM_CFG_HEAP_BASE_ADDR;
    188          #else
    189              pmem_pool->SegAddr          = (void       *)&Mem_Heap[0];
   \       0x20   0x....             LDR      R2,??DataTable0_2
   \       0x22   0x6382             STR      R2,[R0, #+56]
    190              pmem_pool->SegAddrNextAvail = (void       *)&Mem_Heap[0];
   \       0x24   0x63C2             STR      R2,[R0, #+60]
    191          #endif
    192          
    193              pmem_pool->SegSizeTot       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;
   \       0x26   0x2280             MOVS     R2,#+128
   \       0x28   0x00D2             LSLS     R2,R2,#+3        ;; #+1024
   \       0x2A   0x6402             STR      R2,[R0, #+64]
    194              pmem_pool->SegSizeRem       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;
   \       0x2C   0x6442             STR      R2,[R0, #+68]
    195          
    196                                                                                  /* ------------ INIT MEM POOL TBL ------------- */
    197              Mem_PoolTbl = &Mem_PoolHeap;
   \       0x2E   0x....             LDR      R0,??DataTable0_3
   \       0x30   0x6001             STR      R1,[R0, #+0]
    198          #endif
    199          }
   \       0x32   0x4770             BX       LR               ;; return
    200          
    201          
    202          /*$PAGE*/
    203          /*
    204          *********************************************************************************************************
    205          *                                              Mem_Clr()
    206          *
    207          * Description : Clear data buffer (see Note #2).
    208          *
    209          * Argument(s) : pmem        Pointer to memory buffer to clear.
    210          *
    211          *               size        Number of data buffer octets to clear (see Note #1).
    212          *
    213          * Return(s)   : none.
    214          *
    215          * Caller(s)   : Application.
    216          *
    217          * Note(s)     : (1) Null clears allowed (i.e. zero-length clears).
    218          *
    219          *                   See also 'Mem_Set()  Note #1'.
    220          *
    221          *               (2) Clear data by setting each data octet to 0.
    222          *********************************************************************************************************
    223          */
    224          

   \                                 In section .text, align 2, keep-with-next
    225          void  Mem_Clr (void        *pmem,
    226                         CPU_SIZE_T   size)
    227          {
   \                     Mem_Clr: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x000A             MOVS     R2,R1
    228              Mem_Set(pmem,
    229                      0u,                                                 /* See Note #2.                                         */
    230                      size);
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x....'....        BL       Mem_Set
    231          }
   \        0xA   0xBD01             POP      {R0,PC}          ;; return
    232          
    233          
    234          /*$PAGE*/
    235          /*
    236          *********************************************************************************************************
    237          *                                              Mem_Set()
    238          *
    239          * Description : Fill data buffer with specified data octet.
    240          *
    241          * Argument(s) : pmem        Pointer to memory buffer to fill with specified data octet.
    242          *
    243          *               data_val    Data fill octet value.
    244          *
    245          *               size        Number of data buffer octets to fill (see Note #1).
    246          *
    247          * Return(s)   : none.
    248          *
    249          * Caller(s)   : Application.
    250          *
    251          * Note(s)     : (1) Null sets allowed (i.e. zero-length sets).
    252          *
    253          *               (2) For best CPU performance, optimized to fill data buffer using 'CPU_ALIGN'-sized data
    254          *                   words.
    255          *
    256          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    257          *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    258          *                       addresses.
    259          *
    260          *               (3) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    261          *                   address boundary.
    262          *
    263          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    264          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    265          *                  'mem_align_mod' arithmetic operation.
    266          *********************************************************************************************************
    267          */
    268          

   \                                 In section .text, align 2, keep-with-next
    269          void  Mem_Set (void        *pmem,
    270                         CPU_INT08U   data_val,
    271                         CPU_SIZE_T   size)
    272          {
   \                     Mem_Set: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    273              CPU_SIZE_T   size_rem;
    274              CPU_ALIGN    data_align;
    275              CPU_ALIGN   *pmem_align;
    276              CPU_INT08U  *pmem_08;
    277              CPU_DATA     mem_align_mod;
    278              CPU_DATA     i;
    279          
    280          
    281          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    282              if (size < 1) {                                             /* See Note #1.                                         */
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xD025             BEQ      ??Mem_Set_0
    283                  return;
    284              }
    285              if (pmem == (void *)0) {
   \                     ??Mem_Set_1: (+1)
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD023             BEQ      ??Mem_Set_0
    286                  return;
    287              }
    288          #endif
    289          
    290          
    291              data_align = 0u;
   \                     ??Mem_Set_2: (+1)
   \        0xA   0x2500             MOVS     R5,#+0
   \        0xC   0x002B             MOVS     R3,R5
    292              for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
   \        0xE   0xE004             B        ??Mem_Set_3
    293                  data_align <<=  DEF_OCTET_NBR_BITS;
   \                     ??Mem_Set_4: (+1)
   \       0x10   0x021C             LSLS     R4,R3,#+8
    294                  data_align  |= (CPU_ALIGN)data_val;
   \       0x12   0x000B             MOVS     R3,R1
   \       0x14   0xB2DB             UXTB     R3,R3
   \       0x16   0x4323             ORRS     R3,R3,R4
    295              }
   \       0x18   0x1C6D             ADDS     R5,R5,#+1
   \                     ??Mem_Set_3: (+1)
   \       0x1A   0x2D04             CMP      R5,#+4
   \       0x1C   0xD3F8             BCC      ??Mem_Set_4
    296          
    297              size_rem      =  size;
    298              mem_align_mod = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));   /* See Note #3.                                 */
   \       0x1E   0x0004             MOVS     R4,R0
   \       0x20   0x07A4             LSLS     R4,R4,#+30       ;; ZeroExtS R4,R4,#+30,#+30
   \       0x22   0x0FA4             LSRS     R4,R4,#+30
    299          
    300              pmem_08 = (CPU_INT08U *)pmem;
    301              if (mem_align_mod != 0u) {                                  /* If leading octets avail,                   ...       */
   \       0x24   0x2C00             CMP      R4,#+0
   \       0x26   0xD008             BEQ      ??Mem_Set_5
    302                  i = mem_align_mod;
   \       0x28   0xE003             B        ??Mem_Set_6
    303                  while ((size_rem > 0) &&                                /* ... start mem buf fill with leading octets ...       */
    304                         (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
    305                     *pmem_08++ = data_val;
   \                     ??Mem_Set_7: (+1)
   \       0x2A   0x7001             STRB     R1,[R0, #+0]
   \       0x2C   0x1C40             ADDS     R0,R0,#+1
    306                      size_rem -= sizeof(CPU_INT08U);
   \       0x2E   0x1E52             SUBS     R2,R2,#+1
    307                      i++;
   \       0x30   0x1C64             ADDS     R4,R4,#+1
    308                  }
   \                     ??Mem_Set_6: (+1)
   \       0x32   0x2A00             CMP      R2,#+0
   \       0x34   0xD001             BEQ      ??Mem_Set_5
   \       0x36   0x2C04             CMP      R4,#+4
   \       0x38   0xD3F7             BCC      ??Mem_Set_7
    309              }
    310          
    311              pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2a.                                        */
   \                     ??Mem_Set_5: (+1)
   \       0x3A   0xE002             B        ??Mem_Set_8
    312              while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
    313                 *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
   \                     ??Mem_Set_9: (+1)
   \       0x3C   0x6003             STR      R3,[R0, #+0]
   \       0x3E   0x1D00             ADDS     R0,R0,#+4
    314                  size_rem    -= sizeof(CPU_ALIGN);
   \       0x40   0x1F12             SUBS     R2,R2,#+4
    315              }
   \                     ??Mem_Set_8: (+1)
   \       0x42   0x2A04             CMP      R2,#+4
   \       0x44   0xD2FA             BCS      ??Mem_Set_9
    316          
    317              pmem_08 = (CPU_INT08U *)pmem_align;
   \       0x46   0xE002             B        ??Mem_Set_10
    318              while (size_rem > 0) {                                      /* Finish mem buf fill with trailing octets.            */
    319                 *pmem_08++   = data_val;
   \                     ??Mem_Set_11: (+1)
   \       0x48   0x7001             STRB     R1,[R0, #+0]
   \       0x4A   0x1C40             ADDS     R0,R0,#+1
    320                  size_rem   -= sizeof(CPU_INT08U);
   \       0x4C   0x1E52             SUBS     R2,R2,#+1
    321              }
   \                     ??Mem_Set_10: (+1)
   \       0x4E   0x2A00             CMP      R2,#+0
   \       0x50   0xD1FA             BNE      ??Mem_Set_11
    322          }
   \                     ??Mem_Set_0: (+1)
   \       0x52   0xBD30             POP      {R4,R5,PC}       ;; return
    323          
    324          
    325          /*$PAGE*/
    326          /*
    327          *********************************************************************************************************
    328          *                                             Mem_Copy()
    329          *
    330          * Description : Copy data octets from one memory buffer to another memory buffer.
    331          *
    332          * Argument(s) : pdest       Pointer to destination memory buffer.
    333          *
    334          *               psrc        Pointer to source      memory buffer.
    335          *
    336          *               size        Number of octets to copy (see Note #1).
    337          *
    338          * Return(s)   : none.
    339          *
    340          * Caller(s)   : Application.
    341          *
    342          * Note(s)     : (1) Null copies allowed (i.e. zero-length copies).
    343          *
    344          *               (2) Memory buffers NOT checked for overlapping.
    345          *
    346          *                   (a) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that "if
    347          *                       copying takes place between objects that overlap, the behavior is undefined".
    348          *
    349          *                   (b) However, data octets from a source memory buffer at a higher address value SHOULD
    350          *                       successfully copy to a destination memory buffer at a lower  address value even
    351          *                       if any octets of the memory buffers overlap as long as no individual, atomic CPU
    352          *                       word copy overlaps.
    353          *
    354          *                       Since Mem_Copy() performs the data octet copy via 'CPU_ALIGN'-sized words &/or
    355          *                       octets; & since 'CPU_ALIGN'-sized words MUST be accessed on word-aligned addresses
    356          *                       (see Note #3b), neither 'CPU_ALIGN'-sized words nor octets at unique addresses can
    357          *                       ever overlap.
    358          *
    359          *                       Therefore, Mem_Copy() SHOULD be able to successfully copy overlapping memory
    360          *                       buffers as long as the source memory buffer is at a higher address value than the
    361          *                       destination memory buffer.
    362          *
    363          *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
    364          *                   words.
    365          *
    366          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    367          *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    368          *                       addresses.
    369          *
    370          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    371          *                   address boundary.
    372          *
    373          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    374          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    375          *                  'mem_align_mod' arithmetic operation.
    376          *********************************************************************************************************
    377          */
    378          /*$PAGE*/
    379          #if (LIB_MEM_CFG_OPTIMIZE_ASM_EN != DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    380          void  Mem_Copy (       void        *pdest,
    381                          const  void        *psrc,
    382                                 CPU_SIZE_T   size)
    383          {
   \                     Mem_Copy: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    384                     CPU_SIZE_T    size_rem;
    385                     CPU_SIZE_T    mem_gap_octets;
    386                     CPU_ALIGN    *pmem_align_dest;
    387              const  CPU_ALIGN    *pmem_align_src;
    388                     CPU_INT08U   *pmem_08_dest;
    389              const  CPU_INT08U   *pmem_08_src;
    390                     CPU_DATA      i;
    391                     CPU_DATA      mem_align_mod_dest;
    392                     CPU_DATA      mem_align_mod_src;
    393                     CPU_BOOLEAN   mem_aligned;
    394          
    395          
    396          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    397              if (size < 1) {                                             /* See Note #1.                                         */
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xD032             BEQ      ??Mem_Copy_0
    398                  return;
    399              }
    400              if (pdest == (void *)0) {
   \                     ??Mem_Copy_1: (+1)
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD030             BEQ      ??Mem_Copy_0
    401                  return;
    402              }
    403              if (psrc  == (void *)0) {
   \                     ??Mem_Copy_2: (+1)
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD02E             BEQ      ??Mem_Copy_0
    404                  return;
    405              }
    406          #endif
    407          
    408          
    409              size_rem           =  size;
    410          
    411              pmem_08_dest       = (      CPU_INT08U *)pdest;
    412              pmem_08_src        = (const CPU_INT08U *)psrc;
    413          
    414              mem_gap_octets     = pmem_08_src - pmem_08_dest;
   \                     ??Mem_Copy_3: (+1)
   \        0xE   0x1A0B             SUBS     R3,R1,R0
    415          
    416          
    417              if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
   \       0x10   0x2B04             CMP      R3,#+4
   \       0x12   0xD329             BCC      ??Mem_Copy_4
    418                                                                          /* See Note #4.                                         */
    419                  mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
   \       0x14   0x2403             MOVS     R4,#+3
   \       0x16   0x0003             MOVS     R3,R0
   \       0x18   0x4023             ANDS     R3,R3,R4
   \       0x1A   0xB2DB             UXTB     R3,R3
    420                  mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
   \       0x1C   0x000D             MOVS     R5,R1
   \       0x1E   0x402C             ANDS     R4,R4,R5
   \       0x20   0xB2E4             UXTB     R4,R4
    421          
    422                  mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
   \       0x22   0x42A3             CMP      R3,R4
   \       0x24   0xD101             BNE      ??Mem_Copy_5
   \       0x26   0x2401             MOVS     R4,#+1
   \       0x28   0xE000             B        ??Mem_Copy_6
   \                     ??Mem_Copy_5: (+1)
   \       0x2A   0x2400             MOVS     R4,#+0
    423          
    424                  if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
   \                     ??Mem_Copy_6: (+1)
   \       0x2C   0xB2E4             UXTB     R4,R4
   \       0x2E   0x2C01             CMP      R4,#+1
   \       0x30   0xD11A             BNE      ??Mem_Copy_4
    425                                                                          /* ... optimize copy for mem buf alignment.             */
    426                      if (mem_align_mod_dest != 0u) {                     /* If leading octets avail,                   ...       */
   \       0x32   0x2B00             CMP      R3,#+0
   \       0x34   0xD00A             BEQ      ??Mem_Copy_7
    427                          i = mem_align_mod_dest;
   \       0x36   0xE005             B        ??Mem_Copy_8
    428                          while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
    429                                 (i          <  sizeof(CPU_ALIGN ))) {    /* ... until next CPU_ALIGN word boundary.              */
    430                             *pmem_08_dest++ = *pmem_08_src++;
   \                     ??Mem_Copy_9: (+1)
   \       0x38   0x780C             LDRB     R4,[R1, #+0]
   \       0x3A   0x7004             STRB     R4,[R0, #+0]
   \       0x3C   0x1C49             ADDS     R1,R1,#+1
   \       0x3E   0x1C40             ADDS     R0,R0,#+1
    431                              size_rem      -=  sizeof(CPU_INT08U);
   \       0x40   0x1E52             SUBS     R2,R2,#+1
    432                              i++;
   \       0x42   0x1C5B             ADDS     R3,R3,#+1
    433                          }
   \                     ??Mem_Copy_8: (+1)
   \       0x44   0x2A00             CMP      R2,#+0
   \       0x46   0xD001             BEQ      ??Mem_Copy_7
   \       0x48   0x2B04             CMP      R3,#+4
   \       0x4A   0xD3F5             BCC      ??Mem_Copy_9
    434                      }
    435          
    436                      pmem_align_dest = (      CPU_ALIGN *)pmem_08_dest;  /* See Note #3a.                                        */
    437                      pmem_align_src  = (const CPU_ALIGN *)pmem_08_src;
   \                     ??Mem_Copy_7: (+1)
   \       0x4C   0xE004             B        ??Mem_Copy_10
    438                      while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
    439                         *pmem_align_dest++ = *pmem_align_src++;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
   \                     ??Mem_Copy_11: (+1)
   \       0x4E   0x680B             LDR      R3,[R1, #+0]
   \       0x50   0x6003             STR      R3,[R0, #+0]
   \       0x52   0x1D09             ADDS     R1,R1,#+4
   \       0x54   0x1D00             ADDS     R0,R0,#+4
    440                          size_rem         -=  sizeof(CPU_ALIGN);
   \       0x56   0x1F12             SUBS     R2,R2,#+4
    441                      }
   \                     ??Mem_Copy_10: (+1)
   \       0x58   0x2A04             CMP      R2,#+4
   \       0x5A   0xD2F8             BCS      ??Mem_Copy_11
    442          
    443                      pmem_08_dest = (      CPU_INT08U *)pmem_align_dest;
    444                      pmem_08_src  = (const CPU_INT08U *)pmem_align_src;
   \       0x5C   0xE004             B        ??Mem_Copy_4
    445                  }
    446              }
    447          
    448              while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
    449                 *pmem_08_dest++ = *pmem_08_src++;                        /* ... copy psrc to pdest by octets.                    */
   \                     ??Mem_Copy_12: (+1)
   \       0x5E   0x780B             LDRB     R3,[R1, #+0]
   \       0x60   0x7003             STRB     R3,[R0, #+0]
   \       0x62   0x1C49             ADDS     R1,R1,#+1
   \       0x64   0x1C40             ADDS     R0,R0,#+1
    450                  size_rem      -=  sizeof(CPU_INT08U);
   \       0x66   0x1E52             SUBS     R2,R2,#+1
    451              }
   \                     ??Mem_Copy_4: (+1)
   \       0x68   0x2A00             CMP      R2,#+0
   \       0x6A   0xD1F8             BNE      ??Mem_Copy_12
    452          }
   \                     ??Mem_Copy_0: (+1)
   \       0x6C   0xBD30             POP      {R4,R5,PC}       ;; return
    453          #endif
    454          
    455          
    456          /*
    457          *********************************************************************************************************
    458          *                                             Mem_Move()
    459          *
    460          * Description : Move data octets from one memory buffer to another memory buffer, or within the same
    461          *               memory buffer. Overlapping is correctly handled for all move operations.
    462          *
    463          * Argument(s) : pdest       Pointer to destination memory buffer.
    464          *
    465          *               psrc        Pointer to source      memory buffer.
    466          *
    467          *               size        Number of octets to move (see Note #1).
    468          *
    469          * Return(s)   : none.
    470          *
    471          * Caller(s)   : Application.
    472          *
    473          * Note(s)     : (1) Null move operations allowed (i.e. zero-length).
    474          *
    475          *               (2) Memory buffers checked for overlapping.
    476          *
    477          *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
    478          *                   words.
    479          *
    480          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    481          *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    482          *                       addresses.
    483          *
    484          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    485          *                   address boundary.
    486          *
    487          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    488          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    489          *                  'mem_align_mod' arithmetic operation.
    490          *********************************************************************************************************
    491          */
    492          /*$PAGE*/
    493          

   \                                 In section .text, align 2, keep-with-next
    494          void  Mem_Move (       void        *pdest,
    495                          const  void        *psrc,
    496                                 CPU_SIZE_T   size)
    497          {
   \                     Mem_Move: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    498                     CPU_SIZE_T    size_rem;
    499                     CPU_SIZE_T    mem_gap_octets;
    500                     CPU_ALIGN    *pmem_align_dest;
    501              const  CPU_ALIGN    *pmem_align_src;
    502                     CPU_INT08U   *pmem_08_dest;
    503              const  CPU_INT08U   *pmem_08_src;
    504                     CPU_INT08S    i;
    505                     CPU_DATA      mem_align_mod_dest;
    506                     CPU_DATA      mem_align_mod_src;
    507                     CPU_BOOLEAN   mem_aligned;
    508          
    509          
    510          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    511              if (size < 1) {
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xD045             BEQ      ??Mem_Move_0
    512                  return;
    513              }
    514              if (pdest == (void *)0) {
   \                     ??Mem_Move_1: (+1)
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD043             BEQ      ??Mem_Move_0
    515                  return;
    516              }
    517              if (psrc  == (void *)0) {
   \                     ??Mem_Move_2: (+1)
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD041             BEQ      ??Mem_Move_0
    518                  return;
    519              }
    520          #endif
    521          
    522              pmem_08_src  = (const CPU_INT08U *)psrc;
   \                     ??Mem_Move_3: (+1)
   \        0xE   0x000C             MOVS     R4,R1
    523              pmem_08_dest = (      CPU_INT08U *)pdest;
   \       0x10   0x0003             MOVS     R3,R0
    524              if (pmem_08_src > pmem_08_dest) {
   \       0x12   0x42A3             CMP      R3,R4
   \       0x14   0xD202             BCS      ??Mem_Move_4
    525                  Mem_Copy(pdest, psrc, size);
   \       0x16   0x....'....        BL       Mem_Copy
    526                  return;
   \       0x1A   0xE03A             B        ??Mem_Move_0
    527              }
    528          
    529              size_rem           =  size;
   \                     ??Mem_Move_4: (+1)
   \       0x1C   0x0013             MOVS     R3,R2
    530          
    531              pmem_08_dest       = (      CPU_INT08U *)pdest + size - 1;
   \       0x1E   0x1880             ADDS     R0,R0,R2
   \       0x20   0x1E40             SUBS     R0,R0,#+1
    532              pmem_08_src        = (const CPU_INT08U *)psrc  + size - 1;
   \       0x22   0x1889             ADDS     R1,R1,R2
   \       0x24   0x1E49             SUBS     R1,R1,#+1
    533              
    534              mem_gap_octets     = pmem_08_dest - pmem_08_src;
   \       0x26   0x1A42             SUBS     R2,R0,R1
    535              
    536          
    537              if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
   \       0x28   0x2A04             CMP      R2,#+4
   \       0x2A   0xD330             BCC      ??Mem_Move_5
    538              
    539                                                                          /* See Note #4.                                         */
    540                  mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
   \       0x2C   0x2403             MOVS     R4,#+3
   \       0x2E   0x0005             MOVS     R5,R0
   \       0x30   0x0022             MOVS     R2,R4
   \       0x32   0x402A             ANDS     R2,R2,R5
   \       0x34   0xB2D2             UXTB     R2,R2
    541                  mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
   \       0x36   0x000D             MOVS     R5,R1
   \       0x38   0x402C             ANDS     R4,R4,R5
   \       0x3A   0xB2E4             UXTB     R4,R4
    542          
    543                  mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
   \       0x3C   0x42A2             CMP      R2,R4
   \       0x3E   0xD101             BNE      ??Mem_Move_6
   \       0x40   0x2401             MOVS     R4,#+1
   \       0x42   0xE000             B        ??Mem_Move_7
   \                     ??Mem_Move_6: (+1)
   \       0x44   0x2400             MOVS     R4,#+0
    544          
    545                  if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
   \                     ??Mem_Move_7: (+1)
   \       0x46   0xB2E4             UXTB     R4,R4
   \       0x48   0x2C01             CMP      R4,#+1
   \       0x4A   0xD120             BNE      ??Mem_Move_5
    546                                                                          /* ... optimize copy for mem buf alignment.             */
    547                      if (mem_align_mod_dest != (sizeof(CPU_ALIGN) - 1)) {/* If leading octets avail,                   ...       */
   \       0x4C   0x2A03             CMP      R2,#+3
   \       0x4E   0xD00C             BEQ      ??Mem_Move_8
    548                          i = mem_align_mod_dest;
   \       0x50   0xE005             B        ??Mem_Move_9
    549                          while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
    550                                 (i          >= 0)) {                     /* ... until next CPU_ALIGN word boundary.              */
    551                             *pmem_08_dest-- = *pmem_08_src--;
   \                     ??Mem_Move_10: (+1)
   \       0x52   0x780C             LDRB     R4,[R1, #+0]
   \       0x54   0x7004             STRB     R4,[R0, #+0]
   \       0x56   0x1E49             SUBS     R1,R1,#+1
   \       0x58   0x1E40             SUBS     R0,R0,#+1
    552                              size_rem      -=  sizeof(CPU_INT08U);
   \       0x5A   0x1E5B             SUBS     R3,R3,#+1
    553                              i--;
   \       0x5C   0x1E52             SUBS     R2,R2,#+1
    554                          }
   \                     ??Mem_Move_9: (+1)
   \       0x5E   0x2B00             CMP      R3,#+0
   \       0x60   0xD003             BEQ      ??Mem_Move_8
   \       0x62   0x0014             MOVS     R4,R2
   \       0x64   0xB264             SXTB     R4,R4
   \       0x66   0x2C00             CMP      R4,#+0
   \       0x68   0xD5F3             BPL      ??Mem_Move_10
    555                      }
    556          
    557                                                                          /* See Note #3a.                                        */
    558                      pmem_align_dest = (      CPU_ALIGN *)((CPU_INT08U *)pmem_08_dest - sizeof(CPU_ALIGN) + 1);
   \                     ??Mem_Move_8: (+1)
   \       0x6A   0x1EC0             SUBS     R0,R0,#+3
    559                      pmem_align_src  = (const CPU_ALIGN *)((CPU_INT08U *)pmem_08_src  - sizeof(CPU_ALIGN) + 1);
   \       0x6C   0x1EC9             SUBS     R1,R1,#+3
   \       0x6E   0xE004             B        ??Mem_Move_11
    560                      while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
    561                         *pmem_align_dest-- = *pmem_align_src--;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
   \                     ??Mem_Move_12: (+1)
   \       0x70   0x680A             LDR      R2,[R1, #+0]
   \       0x72   0x6002             STR      R2,[R0, #+0]
   \       0x74   0x1F09             SUBS     R1,R1,#+4
   \       0x76   0x1F00             SUBS     R0,R0,#+4
    562                          size_rem         -=  sizeof(CPU_ALIGN);
   \       0x78   0x1F1B             SUBS     R3,R3,#+4
    563                      }
   \                     ??Mem_Move_11: (+1)
   \       0x7A   0x2B04             CMP      R3,#+4
   \       0x7C   0xD2F8             BCS      ??Mem_Move_12
    564          
    565                      pmem_08_dest = (      CPU_INT08U *)pmem_align_dest + sizeof(CPU_ALIGN) - 1;
   \       0x7E   0x1CC0             ADDS     R0,R0,#+3
    566                      pmem_08_src  = (const CPU_INT08U *)pmem_align_src  + sizeof(CPU_ALIGN) - 1;
   \       0x80   0x1CC9             ADDS     R1,R1,#+3
   \       0x82   0xE004             B        ??Mem_Move_5
    567          
    568                  }
    569              }
    570          
    571              while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
    572                 *pmem_08_dest-- = *pmem_08_src--;                        /* ... copy psrc to pdest by octets.                    */
   \                     ??Mem_Move_13: (+1)
   \       0x84   0x780A             LDRB     R2,[R1, #+0]
   \       0x86   0x7002             STRB     R2,[R0, #+0]
   \       0x88   0x1E49             SUBS     R1,R1,#+1
   \       0x8A   0x1E40             SUBS     R0,R0,#+1
    573                  size_rem      -=  sizeof(CPU_INT08U);
   \       0x8C   0x1E5B             SUBS     R3,R3,#+1
    574              }
   \                     ??Mem_Move_5: (+1)
   \       0x8E   0x2B00             CMP      R3,#+0
   \       0x90   0xD1F8             BNE      ??Mem_Move_13
    575          }
   \                     ??Mem_Move_0: (+1)
   \       0x92   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    576          
    577          
    578          /*$PAGE*/
    579          /*
    580          *********************************************************************************************************
    581          *                                              Mem_Cmp()
    582          *
    583          * Description : Verify that ALL data octets in two memory buffers are identical in sequence.
    584          *
    585          * Argument(s) : p1_mem      Pointer to first  memory buffer.
    586          *
    587          *               p2_mem      Pointer to second memory buffer.
    588          *
    589          *               size        Number of data buffer octets to compare (see Note #1).
    590          *
    591          * Return(s)   : DEF_YES, if 'size' number of data octets are identical in both memory buffers.
    592          *
    593          *               DEF_NO,  otherwise.
    594          *
    595          * Caller(s)   : Application.
    596          *
    597          * Note(s)     : (1) Null compares allowed (i.e. zero-length compares); 'DEF_YES' returned to indicate
    598          *                   identical null compare.
    599          *
    600          *               (2) Many memory buffer comparisons vary ONLY in the least significant octets -- e.g.
    601          *                   network address buffers.  Consequently, memory buffer comparison is more efficient
    602          *                   if the comparison starts from the end of the memory buffers which will abort sooner
    603          *                   on dissimilar memory buffers that vary only in the least significant octets.
    604          *
    605          *               (3) For best CPU performance, optimized to compare data buffers using 'CPU_ALIGN'-sized
    606          *                   data words.
    607          *
    608          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    609          *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    610          *                       addresses.
    611          *
    612          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    613          *                   address boundary.
    614          *
    615          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    616          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    617          *                  'mem_align_mod' arithmetic operation.
    618          *********************************************************************************************************
    619          */
    620          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
    621          CPU_BOOLEAN  Mem_Cmp (const  void        *p1_mem,
    622                                const  void        *p2_mem,
    623                                       CPU_SIZE_T   size)
    624          {
   \                     Mem_Cmp: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x0003             MOVS     R3,R0
    625                     CPU_SIZE_T    size_rem;
    626                     CPU_ALIGN    *p1_mem_align;
    627                     CPU_ALIGN    *p2_mem_align;
    628              const  CPU_INT08U   *p1_mem_08;
    629              const  CPU_INT08U   *p2_mem_08;
    630                     CPU_DATA      i;
    631                     CPU_DATA      mem_align_mod_1;
    632                     CPU_DATA      mem_align_mod_2;
    633                     CPU_BOOLEAN   mem_aligned;
    634                     CPU_BOOLEAN   mem_cmp;
    635          
    636          
    637              if (size < 1) {                                             /* See Note #1.                                         */
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD101             BNE      ??Mem_Cmp_0
    638                  return (DEF_YES);
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE050             B        ??Mem_Cmp_1
    639              }
    640              if (p1_mem == (void *)0) {
   \                     ??Mem_Cmp_0: (+1)
   \        0xC   0x2B00             CMP      R3,#+0
   \        0xE   0xD101             BNE      ??Mem_Cmp_2
    641                  return (DEF_NO);
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xE04C             B        ??Mem_Cmp_1
    642              }
    643              if (p2_mem == (void *)0) {
   \                     ??Mem_Cmp_2: (+1)
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD101             BNE      ??Mem_Cmp_3
    644                  return (DEF_NO);
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xE048             B        ??Mem_Cmp_1
    645              }
    646          
    647          
    648              mem_cmp         =  DEF_YES;                                 /* Assume mem bufs are identical until cmp fails.       */
   \                     ??Mem_Cmp_3: (+1)
   \       0x1C   0x2501             MOVS     R5,#+1
   \       0x1E   0x0028             MOVS     R0,R5
    649              size_rem        =  size;
   \       0x20   0x0014             MOVS     R4,R2
    650                                                                          /* Start @ end of mem bufs (see Note #2).               */
    651              p1_mem_08       = (const CPU_INT08U *)p1_mem + size;
   \       0x22   0x189B             ADDS     R3,R3,R2
    652              p2_mem_08       = (const CPU_INT08U *)p2_mem + size;
   \       0x24   0x188A             ADDS     R2,R1,R2
    653                                                                          /* See Note #4.                                         */
    654              mem_align_mod_1 = (CPU_INT08U)((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
   \       0x26   0x2603             MOVS     R6,#+3
   \       0x28   0x0019             MOVS     R1,R3
   \       0x2A   0x4031             ANDS     R1,R1,R6
   \       0x2C   0xB2C9             UXTB     R1,R1
    655              mem_align_mod_2 = (CPU_INT08U)((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));
   \       0x2E   0x0017             MOVS     R7,R2
   \       0x30   0x403E             ANDS     R6,R6,R7
   \       0x32   0xB2F6             UXTB     R6,R6
    656          
    657              mem_aligned     = (mem_align_mod_1 == mem_align_mod_2) ? DEF_YES : DEF_NO;
   \       0x34   0x42B1             CMP      R1,R6
   \       0x36   0xD000             BEQ      ??Mem_Cmp_4
   \                     ??Mem_Cmp_5: (+1)
   \       0x38   0x2500             MOVS     R5,#+0
    658          
    659              if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
   \                     ??Mem_Cmp_4: (+1)
   \       0x3A   0xB2ED             UXTB     R5,R5
   \       0x3C   0x2D01             CMP      R5,#+1
   \       0x3E   0xD12F             BNE      ??Mem_Cmp_6
    660                                                                          /* ... optimize cmp for mem buf alignment.              */
    661                  if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
   \       0x40   0x2900             CMP      R1,#+0
   \       0x42   0xD011             BEQ      ??Mem_Cmp_7
    662                      i = mem_align_mod_1;
   \       0x44   0xE008             B        ??Mem_Cmp_8
    663                      while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
    664                             (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
    665                             (i        > 0)) {                            /* ... until next CPU_ALIGN word boundary.              */
    666                          p1_mem_08--;
   \                     ??Mem_Cmp_9: (+1)
   \       0x46   0x1E5B             SUBS     R3,R3,#+1
    667                          p2_mem_08--;
   \       0x48   0x1E52             SUBS     R2,R2,#+1
    668                          if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
   \       0x4A   0x781D             LDRB     R5,[R3, #+0]
   \       0x4C   0x7816             LDRB     R6,[R2, #+0]
   \       0x4E   0x42B5             CMP      R5,R6
   \       0x50   0xD000             BEQ      ??Mem_Cmp_10
    669                               mem_cmp = DEF_NO;
   \       0x52   0x2000             MOVS     R0,#+0
    670                          }
    671                          size_rem -= sizeof(CPU_INT08U);
   \                     ??Mem_Cmp_10: (+1)
   \       0x54   0x1E64             SUBS     R4,R4,#+1
    672                          i--;
   \       0x56   0x1E49             SUBS     R1,R1,#+1
    673                      }
   \                     ??Mem_Cmp_8: (+1)
   \       0x58   0x0005             MOVS     R5,R0
   \       0x5A   0xB2ED             UXTB     R5,R5
   \       0x5C   0x2D01             CMP      R5,#+1
   \       0x5E   0xD103             BNE      ??Mem_Cmp_7
   \       0x60   0x2C00             CMP      R4,#+0
   \       0x62   0xD001             BEQ      ??Mem_Cmp_7
   \       0x64   0x2900             CMP      R1,#+0
   \       0x66   0xD1EE             BNE      ??Mem_Cmp_9
    674                  }
    675          
    676                  if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
   \                     ??Mem_Cmp_7: (+1)
   \       0x68   0x0001             MOVS     R1,R0
   \       0x6A   0xB2C9             UXTB     R1,R1
   \       0x6C   0x2901             CMP      R1,#+1
   \       0x6E   0xD117             BNE      ??Mem_Cmp_6
    677                      p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3a.                                        */
    678                      p2_mem_align = (CPU_ALIGN *)p2_mem_08;
   \       0x70   0xE007             B        ??Mem_Cmp_11
    679          
    680                      while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
    681                             (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
    682                          p1_mem_align--;
   \                     ??Mem_Cmp_12: (+1)
   \       0x72   0x1F1B             SUBS     R3,R3,#+4
    683                          p2_mem_align--;
   \       0x74   0x1F12             SUBS     R2,R2,#+4
    684                          if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
   \       0x76   0x6819             LDR      R1,[R3, #+0]
   \       0x78   0x6815             LDR      R5,[R2, #+0]
   \       0x7A   0x42A9             CMP      R1,R5
   \       0x7C   0xD000             BEQ      ??Mem_Cmp_13
    685                               mem_cmp = DEF_NO;
   \       0x7E   0x2000             MOVS     R0,#+0
    686                          }
    687                          size_rem -= sizeof(CPU_ALIGN);
   \                     ??Mem_Cmp_13: (+1)
   \       0x80   0x1F24             SUBS     R4,R4,#+4
    688                      }
   \                     ??Mem_Cmp_11: (+1)
   \       0x82   0x0001             MOVS     R1,R0
   \       0x84   0xB2C9             UXTB     R1,R1
   \       0x86   0x2901             CMP      R1,#+1
   \       0x88   0xD101             BNE      ??Mem_Cmp_14
   \       0x8A   0x2C04             CMP      R4,#+4
   \       0x8C   0xD2F1             BCS      ??Mem_Cmp_12
    689          
    690                      p1_mem_08 = (CPU_INT08U *)p1_mem_align;
    691                      p2_mem_08 = (CPU_INT08U *)p2_mem_align;
   \                     ??Mem_Cmp_14: (+1)
   \       0x8E   0xE007             B        ??Mem_Cmp_6
    692                  }
    693              }
    694          
    695              while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
    696                     (size_rem > 0)) {                                    /* ... for unaligned mem bufs or trailing octets.       */
    697                  p1_mem_08--;
   \                     ??Mem_Cmp_15: (+1)
   \       0x90   0x1E5B             SUBS     R3,R3,#+1
    698                  p2_mem_08--;
   \       0x92   0x1E52             SUBS     R2,R2,#+1
    699                  if (*p1_mem_08 != *p2_mem_08) {                         /* If ANY data octet(s) NOT identical, cmp fails.       */
   \       0x94   0x7819             LDRB     R1,[R3, #+0]
   \       0x96   0x7815             LDRB     R5,[R2, #+0]
   \       0x98   0x42A9             CMP      R1,R5
   \       0x9A   0xD000             BEQ      ??Mem_Cmp_16
    700                       mem_cmp = DEF_NO;
   \       0x9C   0x2000             MOVS     R0,#+0
    701                  }
    702                  size_rem -= sizeof(CPU_INT08U);
   \                     ??Mem_Cmp_16: (+1)
   \       0x9E   0x1E64             SUBS     R4,R4,#+1
    703              }
   \                     ??Mem_Cmp_6: (+1)
   \       0xA0   0x0001             MOVS     R1,R0
   \       0xA2   0xB2C9             UXTB     R1,R1
   \       0xA4   0x2901             CMP      R1,#+1
   \       0xA6   0xD101             BNE      ??Mem_Cmp_17
   \       0xA8   0x2C00             CMP      R4,#+0
   \       0xAA   0xD1F1             BNE      ??Mem_Cmp_15
    704          
    705              return (mem_cmp);
   \                     ??Mem_Cmp_17: (+1)
   \       0xAC   0xB2C0             UXTB     R0,R0
   \                     ??Mem_Cmp_1: (+1)
   \       0xAE   0xBDF0             POP      {R4-R7,PC}       ;; return
    706          }
    707          
    708          
    709          /*$PAGE*/
    710          /*
    711          *********************************************************************************************************
    712          *                                           Mem_HeapAlloc()
    713          *
    714          * Description : Allocate a memory block from the heap memory pool.
    715          *
    716          * Argument(s) : size            Size      of memory block to allocate (in octets).
    717          *
    718          *               align           Alignment of memory block to specific word boundary (in octets).
    719          *
    720          *               poctets_reqd    Optional pointer to a variable to ... :
    721          *
    722          *                                   (a) Return the number of octets required to successfully
    723          *                                           allocate the memory block, if any error(s);
    724          *                                   (b) Return 0, otherwise.
    725          *
    726          *               perr        Pointer to variable that will receive the return error code from this function :
    727          *
    728          *                               LIB_MEM_ERR_NONE                Memory block successfully returned.
    729          *                               LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory size.
    730          *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
    731          *                               LIB_MEM_ERR_HEAP_EMPTY          Heap segment empty; NOT enough available
    732          *                                                                   memory from heap.
    733          *                               LIB_MEM_ERR_HEAP_OVF            Requested memory overflows heap memory.
    734          *
    735          * Return(s)   : Pointer to memory block, if NO error(s).
    736          *
    737          *               Pointer to NULL,         otherwise.
    738          *
    739          * Caller(s)   : Application.
    740          *
    741          * Note(s)     : (1) Pointers to variables that return values MUST be initialized PRIOR to all other
    742          *                   validation or function handling in case of any error(s).
    743          *
    744          *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
    745          *********************************************************************************************************
    746          */
    747          /*$PAGE*/
    748          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    749          void  *Mem_HeapAlloc (CPU_SIZE_T   size,
    750                                CPU_SIZE_T   align,
    751                                CPU_SIZE_T  *poctets_reqd,
    752                                LIB_ERR     *perr)
    753          {
   \                     Mem_HeapAlloc: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x0015             MOVS     R5,R2
   \        0x8   0x001F             MOVS     R7,R3
    754              MEM_POOL    *pmem_pool_heap;
    755              void        *pmem_addr;
    756              void        *pmem_blk;
    757              CPU_SIZE_T   octets_reqd_unused;
    758              CPU_SIZE_T   size_rem;
    759              CPU_SIZE_T   size_req;
    760              CPU_SR_ALLOC();
   \        0xA   0x2600             MOVS     R6,#+0
   \        0xC   0x0030             MOVS     R0,R6
    761          
    762          
    763          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
    764              if (perr == (LIB_ERR *)0) {
   \        0xE   0x2F00             CMP      R7,#+0
   \       0x10   0xD101             BNE      ??Mem_HeapAlloc_0
    765                  CPU_SW_EXCEPTION((void *)0);
   \       0x12   0x....'....        BL       CPU_SW_Exception
   \                     ??Mem_HeapAlloc_0: (+1)
   \       0x16   0x9500             STR      R5,[SP, #+0]
    766              }
    767          #endif
    768          
    769                                                                              /* ------------ VALIDATE RTN OCTETS PTR ----------- */
    770              if (poctets_reqd == (CPU_SIZE_T *) 0) {                         /* If NOT avail, ...                                */
   \       0x18   0x9800             LDR      R0,[SP, #+0]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD102             BNE      ??Mem_HeapAlloc_1
    771                  poctets_reqd  = (CPU_SIZE_T *)&octets_reqd_unused;          /* ... re-cfg NULL rtn ptr to unused local var.     */
   \       0x1E   0xA803             ADD      R0,SP,#+12
   \       0x20   0x9000             STR      R0,[SP, #+0]
    772                 (void)&octets_reqd_unused;                                   /* Prevent possible 'variable unused' warning.      */
   \       0x22   0xA803             ADD      R0,SP,#+12
   \                     ??Mem_HeapAlloc_1: (+1)
   \       0x24   0x9401             STR      R4,[SP, #+4]
    773              }
    774             *poctets_reqd = 0u;                                              /* Init octets req'd for err (see Note #1).         */
   \       0x26   0x9800             LDR      R0,[SP, #+0]
   \       0x28   0x6006             STR      R6,[R0, #+0]
    775          
    776          
    777          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------ VALIDATE HEAP MEM ALLOC ----------- */
    778              if (size < 1) {
   \       0x2A   0x9801             LDR      R0,[SP, #+4]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD103             BNE      ??Mem_HeapAlloc_2
    779                 *perr = LIB_MEM_ERR_INVALID_MEM_SIZE;
   \       0x30   0x....             LDR      R0,??DataTable4  ;; 0x2774
   \       0x32   0x8038             STRH     R0,[R7, #+0]
    780                  return ((void *)0);
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xE044             B        ??Mem_HeapAlloc_3
    781              }
    782          
    783              if (align < 1) {
   \                     ??Mem_HeapAlloc_2: (+1)
   \       0x38   0x9804             LDR      R0,[SP, #+16]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD103             BNE      ??Mem_HeapAlloc_4
    784                 *perr = LIB_MEM_ERR_INVALID_MEM_ALIGN;
   \       0x3E   0x....             LDR      R0,??DataTable4_1  ;; 0x2775
   \       0x40   0x8038             STRH     R0,[R7, #+0]
    785                  return ((void *)0);
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xE03D             B        ??Mem_HeapAlloc_3
    786              }
    787          #endif
    788          
    789                                                                              /* -------------- ALLOC HEAP MEM BLK -------------- */
    790              pmem_pool_heap = &Mem_PoolHeap;
   \                     ??Mem_HeapAlloc_4: (+1)
   \       0x46   0x....             LDR      R6,??DataTable4_2
    791          
    792              CPU_CRITICAL_ENTER();
   \       0x48   0x....'....        BL       CPU_SR_Save
   \       0x4C   0x0005             MOVS     R5,R0
    793          
    794              pmem_addr = pmem_pool_heap->SegAddrNextAvail;
   \       0x4E   0x6BF0             LDR      R0,[R6, #+60]
    795              size_rem  = pmem_pool_heap->SegSizeRem;
   \       0x50   0x6C71             LDR      R1,[R6, #+68]
   \       0x52   0x9102             STR      R1,[SP, #+8]
    796              size_req  = Mem_SegCalcTotSize(pmem_addr,
    797                                             1u,                              /* Calc alloc for single mem blk from heap.         */
    798                                             size,
    799                                             align);
   \       0x54   0x9B04             LDR      R3,[SP, #+16]
   \       0x56   0x9A01             LDR      R2,[SP, #+4]
   \       0x58   0x2101             MOVS     R1,#+1
   \       0x5A   0x....'....        BL       Mem_SegCalcTotSize
   \       0x5E   0x0004             MOVS     R4,R0
    800          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    801              if (size_req < 1) {                                             /* If req'd size ovf, ...                           */
   \       0x60   0x2C00             CMP      R4,#+0
   \       0x62   0xD109             BNE      ??Mem_HeapAlloc_5
    802                  CPU_CRITICAL_EXIT();
   \       0x64   0x0028             MOVS     R0,R5
   \       0x66   0x....'....        BL       CPU_SR_Restore
    803                 *poctets_reqd = size;                                        /* ... rtn add'l heap size needed.                  */
   \       0x6A   0x9801             LDR      R0,[SP, #+4]
   \       0x6C   0x9900             LDR      R1,[SP, #+0]
   \       0x6E   0x6008             STR      R0,[R1, #+0]
    804                 *perr         = LIB_MEM_ERR_HEAP_OVF;
   \       0x70   0x....             LDR      R0,??DataTable4_3  ;; 0x27e3
   \       0x72   0x8038             STRH     R0,[R7, #+0]
    805                  return ((void *)0);
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xE024             B        ??Mem_HeapAlloc_3
    806              }
    807          #endif
    808          
    809              if (size_req > size_rem) {                                      /* If req'd size > rem heap size, ...               */
   \                     ??Mem_HeapAlloc_5: (+1)
   \       0x78   0x9802             LDR      R0,[SP, #+8]
   \       0x7A   0x42A0             CMP      R0,R4
   \       0x7C   0xD20A             BCS      ??Mem_HeapAlloc_6
    810                  CPU_CRITICAL_EXIT();
   \       0x7E   0x0028             MOVS     R0,R5
   \       0x80   0x....'....        BL       CPU_SR_Restore
    811                 *poctets_reqd = size_req - size_rem;                         /* ... rtn add'l heap size needed.                  */
   \       0x84   0x9802             LDR      R0,[SP, #+8]
   \       0x86   0x1A20             SUBS     R0,R4,R0
   \       0x88   0x9900             LDR      R1,[SP, #+0]
   \       0x8A   0x6008             STR      R0,[R1, #+0]
    812                 *perr         = LIB_MEM_ERR_HEAP_EMPTY;
   \       0x8C   0x....             LDR      R0,??DataTable4_4  ;; 0x27e2
   \       0x8E   0x8038             STRH     R0,[R7, #+0]
    813                  return ((void *)0);
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0xE016             B        ??Mem_HeapAlloc_3
    814              }
    815          
    816              pmem_blk = Mem_SegAlloc(pmem_pool_heap, size, align);
   \                     ??Mem_HeapAlloc_6: (+1)
   \       0x94   0x9A04             LDR      R2,[SP, #+16]
   \       0x96   0x9901             LDR      R1,[SP, #+4]
   \       0x98   0x0030             MOVS     R0,R6
   \       0x9A   0x....'....        BL       Mem_SegAlloc
   \       0x9E   0x0006             MOVS     R6,R0
    817              if (pmem_blk == (void *)0) {                                    /* If mem blk NOT avail from heap, ...              */
   \       0xA0   0x2E00             CMP      R6,#+0
   \       0xA2   0xD108             BNE      ??Mem_HeapAlloc_7
    818                  CPU_CRITICAL_EXIT();
   \       0xA4   0x0028             MOVS     R0,R5
   \       0xA6   0x....'....        BL       CPU_SR_Restore
    819                 *poctets_reqd = size_req;                                    /* ... rtn add'l heap size needed.                  */
   \       0xAA   0x9800             LDR      R0,[SP, #+0]
   \       0xAC   0x6004             STR      R4,[R0, #+0]
    820                 *perr         = LIB_MEM_ERR_HEAP_EMPTY;
   \       0xAE   0x....             LDR      R0,??DataTable4_4  ;; 0x27e2
   \       0xB0   0x8038             STRH     R0,[R7, #+0]
    821                  return ((void *)0);
   \       0xB2   0x2000             MOVS     R0,#+0
   \       0xB4   0xE005             B        ??Mem_HeapAlloc_3
    822              }
    823          
    824              CPU_CRITICAL_EXIT();
   \                     ??Mem_HeapAlloc_7: (+1)
   \       0xB6   0x0028             MOVS     R0,R5
   \       0xB8   0x....'....        BL       CPU_SR_Restore
    825          
    826             *perr =  LIB_MEM_ERR_NONE;
   \       0xBC   0x....             LDR      R0,??DataTable4_5  ;; 0x2710
   \       0xBE   0x8038             STRH     R0,[R7, #+0]
    827          
    828              return (pmem_blk);
   \       0xC0   0x0030             MOVS     R0,R6
   \                     ??Mem_HeapAlloc_3: (+1)
   \       0xC2   0xB005             ADD      SP,SP,#+20
   \       0xC4   0xBDF0             POP      {R4-R7,PC}       ;; return
    829          }
    830          #endif
    831          
    832          
    833          /*$PAGE*/
    834          /*
    835          *********************************************************************************************************
    836          *                                        Mem_HeapGetSizeRem()
    837          *
    838          * Description : Get remaining heap memory size available to allocate.
    839          *
    840          * Argument(s) : align       Desired word boundary alignment (in octets) to return remaining memory size from.
    841          *
    842          *               perr        Pointer to variable that will receive the return error code from this function :
    843          *
    844          *                                                               ---- RETURNED BY Mem_PoolGetSizeRem() : ----
    845          *                               LIB_MEM_ERR_NONE                Heap memory pool remaining size successfully
    846          *                                                                   returned.
    847          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
    848          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
    849          *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
    850          *
    851          * Return(s)   : Remaining heap memory size (in octets), if NO error(s).
    852          *
    853          *               0,                                      otherwise.
    854          *
    855          * Caller(s)   : Application.
    856          *
    857          * Note(s)     : none.
    858          *********************************************************************************************************
    859          */
    860          
    861          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    862          CPU_SIZE_T  Mem_HeapGetSizeRem (CPU_SIZE_T   align,
    863                                          LIB_ERR     *perr)
    864          {
   \                     Mem_HeapGetSizeRem: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0x000A             MOVS     R2,R1
    865              CPU_SIZE_T  size_rem;
    866          
    867          
    868              size_rem = Mem_SegGetSizeRem(&Mem_PoolHeap, align, perr);
   \        0x4   0x0001             MOVS     R1,R0
   \        0x6   0x....             LDR      R0,??DataTable4_2
   \        0x8   0x....'....        BL       Mem_SegGetSizeRem
    869          
    870              return (size_rem);
   \        0xC   0xBD02             POP      {R1,PC}          ;; return
    871          }
    872          #endif
    873          
    874          
    875          /*$PAGE*/
    876          /*
    877          *********************************************************************************************************
    878          *                                         Mem_SegGetSizeRem()
    879          *
    880          * Description : Get memory pool's remaining segment size available to allocate.
    881          *
    882          * Argument(s) : pmem_pool   Pointer to a memory pool structure.
    883          *
    884          *               align       Desired word boundary alignment (in octets) to return remaining memory size from.
    885          *
    886          *               perr        Pointer to variable that will receive the return error code from this function :
    887          *
    888          *                               LIB_MEM_ERR_NONE                Memory segment remaining size successfully
    889          *                                                                   returned.
    890          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
    891          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
    892          *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
    893          *
    894          * Return(s)   : Remaining memory segment size (in octets) [see Note #1], if NO error(s).
    895          *
    896          *               0,                                                       otherwise.
    897          *
    898          * Caller(s)   : Application.
    899          *
    900          * Note(s)     : (1) Remaining size of memory segment returned from either :
    901          *
    902          *                   (a) Segment's configured dedicated memory, if any
    903          *                   (b) Heap memory pool,                      otherwise
    904          *
    905          *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
    906          *********************************************************************************************************
    907          */
    908          /*$PAGE*/
    909          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    910          CPU_SIZE_T  Mem_SegGetSizeRem (MEM_POOL    *pmem_pool,
    911                                         CPU_SIZE_T   align,
    912                                         LIB_ERR     *perr)
    913          {
   \                     Mem_SegGetSizeRem: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    914              MEM_POOL    *pmem_seg;
    915              MEM_POOL    *pmem_seg_size;
    916              CPU_SIZE_T   size_rem;
    917              CPU_SIZE_T   size_rem_mod;
    918              CPU_SIZE_T   seg_addr_mod;
    919              CPU_ADDR     seg_addr;
    920              CPU_SR_ALLOC();
   \        0x8   0x2700             MOVS     R7,#+0
   \        0xA   0x0038             MOVS     R0,R7
    921          
    922          
    923          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    924                                                                          /* --------------- VALIDATE RTN ERR PTR --------------- */
    925              if (perr == (LIB_ERR *)0) {
   \        0xC   0x2E00             CMP      R6,#+0
   \        0xE   0xD101             BNE      ??Mem_SegGetSizeRem_0
    926                  CPU_SW_EXCEPTION(0u);
   \       0x10   0x....'....        BL       CPU_SW_Exception
    927              }
    928                                                                          /* ---------------- VALIDATE MEM ALIGN ---------------- */
    929              if (align < 1) {
   \                     ??Mem_SegGetSizeRem_0: (+1)
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD103             BNE      ??Mem_SegGetSizeRem_1
    930                 *perr =  LIB_MEM_ERR_INVALID_MEM_ALIGN;
   \       0x18   0x....             LDR      R0,??DataTable4_1  ;; 0x2775
   \       0x1A   0x8030             STRH     R0,[R6, #+0]
    931                  return (0u);
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xE02D             B        ??Mem_SegGetSizeRem_2
    932              }
    933                                                                          /* ---------------- VALIDATE MEM POOL ----------------- */
    934              if (pmem_pool == (MEM_POOL *)0) {                           /* Validate mem ptr.                                    */
   \                     ??Mem_SegGetSizeRem_1: (+1)
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD103             BNE      ??Mem_SegGetSizeRem_3
    935                 *perr =  LIB_MEM_ERR_NULL_PTR;
   \       0x24   0x....             LDR      R0,??DataTable4_6  ;; 0x2711
   \       0x26   0x8030             STRH     R0,[R6, #+0]
    936                  return (0u);
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xE027             B        ??Mem_SegGetSizeRem_2
    937              }
    938          #endif
    939          
    940              CPU_CRITICAL_ENTER();
   \                     ??Mem_SegGetSizeRem_3: (+1)
   \       0x2C   0x....'....        BL       CPU_SR_Save
    941          
    942          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    943              switch (pmem_pool->Type) {                                  /* Validate mem pool type.                              */
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x....             LDR      R2,??DataTable4_7  ;; 0x4c4f4f50
   \       0x34   0x4291             CMP      R1,R2
   \       0x36   0xD002             BEQ      ??Mem_SegGetSizeRem_4
   \       0x38   0x....             LDR      R2,??DataTable4_8  ;; 0x50414548
   \       0x3A   0x4291             CMP      R1,R2
   \       0x3C   0xD104             BNE      ??Mem_SegGetSizeRem_5
    944                  case LIB_MEM_TYPE_HEAP:
    945                  case LIB_MEM_TYPE_POOL:
    946                       break;
    947          
    948          
    949                  case LIB_MEM_TYPE_NONE:
    950                  default:
    951                       CPU_CRITICAL_EXIT();
    952                      *perr =  LIB_MEM_ERR_INVALID_POOL;
    953                       return (0u);                                       /* Prevent 'break NOT reachable' compiler warning.      */
    954              }
    955          #endif
    956          
    957                                                                          /* ------------- GET REM'ING MEM SEG SIZE ------------- */
    958              pmem_seg      =  pmem_pool->SegHeadPtr;                     /* Get mem pool's head seg.                             */
   \                     ??Mem_SegGetSizeRem_4: (+1)
   \       0x3E   0x6861             LDR      R1,[R4, #+4]
    959              pmem_seg_size = (pmem_seg->SegAddr != (void *)0)
    960                            ?  pmem_seg : &Mem_PoolHeap;                  /* See Note #1.                                         */
   \       0x40   0x6B8A             LDR      R2,[R1, #+56]
   \       0x42   0x2A00             CMP      R2,#+0
   \       0x44   0xD006             BEQ      ??Mem_SegGetSizeRem_6
   \       0x46   0xE006             B        ??Mem_SegGetSizeRem_7
   \                     ??Mem_SegGetSizeRem_5: (+1)
   \       0x48   0x....'....        BL       CPU_SR_Restore
   \       0x4C   0x....             LDR      R0,??DataTable4_9  ;; 0x2788
   \       0x4E   0x8030             STRH     R0,[R6, #+0]
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xE013             B        ??Mem_SegGetSizeRem_2
   \                     ??Mem_SegGetSizeRem_6: (+1)
   \       0x54   0x....             LDR      R1,??DataTable4_2
    961              size_rem      =  pmem_seg_size->SegSizeRem;                 /* Get mem seg's rem'ing mem size.                      */
   \                     ??Mem_SegGetSizeRem_7: (+1)
   \       0x56   0x6C4C             LDR      R4,[R1, #+68]
    962              seg_addr      = (CPU_ADDR)pmem_seg_size->SegAddrNextAvail;
   \       0x58   0x6BC9             LDR      R1,[R1, #+60]
   \       0x5A   0x9100             STR      R1,[SP, #+0]
    963          
    964              CPU_CRITICAL_EXIT();
   \       0x5C   0x....'....        BL       CPU_SR_Restore
    965          
    966              if (align > 1) {                                            /* If align > 1 octet, ...                              */
   \       0x60   0x2D02             CMP      R5,#+2
   \       0x62   0xD308             BCC      ??Mem_SegGetSizeRem_8
    967                  seg_addr_mod  =  seg_addr % align;
   \       0x64   0x9800             LDR      R0,[SP, #+0]
   \       0x66   0x0029             MOVS     R1,R5
   \       0x68   0x....'....        BL       __aeabi_uidivmod
    968                  size_rem_mod  = (seg_addr_mod > 0u) ? (align - seg_addr_mod) : 0u;
   \       0x6C   0x2900             CMP      R1,#+0
   \       0x6E   0xD001             BEQ      ??Mem_SegGetSizeRem_9
   \       0x70   0x1A6F             SUBS     R7,R5,R1
   \       0x72   0xE7FF             B        ??Mem_SegGetSizeRem_10
    969                  size_rem     -=  size_rem_mod;                          /* ... adj rem'ing size by offset to align'd seg addr.  */
   \                     ??Mem_SegGetSizeRem_9: (+1)
   \                     ??Mem_SegGetSizeRem_10: (+1)
   \       0x74   0x1BE4             SUBS     R4,R4,R7
    970              }
    971          
    972          
    973             *perr =  LIB_MEM_ERR_NONE;
   \                     ??Mem_SegGetSizeRem_8: (+1)
   \       0x76   0x....             LDR      R0,??DataTable4_5  ;; 0x2710
   \       0x78   0x8030             STRH     R0,[R6, #+0]
    974          
    975              return (size_rem);
   \       0x7A   0x0020             MOVS     R0,R4
   \                     ??Mem_SegGetSizeRem_2: (+1)
   \       0x7C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    976          }
    977          #endif
    978          
    979          
    980          /*$PAGE*/
    981          /*
    982          *********************************************************************************************************
    983          *                                            Mem_PoolClr()
    984          *
    985          * Description : Clear a memory pool (see Note #1).
    986          *
    987          * Argument(s) : pmem_pool   Pointer to a memory pool structure to clear (see Note #2).
    988          *
    989          *               perr        Pointer to variable that will receive the return error code from this function :
    990          *
    991          *                               LIB_MEM_ERR_NONE                Memory pool successfully cleared.
    992          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
    993          *
    994          * Return(s)   : none.
    995          *
    996          * Caller(s)   : Application,
    997          *               Mem_PoolCreate().
    998          *
    999          * Note(s)     : (1) (a) Mem_PoolClr() ONLY clears a memory pool structure's variables & should ONLY be
   1000          *                       called to initialize a memory pool structure prior to calling Mem_PoolCreate().
   1001          *
   1002          *                   (b) Mem_PoolClr() does NOT deallocate memory from the memory pool or deallocate the
   1003          *                       memory pool itself & MUST NOT be called after calling Mem_PoolCreate() since
   1004          *                       this will likely corrupt the memory pool management.
   1005          *
   1006          *               (2) Assumes 'pmem_pool' points to a valid memory pool (if non-NULL).
   1007          *********************************************************************************************************
   1008          */
   1009          
   1010          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1011          void  Mem_PoolClr (MEM_POOL  *pmem_pool,
   1012                             LIB_ERR   *perr)
   1013          {
   \                     Mem_PoolClr: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   1014          
   1015          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE RTN ERR  PTR --------------- */
   1016              if (perr == (LIB_ERR *)0) {
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE      ??Mem_PoolClr_0
   1017                  CPU_SW_EXCEPTION(;);
   \        0xA   0x....'....        BL       CPU_SW_Exception
   1018              }
   1019          #endif
   1020          
   1021                                                                          /* -------------- VALIDATE MEM POOL PTR --------------- */
   1022              if (pmem_pool == (MEM_POOL *)0) {
   \                     ??Mem_PoolClr_0: (+1)
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD102             BNE      ??Mem_PoolClr_1
   1023                 *perr = LIB_MEM_ERR_NULL_PTR;
   \       0x12   0x....             LDR      R0,??DataTable4_6  ;; 0x2711
   \       0x14   0x8020             STRH     R0,[R4, #+0]
   1024                  return;
   \       0x16   0xE015             B        ??Mem_PoolClr_2
   1025              }
   1026          
   1027          
   1028              pmem_pool->Type             = (LIB_MEM_TYPE)LIB_MEM_TYPE_NONE;
   \                     ??Mem_PoolClr_1: (+1)
   \       0x18   0x....             LDR      R0,??DataTable4_10  ;; 0x454e4f4e
   \       0x1A   0x6028             STR      R0,[R5, #+0]
   1029              pmem_pool->SegHeadPtr       = (MEM_POOL   *)0;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x6068             STR      R0,[R5, #+4]
   1030              pmem_pool->SegPrevPtr       = (MEM_POOL   *)0;
   \       0x20   0x60A8             STR      R0,[R5, #+8]
   1031              pmem_pool->SegNextPtr       = (MEM_POOL   *)0;
   \       0x22   0x60E8             STR      R0,[R5, #+12]
   1032              pmem_pool->PoolPrevPtr      = (MEM_POOL   *)0;
   \       0x24   0x6128             STR      R0,[R5, #+16]
   1033              pmem_pool->PoolNextPtr      = (MEM_POOL   *)0;
   \       0x26   0x6168             STR      R0,[R5, #+20]
   1034              pmem_pool->PoolAddrStart    = (void       *)0;
   \       0x28   0x61A8             STR      R0,[R5, #+24]
   1035              pmem_pool->PoolAddrEnd      = (void       *)0;
   \       0x2A   0x61E8             STR      R0,[R5, #+28]
   1036              pmem_pool->PoolPtrs         = (void      **)0;
   \       0x2C   0x6228             STR      R0,[R5, #+32]
   1037              pmem_pool->PoolSize         = (CPU_SIZE_T  )0u;
   \       0x2E   0x62A8             STR      R0,[R5, #+40]
   1038              pmem_pool->BlkAlign         = (CPU_SIZE_T  )0u;
   \       0x30   0x6368             STR      R0,[R5, #+52]
   1039              pmem_pool->BlkSize          = (CPU_SIZE_T  )0u;
   \       0x32   0x6328             STR      R0,[R5, #+48]
   1040              pmem_pool->BlkNbr           = (CPU_SIZE_T  )0u;
   \       0x34   0x62E8             STR      R0,[R5, #+44]
   1041              pmem_pool->BlkIx            = (MEM_POOL_IX )0u;
   \       0x36   0x6268             STR      R0,[R5, #+36]
   1042              pmem_pool->SegAddr          = (void       *)0;
   \       0x38   0x63A8             STR      R0,[R5, #+56]
   1043              pmem_pool->SegAddrNextAvail = (void       *)0;
   \       0x3A   0x63E8             STR      R0,[R5, #+60]
   1044              pmem_pool->SegSizeTot       = (CPU_SIZE_T  )0u;
   \       0x3C   0x6428             STR      R0,[R5, #+64]
   1045              pmem_pool->SegSizeRem       = (CPU_SIZE_T  )0u;
   \       0x3E   0x6468             STR      R0,[R5, #+68]
   1046          
   1047          
   1048             *perr = LIB_MEM_ERR_NONE;
   \       0x40   0x....             LDR      R0,??DataTable4_5  ;; 0x2710
   \       0x42   0x8020             STRH     R0,[R4, #+0]
   1049          }
   \                     ??Mem_PoolClr_2: (+1)
   \       0x44   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1050          #endif
   1051          
   1052          
   1053          /*$PAGE*/
   1054          /*
   1055          *********************************************************************************************************
   1056          *                                          Mem_PoolCreate()
   1057          *
   1058          * Description : (1) Create a memory pool :
   1059          *
   1060          *                   (a) Create    memory pool from heap or dedicated memory
   1061          *                   (b) Allocate  memory pool memory blocks
   1062          *                   (c) Update    memory pool table
   1063          *                   (d) Configure memory pool
   1064          *
   1065          *
   1066          *               (2) Memory pools are indexed by the Memory Segments they use.
   1067          *
   1068          *                   (a) The memory pool table is composed by a two-dimensional list :
   1069          *
   1070          *                       (1) Memory segments manage the following memory segment/pool information :
   1071          *
   1072          *                           (A) Memory segment base           address
   1073          *                           (B) Memory segment next available address
   1074          *                           (C) Memory segment total     size
   1075          *                           (D) Memory segment remaining size
   1076          *
   1077          *                       (2) Memory pools share memory from memory segments but do NOT manage any memory
   1078          *                           segment information.  To access the memory segment information, the head
   1079          *                           memory segment must be accessed via each memory pool's 'SegHeadPtr'.
   1080          *
   1081          *                   (b) In the diagram below, memory pools in vertical columns represent they share the same
   1082          *                       memory segment for the memory blocks they have.  The heads of the memory pool are
   1083          *                       linked horizontally to form a memory pool table.
   1084          *
   1085          *                       (1) 'Mem_PoolTbl' points to the head of the Memory Pool table.
   1086          *
   1087          *                       (2) Memory Pools' 'SegPrevPtr'  & 'SegNextPtr'  doubly-link each memory segment to
   1088          *                           form the list of memory segments.
   1089          *
   1090          *                       (3) Memory Pools' 'PoolPrevPtr' & 'PoolNextPtr' doubly-link the  memory pools of
   1091          *                           each memory segment.
   1092          *
   1093          *                   (c) New memory pools, which do not share a memory segment, are inserted in the Memory
   1094          *                       Segments Primary List.  The point of insertion is such to keep ascended order by
   1095          *                       memory segment base address.
   1096          *
   1097          *                   (d) Memory pool pointers to memory blocks 'PoolPtrs' must be allocated for each created
   1098          *                       memory pool.  These pointers are stored in the memory pool heap segment 'Mem_PoolHeap'.
   1099          *
   1100          *                       (1) A memory pool can also have its memory blocks allocated from the memory pool heap.
   1101          *                           'pmem_base_addr' must be set to NULL & 'mem_size' must be set to (0) to create the
   1102          *                           memory pool.
   1103          *
   1104          *
   1105          *                                        |                                                                 |
   1106          *                                        |<----------------------- Memory Segments ----------------------->|
   1107          *                                        |                         (see Note #2a1)                         |
   1108          *
   1109          *                                 Lowest Memory Segment                                      Highest Memory Segment
   1110          *                                     Base Address                                                Base Address
   1111          *                                    (see Note #2c)                                              (see Note #2c)
   1112          *
   1113          *                                           |             SegNextPtr             Heap Memory Pool       |
   1114          *                                           |          (see Note #2b2)            (see Note #2d)        |
   1115          *                                           |                     |                                     |
   1116          *                                           v                     |                      |              v
   1117          *                                                                 |                      v
   1118          *        ---          Head of Memory     -------        -------   v    -------        -------        -------
   1119          *         ^             Pool Table   --->|     |------->|     |------->|     |------->|     |------->|     |
   1120          *         |          (see Note #2b1)     |     |        |     |        |     |        |  H  |        |     |
   1121          *         |                              |     |<-------|     |<-------|     |<-------|  E  |<-------|     |
   1122          *         |                              |     |        |     |   ^    |     |        |  A  |        |     |
   1123          *         |                              |     |        |     |   |    |     |        |  P  |        |     |
   1124          *         |                              |     |        |     |   |    |     |        |     |        |     |
   1125          *         |                              -------        -------   |    -------        -------        -------
   1126          *         |                                | ^                    |      | ^
   1127          *         |                                | |            SegPrevPtr     | |
   1128          *         |                                v |         (see Note #2b2)   v |
   1129          *         |                              -------                       -------
   1130          *                                        |     |                       |     |
   1131          *    Memory Pools                        |     |                       |     |
   1132          *  (see Note #2a2)                       |     |                       |     |
   1133          *                                        |     |                       |     |
   1134          *         |                              |     |                       |     |
   1135          *         |                              -------                       -------
   1136          *         |                                | ^
   1137          *         |               PoolNextPtr ---> | | <--- PoolPrevPtr
   1138          *         |             (see Note #2b3)    v |    (see Note #2b3)
   1139          *         |                              -------
   1140          *         |                              |     |
   1141          *         |                              |     |
   1142          *         |                              |     |
   1143          *         |                              |     |
   1144          *         v                              |     |
   1145          *        ---                             -------
   1146          *
   1147          *$PAGE*
   1148          * Argument(s) : pmem_pool           Pointer to a memory pool structure to create (see Note #3).
   1149          *
   1150          *               pmem_base_addr      Memory pool base address :
   1151          *
   1152          *                                       (a)     Null address    Memory pool allocated from general-purpose heap.
   1153          *                                       (b) Non-null address    Memory pool allocated from dedicated memory
   1154          *                                                                   specified by its base address.
   1155          *
   1156          *               mem_size            Size      of memory pool segment          (in octets).
   1157          *
   1158          *               blk_nbr             Number    of memory pool blocks to create.
   1159          *
   1160          *               blk_size            Size      of memory pool blocks to create (in octets).
   1161          *
   1162          *               blk_align           Alignment of memory pool blocks to specific word boundary (in octets).
   1163          *
   1164          *               poctets_reqd        Optional pointer to a variable to ... :
   1165          *
   1166          *                                       (a) Return the number of octets required to successfully
   1167          *                                               allocate the memory pool, if any error(s);
   1168          *                                       (b) Return 0, otherwise.
   1169          *
   1170          *               perr        Pointer to variable that will receive the return error code from this function :
   1171          *
   1172          *                               LIB_MEM_ERR_NONE                    Memory pool successfully created.
   1173          *
   1174          *                               LIB_MEM_ERR_HEAP_NOT_FOUND          Heap   segment NOT found.
   1175          *                               LIB_MEM_ERR_HEAP_EMPTY              Heap   segment empty; NOT enough available
   1176          *                                                                       memory from heap.
   1177          *                               LIB_MEM_ERR_HEAP_OVF                Requested memory overflows heap    memory.
   1178          *                               LIB_MEM_ERR_SEG_EMPTY               Memory segment empty; NOT enough available
   1179          *                                                                       memory from segment for memory pools.
   1180          *                               LIB_MEM_ERR_SEG_OVF                 Requested memory overflows segment memory.
   1181          *
   1182          *                               LIB_MEM_ERR_INVALID_SEG_SIZE        Invalid memory segment size.
   1183          *                               LIB_MEM_ERR_INVALID_SEG_OVERLAP     Memory segment overlaps other memory
   1184          *                                                                       segment(s) in memory pool table.
   1185          *                               LIB_MEM_ERR_INVALID_BLK_NBR         Invalid memory pool number of blocks.
   1186          *                               LIB_MEM_ERR_INVALID_BLK_SIZE        Invalid memory pool block size.
   1187          *                               LIB_MEM_ERR_INVALID_BLK_ALIGN       Invalid memory pool block alignment.
   1188          *
   1189          *                                                                   ------- RETURNED BY Mem_PoolClr() : -------
   1190          *                               LIB_MEM_ERR_NULL_PTR                Argument 'pmem_pool' passed a NULL pointer.
   1191          *
   1192          * Return(s)   : none.
   1193          *
   1194          * Caller(s)   : Application.
   1195          *
   1196          * Note(s)     : (3) Assumes 'pmem_pool' points to a valid memory pool (if non-NULL).
   1197          *
   1198          *               (4) Pointers to variables that return values MUST be initialized PRIOR to all other
   1199          *                   validation or function handling in case of any error(s).
   1200          *
   1201          *               (5) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1202          *********************************************************************************************************
   1203          */
   1204          /*$PAGE*/
   1205          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 4, keep-with-next
   1206          void  Mem_PoolCreate (MEM_POOL          *pmem_pool,
   1207                                void              *pmem_base_addr,
   1208                                CPU_SIZE_T         mem_size,
   1209                                MEM_POOL_BLK_QTY   blk_nbr,
   1210                                CPU_SIZE_T         blk_size,
   1211                                CPU_SIZE_T         blk_align,
   1212                                CPU_SIZE_T        *poctets_reqd,
   1213                                LIB_ERR           *perr)
   1214          {
   \                     Mem_PoolCreate: (+1)
   \        0x0   0xB5F6             PUSH     {R1,R2,R4-R7,LR}
   \        0x2   0xB08B             SUB      SP,SP,#+44
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x001F             MOVS     R7,R3
   \        0xA   0x9D15             LDR      R5,[SP, #+84]
   1215              MEM_POOL           *pmem_pool_heap;
   1216              MEM_POOL           *pmem_pool_next;
   1217              MEM_POOL           *pmem_seg;
   1218              MEM_POOL           *pmem_seg_prev;
   1219              MEM_POOL           *pmem_seg_next;
   1220              void              **ppool_ptr;
   1221              void               *pmem_blk;
   1222              CPU_INT08U         *pmem_addr_ptrs;
   1223              CPU_INT08U         *pmem_addr_pool;
   1224              CPU_INT08U         *pmem_base_addr_start;
   1225              CPU_INT08U         *pmem_base_addr_end;
   1226              CPU_INT08U         *pmem_seg_addr_start;
   1227              CPU_INT08U         *pmem_seg_addr_end;
   1228              MEM_POOL_BLK_QTY    blk_rem;
   1229              CPU_SIZE_T          octets_reqd_unused;
   1230              CPU_SIZE_T          size_tot;
   1231              CPU_SIZE_T          size_tot_ptrs;
   1232              CPU_SIZE_T          size_tot_pool;
   1233              CPU_SIZE_T          size_rem;
   1234              CPU_SIZE_T          size_pool_ptrs;
   1235              CPU_SIZE_T          i;
   1236              CPU_SR_ALLOC();
   \        0xC   0x2000             MOVS     R0,#+0
   1237          
   1238          
   1239          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   1240              if (perr == (LIB_ERR *)0) {
   \        0xE   0x2D00             CMP      R5,#+0
   \       0x10   0xD101             BNE      ??Mem_PoolCreate_2
   1241                  CPU_SW_EXCEPTION(;);
   \       0x12   0x....'....        BL       CPU_SW_Exception
   1242              }
   1243          #endif
   1244          
   1245                                                                              /* ------------ VALIDATE RTN OCTETS PTR ----------- */
   1246              if (poctets_reqd == (CPU_SIZE_T *) 0) {                         /* If NOT avail, ...                                */
   \                     ??Mem_PoolCreate_2: (+1)
   \       0x16   0x9814             LDR      R0,[SP, #+80]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD102             BNE      ??Mem_PoolCreate_3
   1247                  poctets_reqd  = (CPU_SIZE_T *)&octets_reqd_unused;          /* ... re-cfg NULL rtn ptr to unused local var.     */
   \       0x1C   0xA80A             ADD      R0,SP,#+40
   \       0x1E   0x9014             STR      R0,[SP, #+80]
   1248                 (void)&octets_reqd_unused;                                   /* Prevent possible 'variable unused' warning.      */
   \       0x20   0xA80A             ADD      R0,SP,#+40
   \                     ??Mem_PoolCreate_3: (+1)
   \       0x22   0x9600             STR      R6,[SP, #+0]
   1249              }
   1250             *poctets_reqd = 0u;                                              /* Init octets req'd for err (see Note #4).         */
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x9914             LDR      R1,[SP, #+80]
   \       0x28   0x6008             STR      R0,[R1, #+0]
   1251          
   1252          
   1253          
   1254              Mem_PoolClr(pmem_pool, perr);                                   /* Init mem pool     for err (see Note #4).         */
   \       0x2A   0x0029             MOVS     R1,R5
   \       0x2C   0x9800             LDR      R0,[SP, #+0]
   \       0x2E   0x....'....        BL       Mem_PoolClr
   1255              if (*perr != LIB_MEM_ERR_NONE) {
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x5E28             LDRSH    R0,[R5, R0]
   \       0x36   0x49B6             LDR      R1,??Mem_PoolCreate_0  ;; 0x2710
   \       0x38   0x4288             CMP      R0,R1
   \       0x3A   0xD000             BEQ      .+4
   \       0x3C   0xE1C2             B        ??Mem_PoolCreate_4
   1256                   return;
   \                     ??Mem_PoolCreate_5: (+1)
   \       0x3E   0x9406             STR      R4,[SP, #+24]
   \       0x40   0x9E0C             LDR      R6,[SP, #+48]
   1257              }
   1258          
   1259          
   1260                                                                              /* ----------- VALIDATE MEM POOL CREATE ----------- */
   1261          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1262              if (pmem_base_addr != (void *)0) {
   \       0x42   0x9806             LDR      R0,[SP, #+24]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD004             BEQ      ??Mem_PoolCreate_6
   1263                  if (mem_size < 1) {
   \       0x48   0x2E00             CMP      R6,#+0
   \       0x4A   0xD102             BNE      ??Mem_PoolCreate_6
   1264                     *perr = LIB_MEM_ERR_INVALID_SEG_SIZE;
   \       0x4C   0x48B1             LDR      R0,??Mem_PoolCreate_0+0x4  ;; 0x277e
   \       0x4E   0x8028             STRH     R0,[R5, #+0]
   1265                      return;
   \       0x50   0xE1B8             B        ??Mem_PoolCreate_4
   1266                  }
   1267              }
   \                     ??Mem_PoolCreate_6: (+1)
   \       0x52   0x9702             STR      R7,[SP, #+8]
   1268          
   1269              if (blk_nbr < 1) {
   \       0x54   0x9802             LDR      R0,[SP, #+8]
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD102             BNE      ??Mem_PoolCreate_7
   1270                 *perr = LIB_MEM_ERR_INVALID_BLK_NBR;
   \       0x5A   0x48BB             LDR      R0,??Mem_PoolCreate_1  ;; 0x2792
   \       0x5C   0x8028             STRH     R0,[R5, #+0]
   1271                  return;
   \       0x5E   0xE1B1             B        ??Mem_PoolCreate_4
   1272              }
   1273          
   1274              if (blk_size < 1) {
   \                     ??Mem_PoolCreate_7: (+1)
   \       0x60   0x9812             LDR      R0,[SP, #+72]
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD102             BNE      ??Mem_PoolCreate_8
   1275                 *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
   \       0x66   0x48B9             LDR      R0,??Mem_PoolCreate_1+0x4  ;; 0x2793
   \       0x68   0x8028             STRH     R0,[R5, #+0]
   1276                  return;
   \       0x6A   0xE1AB             B        ??Mem_PoolCreate_4
   1277              }
   1278          
   1279              if (blk_align < 1) {
   \                     ??Mem_PoolCreate_8: (+1)
   \       0x6C   0x9813             LDR      R0,[SP, #+76]
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD102             BNE      ??Mem_PoolCreate_9
   1280                 *perr = LIB_MEM_ERR_INVALID_BLK_ALIGN;
   \       0x72   0x48B7             LDR      R0,??Mem_PoolCreate_1+0x8  ;; 0x2794
   \       0x74   0x8028             STRH     R0,[R5, #+0]
   1281                  return;
   \       0x76   0xE1A5             B        ??Mem_PoolCreate_4
   1282              }
   1283          #endif
   1284          
   1285          
   1286                                                                              /* ------------ VALIDATE MEM POOL TBL ------------- */
   1287              if (Mem_PoolTbl == (MEM_POOL *)0) {
   \                     ??Mem_PoolCreate_9: (+1)
   \       0x78   0x48B6             LDR      R0,??Mem_PoolCreate_1+0xC
   \       0x7A   0x6800             LDR      R0,[R0, #+0]
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD102             BNE      ??Mem_PoolCreate_10
   1288                 *perr = LIB_MEM_ERR_HEAP_NOT_FOUND;
   \       0x80   0x48B5             LDR      R0,??Mem_PoolCreate_1+0x10  ;; 0x27e7
   \       0x82   0x8028             STRH     R0,[R5, #+0]
   1289                  return;
   \       0x84   0xE19E             B        ??Mem_PoolCreate_4
   1290              }
   1291          
   1292          
   1293          
   1294          /*$PAGE*/
   1295                                                                              /* ---------------- CREATE MEM POOL --------------- */
   1296              pmem_pool_heap = (MEM_POOL *)&Mem_PoolHeap;
   \                     ??Mem_PoolCreate_10: (+1)
   \       0x86   0x48B5             LDR      R0,??Mem_PoolCreate_1+0x14
   \       0x88   0x9003             STR      R0,[SP, #+12]
   1297              size_tot       = (CPU_SIZE_T) 0u;
   \       0x8A   0x2000             MOVS     R0,#+0
   \       0x8C   0x9005             STR      R0,[SP, #+20]
   1298          
   1299              CPU_CRITICAL_ENTER();
   \       0x8E   0x....'....        BL       CPU_SR_Save
   \       0x92   0x0007             MOVS     R7,R0
   1300          
   1301              if (pmem_base_addr == (void *)0) {                              /* If no base addr, cfg mem pool from heap.         */
   \       0x94   0x9806             LDR      R0,[SP, #+24]
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD14B             BNE      ??Mem_PoolCreate_11
   1302                  pmem_seg        =  pmem_pool_heap;
   \       0x9A   0x9803             LDR      R0,[SP, #+12]
   \       0x9C   0x9001             STR      R0,[SP, #+4]
   1303                  pmem_seg_prev   =  pmem_pool_heap;
   \       0x9E   0x9803             LDR      R0,[SP, #+12]
   \       0xA0   0x9008             STR      R0,[SP, #+32]
   1304                  pmem_seg_next   =  pmem_pool_heap;
   \       0xA2   0x9C03             LDR      R4,[SP, #+12]
   1305          
   1306                                                                              /* --------------- VALIDATE MEM SEG --------------- */
   1307                                                                              /* Calc tot mem   size for mem pool ptrs.           */
   1308                  pmem_addr_ptrs  = (CPU_INT08U *)pmem_pool_heap->SegAddrNextAvail;
   \       0xA4   0x9803             LDR      R0,[SP, #+12]
   \       0xA6   0x6BC6             LDR      R6,[R0, #+60]
   1309                  size_tot_ptrs   =  Mem_SegCalcTotSize((void     *)pmem_addr_ptrs,
   1310                                                        (CPU_SIZE_T)blk_nbr,
   1311                                                        (CPU_SIZE_T)sizeof(void *),
   1312                                                        (CPU_SIZE_T)sizeof(void *));
   \       0xA8   0x2304             MOVS     R3,#+4
   \       0xAA   0x2204             MOVS     R2,#+4
   \       0xAC   0x9902             LDR      R1,[SP, #+8]
   \       0xAE   0x0030             MOVS     R0,R6
   \       0xB0   0x....'....        BL       Mem_SegCalcTotSize
   \       0xB4   0x9004             STR      R0,[SP, #+16]
   1313          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1314                  if (size_tot_ptrs < 1) {                                    /* If heap ovf, ...                                 */
   \       0xB6   0x9804             LDR      R0,[SP, #+16]
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD105             BNE      ??Mem_PoolCreate_12
   1315                      CPU_CRITICAL_EXIT();
   \       0xBC   0x0038             MOVS     R0,R7
   \       0xBE   0x....'....        BL       CPU_SR_Restore
   1316                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   \       0xC2   0x....             LDR      R0,??DataTable5  ;; 0x27e3
   \       0xC4   0x8028             STRH     R0,[R5, #+0]
   1317                      return;
   \       0xC6   0xE17D             B        ??Mem_PoolCreate_4
   1318                  }
   1319          #endif
   1320                                                                              /* Calc tot mem   size for mem blks.                */
   1321                  pmem_addr_pool  =  pmem_addr_ptrs + size_tot_ptrs;          /* Adj next avail addr for mem pool blks.           */
   \                     ??Mem_PoolCreate_12: (+1)
   \       0xC8   0x9804             LDR      R0,[SP, #+16]
   \       0xCA   0x1830             ADDS     R0,R6,R0
   \       0xCC   0x9007             STR      R0,[SP, #+28]
   1322                  size_tot_pool   =  Mem_SegCalcTotSize((void     *)pmem_addr_pool,
   1323                                                        (CPU_SIZE_T)blk_nbr,
   1324                                                        (CPU_SIZE_T)blk_size,
   1325                                                        (CPU_SIZE_T)blk_align);
   \       0xCE   0x9B13             LDR      R3,[SP, #+76]
   \       0xD0   0x9A12             LDR      R2,[SP, #+72]
   \       0xD2   0x9902             LDR      R1,[SP, #+8]
   \       0xD4   0x9807             LDR      R0,[SP, #+28]
   \       0xD6   0x....'....        BL       Mem_SegCalcTotSize
   \       0xDA   0x0006             MOVS     R6,R0
   1326          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1327                  if (size_tot_pool < 1) {                                    /* If heap ovf, ...                                 */
   \       0xDC   0x2E00             CMP      R6,#+0
   \       0xDE   0xD105             BNE      ??Mem_PoolCreate_13
   1328                      CPU_CRITICAL_EXIT();
   \       0xE0   0x0038             MOVS     R0,R7
   \       0xE2   0x....'....        BL       CPU_SR_Restore
   1329                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   \       0xE6   0x....             LDR      R0,??DataTable5  ;; 0x27e3
   \       0xE8   0x8028             STRH     R0,[R5, #+0]
   1330                      return;
   \       0xEA   0xE16B             B        ??Mem_PoolCreate_4
   1331                  }
   1332          #endif
   1333          
   1334                  size_tot = size_tot_ptrs + size_tot_pool;
   \                     ??Mem_PoolCreate_13: (+1)
   \       0xEC   0x9804             LDR      R0,[SP, #+16]
   \       0xEE   0x1980             ADDS     R0,R0,R6
   \       0xF0   0x9005             STR      R0,[SP, #+20]
   1335          
   1336          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1337                  if ((size_tot < size_tot_ptrs) ||                           /* If heap ovf, ...                                 */
   1338                      (size_tot < size_tot_pool)) {
   \       0xF2   0x9805             LDR      R0,[SP, #+20]
   \       0xF4   0x9904             LDR      R1,[SP, #+16]
   \       0xF6   0x4288             CMP      R0,R1
   \       0xF8   0xD302             BCC      ??Mem_PoolCreate_14
   \       0xFA   0x9805             LDR      R0,[SP, #+20]
   \       0xFC   0x42B0             CMP      R0,R6
   \       0xFE   0xD205             BCS      ??Mem_PoolCreate_15
   1339                      CPU_CRITICAL_EXIT();
   \                     ??Mem_PoolCreate_14: (+1)
   \      0x100   0x0038             MOVS     R0,R7
   \      0x102   0x....'....        BL       CPU_SR_Restore
   1340                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   \      0x106   0x....             LDR      R0,??DataTable5  ;; 0x27e3
   \      0x108   0x8028             STRH     R0,[R5, #+0]
   1341                      return;
   \      0x10A   0xE15B             B        ??Mem_PoolCreate_4
   1342                  }
   1343          #endif
   1344          
   1345                  size_rem = pmem_pool_heap->SegSizeRem;
   \                     ??Mem_PoolCreate_15: (+1)
   \      0x10C   0x9803             LDR      R0,[SP, #+12]
   \      0x10E   0x6C40             LDR      R0,[R0, #+68]
   \      0x110   0x9004             STR      R0,[SP, #+16]
   1346                  if (size_tot > size_rem) {                                  /* If tot size > rem  size, ...                     */
   \      0x112   0x9804             LDR      R0,[SP, #+16]
   \      0x114   0x9905             LDR      R1,[SP, #+20]
   \      0x116   0x4288             CMP      R0,R1
   \      0x118   0xD300             BCC      .+4
   \      0x11A   0xE099             B        ??Mem_PoolCreate_16
   1347                      CPU_CRITICAL_EXIT();
   \      0x11C   0x0038             MOVS     R0,R7
   \      0x11E   0x....'....        BL       CPU_SR_Restore
   1348                     *poctets_reqd = size_tot - size_rem;                     /* ... rtn add'l heap size needed.                  */
   \      0x122   0x9805             LDR      R0,[SP, #+20]
   \      0x124   0x9904             LDR      R1,[SP, #+16]
   \      0x126   0x1A40             SUBS     R0,R0,R1
   \      0x128   0x9914             LDR      R1,[SP, #+80]
   \      0x12A   0x6008             STR      R0,[R1, #+0]
   1349                     *perr         = LIB_MEM_ERR_HEAP_EMPTY;
   \      0x12C   0x....             LDR      R0,??DataTable6  ;; 0x27e2
   \      0x12E   0x8028             STRH     R0,[R5, #+0]
   1350                      return;
   \      0x130   0xE148             B        ??Mem_PoolCreate_4
   1351                  }
   1352          
   1353          /*$PAGE*/
   1354              } else {                                                        /* Else cfg mem pool from dedicated mem.            */
   1355                                                                              /* -------- SRCH ALL MEM SEGS FOR MEM POOL -------- */
   1356                  pmem_base_addr_start = (CPU_INT08U *)pmem_base_addr;
   \                     ??Mem_PoolCreate_11: (+1)
   \      0x132   0x9806             LDR      R0,[SP, #+24]
   \      0x134   0x9004             STR      R0,[SP, #+16]
   1357                  pmem_base_addr_end   = (CPU_INT08U *)pmem_base_addr + mem_size - 1;
   \      0x136   0x9806             LDR      R0,[SP, #+24]
   \      0x138   0x1980             ADDS     R0,R0,R6
   \      0x13A   0x1E40             SUBS     R0,R0,#+1
   1358          
   1359          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1360                  if (pmem_base_addr_end < pmem_base_addr_start) {            /* Chk ovf of end addr.                             */
   \      0x13C   0x9904             LDR      R1,[SP, #+16]
   \      0x13E   0x4288             CMP      R0,R1
   \      0x140   0xD205             BCS      ??Mem_PoolCreate_17
   1361                      CPU_CRITICAL_EXIT();
   \      0x142   0x0038             MOVS     R0,R7
   \      0x144   0x....'....        BL       CPU_SR_Restore
   1362                     *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
   \      0x148   0x....             LDR      R0,??DataTable6_1  ;; 0x2797
   \      0x14A   0x8028             STRH     R0,[R5, #+0]
   1363                      return;
   \      0x14C   0xE13A             B        ??Mem_PoolCreate_4
   1364                  }
   1365          #endif
   1366          
   1367                  pmem_seg      = (MEM_POOL *)0;
   \                     ??Mem_PoolCreate_17: (+1)
   \      0x14E   0x2100             MOVS     R1,#+0
   \      0x150   0x9101             STR      R1,[SP, #+4]
   1368                  pmem_seg_prev = (MEM_POOL *)0;
   \      0x152   0x2100             MOVS     R1,#+0
   \      0x154   0x9108             STR      R1,[SP, #+32]
   1369                  pmem_seg_next =  Mem_PoolTbl;
   \      0x156   0x497F             LDR      R1,??Mem_PoolCreate_1+0xC
   \      0x158   0x680C             LDR      R4,[R1, #+0]
   \      0x15A   0xE017             B        ??Mem_PoolCreate_18
   1370          
   1371                  while (pmem_seg_next != (MEM_POOL *)0) {                    /* Srch tbl for mem seg with same base addr/size.   */
   1372          
   1373                      if ((pmem_base_addr == pmem_seg_next->SegAddr) &&       /* If same base addr/size found, ...                */
   1374                          (mem_size       == pmem_seg_next->SegSizeTot)) {
   1375          
   1376                           pmem_seg        = pmem_seg_next;                   /* ... mem seg already avail in tbl.                */
   1377                           break;
   1378          
   1379                      } else {
   1380                          pmem_seg_addr_start = (CPU_INT08U *)pmem_seg_next->SegAddr;
   \                     ??Mem_PoolCreate_19: (+1)
   \      0x15C   0x6BA1             LDR      R1,[R4, #+56]
   1381                          pmem_seg_addr_end   = (CPU_INT08U *)pmem_seg_next->SegAddr + pmem_seg_next->SegSizeTot - 1;
   \      0x15E   0x6BA2             LDR      R2,[R4, #+56]
   \      0x160   0x6C23             LDR      R3,[R4, #+64]
   \      0x162   0x18D2             ADDS     R2,R2,R3
   \      0x164   0x1E52             SUBS     R2,R2,#+1
   1382          
   1383          
   1384                          if (pmem_base_addr_end < pmem_seg_addr_start) {     /* If mem seg addr/size prior to next mem seg, ...  */
   \      0x166   0x4288             CMP      R0,R1
   \      0x168   0xD339             BCC      ??Mem_PoolCreate_20
   1385                              break;                                          /* ... new mem seg NOT avail in tbl.                */
   1386          
   1387                                                                              /* If mem seg overlaps prev mem seg(s) in tbl, ...  */
   1388                          } else if (((pmem_base_addr_start <= pmem_seg_addr_start)  &&
   1389                                      (pmem_base_addr_end   >= pmem_seg_addr_start)) ||
   1390                                     ((pmem_base_addr_start >= pmem_seg_addr_start)  &&
   1391                                      (pmem_base_addr_end   <= pmem_seg_addr_end  )) ||
   1392                                     ((pmem_base_addr_start <= pmem_seg_addr_end  )  &&
   1393                                      (pmem_base_addr_end   >= pmem_seg_addr_end  ))) {
   \                     ??Mem_PoolCreate_21: (+1)
   \      0x16A   0x9B04             LDR      R3,[SP, #+16]
   \      0x16C   0x4299             CMP      R1,R3
   \      0x16E   0xD301             BCC      ??Mem_PoolCreate_22
   \      0x170   0x4288             CMP      R0,R1
   \      0x172   0xD235             BCS      ??Mem_PoolCreate_23
   \                     ??Mem_PoolCreate_22: (+1)
   \      0x174   0x9B04             LDR      R3,[SP, #+16]
   \      0x176   0x428B             CMP      R3,R1
   \      0x178   0xD301             BCC      ??Mem_PoolCreate_24
   \      0x17A   0x4282             CMP      R2,R0
   \      0x17C   0xD230             BCS      ??Mem_PoolCreate_23
   \                     ??Mem_PoolCreate_24: (+1)
   \      0x17E   0x9904             LDR      R1,[SP, #+16]
   \      0x180   0x428A             CMP      R2,R1
   \      0x182   0xD301             BCC      ??Mem_PoolCreate_25
   \      0x184   0x4290             CMP      R0,R2
   \      0x186   0xD22B             BCS      ??Mem_PoolCreate_23
   1394                              CPU_CRITICAL_EXIT();
   1395                             *perr = LIB_MEM_ERR_INVALID_SEG_OVERLAP;         /* ... rtn err.                                     */
   1396                              return;
   1397                          }
   1398                      }
   1399                                                                              /* If mem seg NOT found, adv to next mem seg.       */
   1400                      pmem_seg_prev = pmem_seg_next;
   \                     ??Mem_PoolCreate_25: (+1)
   \      0x188   0x9408             STR      R4,[SP, #+32]
   1401                      pmem_seg_next = pmem_seg_next->SegNextPtr;
   \      0x18A   0x68E4             LDR      R4,[R4, #+12]
   \                     ??Mem_PoolCreate_18: (+1)
   \      0x18C   0x2C00             CMP      R4,#+0
   \      0x18E   0xD007             BEQ      ??Mem_PoolCreate_26
   \      0x190   0x9906             LDR      R1,[SP, #+24]
   \      0x192   0x6BA2             LDR      R2,[R4, #+56]
   \      0x194   0x4291             CMP      R1,R2
   \      0x196   0xD1E1             BNE      ??Mem_PoolCreate_19
   \      0x198   0x6C21             LDR      R1,[R4, #+64]
   \      0x19A   0x428E             CMP      R6,R1
   \      0x19C   0xD1DE             BNE      ??Mem_PoolCreate_19
   \      0x19E   0x9401             STR      R4,[SP, #+4]
   1402                  }
   1403          
   1404                  if (pmem_seg == (MEM_POOL *)0) {                            /* If mem seg NOT found, add    new  mem seg.       */
   \                     ??Mem_PoolCreate_26: (+1)
   \      0x1A0   0x9801             LDR      R0,[SP, #+4]
   \      0x1A2   0x2800             CMP      R0,#+0
   \      0x1A4   0xD10B             BNE      ??Mem_PoolCreate_27
   1405                      pmem_seg                    = pmem_pool;
   \      0x1A6   0x9800             LDR      R0,[SP, #+0]
   \      0x1A8   0x9001             STR      R0,[SP, #+4]
   1406                      pmem_pool->SegAddr          = pmem_base_addr;
   \      0x1AA   0x9806             LDR      R0,[SP, #+24]
   \      0x1AC   0x9900             LDR      R1,[SP, #+0]
   \      0x1AE   0x6388             STR      R0,[R1, #+56]
   1407                      pmem_pool->SegAddrNextAvail = pmem_base_addr;
   \      0x1B0   0x9806             LDR      R0,[SP, #+24]
   \      0x1B2   0x9900             LDR      R1,[SP, #+0]
   \      0x1B4   0x63C8             STR      R0,[R1, #+60]
   1408                      pmem_pool->SegSizeTot       = mem_size;
   \      0x1B6   0x9800             LDR      R0,[SP, #+0]
   \      0x1B8   0x6406             STR      R6,[R0, #+64]
   1409                      pmem_pool->SegSizeRem       = mem_size;
   \      0x1BA   0x9800             LDR      R0,[SP, #+0]
   \      0x1BC   0x6446             STR      R6,[R0, #+68]
   1410                  }
   1411          
   1412          /*$PAGE*/
   1413                                                                              /* --------------- VALIDATE MEM SEG --------------- */
   1414                                                                              /* Calc tot mem size for mem pool ptrs.             */
   1415                  pmem_addr_ptrs = (CPU_INT08U *)pmem_pool_heap->SegAddrNextAvail;
   \                     ??Mem_PoolCreate_27: (+1)
   \      0x1BE   0x9803             LDR      R0,[SP, #+12]
   \      0x1C0   0x6BC0             LDR      R0,[R0, #+60]
   1416                  size_tot_ptrs  =  Mem_SegCalcTotSize((void     *)pmem_addr_ptrs,
   1417                                                       (CPU_SIZE_T)blk_nbr,
   1418                                                       (CPU_SIZE_T)sizeof(void *),
   1419                                                       (CPU_SIZE_T)sizeof(void *));
   \      0x1C2   0x2304             MOVS     R3,#+4
   \      0x1C4   0x2204             MOVS     R2,#+4
   \      0x1C6   0x9902             LDR      R1,[SP, #+8]
   \      0x1C8   0x....'....        BL       Mem_SegCalcTotSize
   \      0x1CC   0x0006             MOVS     R6,R0
   1420          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1421                  if (size_tot_ptrs < 1) {                                    /* If heap ovf, ...                                 */
   \      0x1CE   0x2E00             CMP      R6,#+0
   \      0x1D0   0xD10C             BNE      ??Mem_PoolCreate_28
   1422                      CPU_CRITICAL_EXIT();
   \      0x1D2   0x0038             MOVS     R0,R7
   \      0x1D4   0x....'....        BL       CPU_SR_Restore
   1423                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   \      0x1D8   0x....             LDR      R0,??DataTable5  ;; 0x27e3
   \      0x1DA   0x8028             STRH     R0,[R5, #+0]
   1424                      return;
   \      0x1DC   0xE0F2             B        ??Mem_PoolCreate_4
   1425                  }
   \                     ??Mem_PoolCreate_20: (+1)
   \      0x1DE   0xE7DF             B        ??Mem_PoolCreate_26
   \                     ??Mem_PoolCreate_23: (+1)
   \      0x1E0   0x0038             MOVS     R0,R7
   \      0x1E2   0x....'....        BL       CPU_SR_Restore
   \      0x1E6   0x....             LDR      R0,??DataTable7  ;; 0x277f
   \      0x1E8   0x8028             STRH     R0,[R5, #+0]
   \      0x1EA   0xE0EB             B        ??Mem_PoolCreate_4
   1426          #endif
   1427          
   1428                  size_rem = pmem_pool_heap->SegSizeRem;
   \                     ??Mem_PoolCreate_28: (+1)
   \      0x1EC   0x9803             LDR      R0,[SP, #+12]
   \      0x1EE   0x6C40             LDR      R0,[R0, #+68]
   \      0x1F0   0x9004             STR      R0,[SP, #+16]
   1429                  if (size_tot_ptrs > size_rem) {                             /* If ptr size > rem  size, ...                     */
   \      0x1F2   0x9804             LDR      R0,[SP, #+16]
   \      0x1F4   0x42B0             CMP      R0,R6
   \      0x1F6   0xD209             BCS      ??Mem_PoolCreate_29
   1430                      CPU_CRITICAL_EXIT();
   \      0x1F8   0x0038             MOVS     R0,R7
   \      0x1FA   0x....'....        BL       CPU_SR_Restore
   1431                     *poctets_reqd = size_tot_ptrs - size_rem;                /* ... rtn add'l heap size needed.                  */
   \      0x1FE   0x9804             LDR      R0,[SP, #+16]
   \      0x200   0x1A30             SUBS     R0,R6,R0
   \      0x202   0x9914             LDR      R1,[SP, #+80]
   \      0x204   0x6008             STR      R0,[R1, #+0]
   1432                     *perr         = LIB_MEM_ERR_HEAP_EMPTY;
   \      0x206   0x....             LDR      R0,??DataTable6  ;; 0x27e2
   \      0x208   0x8028             STRH     R0,[R5, #+0]
   1433                      return;
   \      0x20A   0xE0DB             B        ??Mem_PoolCreate_4
   1434                  }
   1435          
   1436                                                                              /* Calc tot mem size for mem blks.                  */
   1437                  pmem_addr_pool = (CPU_INT08U *)pmem_seg->SegAddrNextAvail;
   \                     ??Mem_PoolCreate_29: (+1)
   \      0x20C   0x9801             LDR      R0,[SP, #+4]
   \      0x20E   0x6BC0             LDR      R0,[R0, #+60]
   \      0x210   0x9007             STR      R0,[SP, #+28]
   1438                  size_tot_pool  =  Mem_SegCalcTotSize((void     *)pmem_addr_pool,
   1439                                                       (CPU_SIZE_T)blk_nbr,
   1440                                                       (CPU_SIZE_T)blk_size,
   1441                                                       (CPU_SIZE_T)blk_align);
   \      0x212   0x9B13             LDR      R3,[SP, #+76]
   \      0x214   0x9A12             LDR      R2,[SP, #+72]
   \      0x216   0x9902             LDR      R1,[SP, #+8]
   \      0x218   0x9807             LDR      R0,[SP, #+28]
   \      0x21A   0x....'....        BL       Mem_SegCalcTotSize
   \      0x21E   0x0006             MOVS     R6,R0
   1442          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1443                  if (size_tot_pool < 1) {                                    /* If seg  ovf, ...                                 */
   \      0x220   0x2E00             CMP      R6,#+0
   \      0x222   0xD105             BNE      ??Mem_PoolCreate_30
   1444                      CPU_CRITICAL_EXIT();
   \      0x224   0x0038             MOVS     R0,R7
   \      0x226   0x....'....        BL       CPU_SR_Restore
   1445                     *perr = LIB_MEM_ERR_SEG_OVF;                             /* ... rtn err but add'l seg  size NOT avail.       */
   \      0x22A   0x....             LDR      R0,??DataTable7_1  ;; 0x27d9
   \      0x22C   0x8028             STRH     R0,[R5, #+0]
   1446                      return;
   \      0x22E   0xE0C9             B        ??Mem_PoolCreate_4
   1447                  }
   1448          #endif
   1449          
   1450                  size_rem = pmem_seg->SegSizeRem;
   \                     ??Mem_PoolCreate_30: (+1)
   \      0x230   0x9801             LDR      R0,[SP, #+4]
   \      0x232   0x6C40             LDR      R0,[R0, #+68]
   \      0x234   0x9004             STR      R0,[SP, #+16]
   1451                  if (size_tot_pool > size_rem) {                             /* If tot size > rem  size, ...                     */
   \      0x236   0x9804             LDR      R0,[SP, #+16]
   \      0x238   0x42B0             CMP      R0,R6
   \      0x23A   0xD209             BCS      ??Mem_PoolCreate_16
   1452                      CPU_CRITICAL_EXIT();
   \      0x23C   0x0038             MOVS     R0,R7
   \      0x23E   0x....'....        BL       CPU_SR_Restore
   1453                     *poctets_reqd = size_tot_pool - size_rem;                /* ... rtn add'l seg  size needed.                  */
   \      0x242   0x9804             LDR      R0,[SP, #+16]
   \      0x244   0x1A30             SUBS     R0,R6,R0
   \      0x246   0x9914             LDR      R1,[SP, #+80]
   \      0x248   0x6008             STR      R0,[R1, #+0]
   1454                     *perr         = LIB_MEM_ERR_SEG_EMPTY;
   \      0x24A   0x....             LDR      R0,??DataTable7_2  ;; 0x27d8
   \      0x24C   0x8028             STRH     R0,[R5, #+0]
   1455                      return;
   \      0x24E   0xE0B9             B        ??Mem_PoolCreate_4
   1456                  }
   1457              }
   1458          
   1459          
   1460          /*$PAGE*/
   1461                                                                              /* ---------------- ALLOC MEM BLKs ---------------- */
   1462              size_pool_ptrs = (CPU_SIZE_T)(blk_nbr * sizeof(void *));
   \                     ??Mem_PoolCreate_16: (+1)
   \      0x250   0x9802             LDR      R0,[SP, #+8]
   \      0x252   0x2104             MOVS     R1,#+4
   \      0x254   0x4348             MULS     R0,R1,R0
   \      0x256   0x9004             STR      R0,[SP, #+16]
   1463                                                                              /* Alloc stk of ptrs for mem blks from heap.        */
   1464              ppool_ptr      = (void **)Mem_SegAlloc((MEM_POOL *)pmem_pool_heap,
   1465                                                     (CPU_SIZE_T)size_pool_ptrs,
   1466                                                     (CPU_SIZE_T)sizeof(void *));
   \      0x258   0x2204             MOVS     R2,#+4
   \      0x25A   0x9904             LDR      R1,[SP, #+16]
   \      0x25C   0x9803             LDR      R0,[SP, #+12]
   \      0x25E   0x....'....        BL       Mem_SegAlloc
   \      0x262   0x9009             STR      R0,[SP, #+36]
   1467              if (ppool_ptr == (void **)0) {                                  /* If mem pool ptrs alloc failed, ...               */
   \      0x264   0x9809             LDR      R0,[SP, #+36]
   \      0x266   0x2800             CMP      R0,#+0
   \      0x268   0xD121             BNE      ??Mem_PoolCreate_31
   1468                  size_rem = pmem_pool_heap->SegSizeRem;
   \      0x26A   0x9803             LDR      R0,[SP, #+12]
   \      0x26C   0x6C44             LDR      R4,[R0, #+68]
   1469                  CPU_CRITICAL_EXIT();
   \      0x26E   0x0038             MOVS     R0,R7
   \      0x270   0x....'....        BL       CPU_SR_Restore
   1470                                                                              /* ... rtn add'l heap size needed.                  */
   1471                  if (pmem_base_addr == (void *)0) {
   \      0x274   0x9806             LDR      R0,[SP, #+24]
   \      0x276   0x2800             CMP      R0,#+0
   \      0x278   0xD10B             BNE      ??Mem_PoolCreate_32
   1472                      if (size_tot > size_rem) {
   \      0x27A   0x9805             LDR      R0,[SP, #+20]
   \      0x27C   0x4284             CMP      R4,R0
   \      0x27E   0xD204             BCS      ??Mem_PoolCreate_33
   1473                         *poctets_reqd = size_tot - size_rem;
   \      0x280   0x9805             LDR      R0,[SP, #+20]
   \      0x282   0x1B00             SUBS     R0,R0,R4
   \      0x284   0x9914             LDR      R1,[SP, #+80]
   \      0x286   0x6008             STR      R0,[R1, #+0]
   \      0x288   0xE00E             B        ??Mem_PoolCreate_34
   1474                      } else {
   1475                         *poctets_reqd = size_tot;
   \                     ??Mem_PoolCreate_33: (+1)
   \      0x28A   0x9805             LDR      R0,[SP, #+20]
   \      0x28C   0x9914             LDR      R1,[SP, #+80]
   \      0x28E   0x6008             STR      R0,[R1, #+0]
   \      0x290   0xE00A             B        ??Mem_PoolCreate_34
   1476                      }
   1477                  } else {
   1478                      if (size_pool_ptrs > size_rem) {
   \                     ??Mem_PoolCreate_32: (+1)
   \      0x292   0x9804             LDR      R0,[SP, #+16]
   \      0x294   0x4284             CMP      R4,R0
   \      0x296   0xD204             BCS      ??Mem_PoolCreate_35
   1479                         *poctets_reqd = size_pool_ptrs - size_rem;
   \      0x298   0x9804             LDR      R0,[SP, #+16]
   \      0x29A   0x1B00             SUBS     R0,R0,R4
   \      0x29C   0x9914             LDR      R1,[SP, #+80]
   \      0x29E   0x6008             STR      R0,[R1, #+0]
   \      0x2A0   0xE002             B        ??Mem_PoolCreate_34
   1480                      } else {
   1481                         *poctets_reqd = size_pool_ptrs;
   \                     ??Mem_PoolCreate_35: (+1)
   \      0x2A2   0x9804             LDR      R0,[SP, #+16]
   \      0x2A4   0x9914             LDR      R1,[SP, #+80]
   \      0x2A6   0x6008             STR      R0,[R1, #+0]
   1482                      }
   1483                  }
   1484                 *perr = LIB_MEM_ERR_HEAP_EMPTY;
   \                     ??Mem_PoolCreate_34: (+1)
   \      0x2A8   0x....             LDR      R0,??DataTable6  ;; 0x27e2
   \      0x2AA   0x8028             STRH     R0,[R5, #+0]
   1485                  return;
   \      0x2AC   0xE08A             B        ??Mem_PoolCreate_4
   1486              }
   1487          
   1488              for (i = 0u; i < (CPU_SIZE_T)blk_nbr; i++) {                    /* Alloc mem blks from mem seg.                     */
   \                     ??Mem_PoolCreate_31: (+1)
   \      0x2AE   0x2000             MOVS     R0,#+0
   \      0x2B0   0x9003             STR      R0,[SP, #+12]
   \      0x2B2   0xE007             B        ??Mem_PoolCreate_36
   1489                  pmem_blk = (void *)Mem_SegAlloc(pmem_seg, blk_size, blk_align);
   1490                  if (pmem_blk == (void *)0) {                                /* If    mem blks alloc failed, ...                 */
   1491                      pmem_addr_pool = (CPU_INT08U *)pmem_seg->SegAddrNextAvail;
   1492                      size_rem       = (CPU_SIZE_T  )pmem_seg->SegSizeRem;
   1493                      CPU_CRITICAL_EXIT();
   1494                      blk_rem        =  blk_nbr - (MEM_POOL_BLK_QTY)i;
   1495                      size_tot       =  Mem_SegCalcTotSize((void           *)pmem_addr_pool,
   1496                                                           (MEM_POOL_BLK_QTY)blk_rem,
   1497                                                           (CPU_SIZE_T      )blk_size,
   1498                                                           (CPU_SIZE_T      )blk_align);
   1499                                                                              /* ... rtn add'l seg  size needed.                  */
   1500                      if (size_tot > size_rem) {
   1501                         *poctets_reqd = size_tot - size_rem;
   1502                      } else {
   1503                         *poctets_reqd = size_tot;
   1504                      }
   1505                     *perr = LIB_MEM_ERR_SEG_EMPTY;
   1506                      return;
   1507                  }
   1508                  ppool_ptr[i] = pmem_blk;
   \                     ??Mem_PoolCreate_37: (+1)
   \      0x2B4   0x9909             LDR      R1,[SP, #+36]
   \      0x2B6   0x9A03             LDR      R2,[SP, #+12]
   \      0x2B8   0x2304             MOVS     R3,#+4
   \      0x2BA   0x435A             MULS     R2,R3,R2
   \      0x2BC   0x5088             STR      R0,[R1, R2]
   \      0x2BE   0x9803             LDR      R0,[SP, #+12]
   \      0x2C0   0x1C40             ADDS     R0,R0,#+1
   \      0x2C2   0x9003             STR      R0,[SP, #+12]
   \                     ??Mem_PoolCreate_36: (+1)
   \      0x2C4   0x9803             LDR      R0,[SP, #+12]
   \      0x2C6   0x9902             LDR      R1,[SP, #+8]
   \      0x2C8   0x4288             CMP      R0,R1
   \      0x2CA   0xD225             BCS      ??Mem_PoolCreate_38
   \      0x2CC   0x9A13             LDR      R2,[SP, #+76]
   \      0x2CE   0x9912             LDR      R1,[SP, #+72]
   \      0x2D0   0x9801             LDR      R0,[SP, #+4]
   \      0x2D2   0x....'....        BL       Mem_SegAlloc
   \      0x2D6   0x2800             CMP      R0,#+0
   \      0x2D8   0xD1EC             BNE      ??Mem_PoolCreate_37
   \      0x2DA   0x9801             LDR      R0,[SP, #+4]
   \      0x2DC   0x6BC6             LDR      R6,[R0, #+60]
   \      0x2DE   0x9801             LDR      R0,[SP, #+4]
   \      0x2E0   0x6C44             LDR      R4,[R0, #+68]
   \      0x2E2   0x0038             MOVS     R0,R7
   \      0x2E4   0x....'....        BL       CPU_SR_Restore
   \      0x2E8   0x9802             LDR      R0,[SP, #+8]
   \      0x2EA   0x9903             LDR      R1,[SP, #+12]
   \      0x2EC   0x1A41             SUBS     R1,R0,R1
   \      0x2EE   0x9B13             LDR      R3,[SP, #+76]
   \      0x2F0   0x9A12             LDR      R2,[SP, #+72]
   \      0x2F2   0x0030             MOVS     R0,R6
   \      0x2F4   0x....'....        BL       Mem_SegCalcTotSize
   \      0x2F8   0x4284             CMP      R4,R0
   \      0x2FA   0xD203             BCS      ??Mem_PoolCreate_39
   \      0x2FC   0x1B00             SUBS     R0,R0,R4
   \      0x2FE   0x9914             LDR      R1,[SP, #+80]
   \      0x300   0x6008             STR      R0,[R1, #+0]
   \      0x302   0xE001             B        ??Mem_PoolCreate_40
   \                     ??Mem_PoolCreate_39: (+1)
   \      0x304   0x9914             LDR      R1,[SP, #+80]
   \      0x306   0x6008             STR      R0,[R1, #+0]
   \                     ??Mem_PoolCreate_40: (+1)
   \      0x308   0x....             LDR      R0,??DataTable7_2  ;; 0x27d8
   \      0x30A   0x8028             STRH     R0,[R5, #+0]
   \      0x30C   0xE05A             B        ??Mem_PoolCreate_4
   \      0x30E   0xBF00             Nop
   \                     ??Mem_PoolCreate_0:
   \      0x310   0x0000'2710        DC32     0x2710
   \      0x314   0x0000'277E        DC32     0x277e
   1509              }
   1510          
   1511          
   1512          /*$PAGE*/
   1513                                                                              /* ------------- UPDATE MEM POOL TBL -------------- */
   1514              if (pmem_seg == pmem_pool) {                                    /* Add mem pool as new  mem pool tbl seg.           */
   \                     ??Mem_PoolCreate_38: (+1)
   \      0x318   0x9801             LDR      R0,[SP, #+4]
   \      0x31A   0x9900             LDR      R1,[SP, #+0]
   \      0x31C   0x4288             CMP      R0,R1
   \      0x31E   0xD11F             BNE      ??Mem_PoolCreate_41
   1515                                                                              /* Update cur  mem seg  links.                      */
   1516                  pmem_pool->SegPrevPtr = pmem_seg_prev;
   \      0x320   0x9808             LDR      R0,[SP, #+32]
   \      0x322   0x9900             LDR      R1,[SP, #+0]
   \      0x324   0x6088             STR      R0,[R1, #+8]
   1517                  pmem_pool->SegNextPtr = pmem_seg_next;
   \      0x326   0x9800             LDR      R0,[SP, #+0]
   \      0x328   0x60C4             STR      R4,[R0, #+12]
   1518          
   1519                  if (pmem_seg_prev != (MEM_POOL *)0) {                       /* Update prev mem seg  link.                       */
   \      0x32A   0x9808             LDR      R0,[SP, #+32]
   \      0x32C   0x2800             CMP      R0,#+0
   \      0x32E   0xD003             BEQ      ??Mem_PoolCreate_42
   1520                      pmem_seg_prev->SegNextPtr = pmem_pool;
   \      0x330   0x9800             LDR      R0,[SP, #+0]
   \      0x332   0x9908             LDR      R1,[SP, #+32]
   \      0x334   0x60C8             STR      R0,[R1, #+12]
   \      0x336   0xE002             B        ??Mem_PoolCreate_43
   1521                  } else {
   1522                      Mem_PoolTbl               = pmem_pool;                  /* Update      mem tbl.                             */
   \                     ??Mem_PoolCreate_42: (+1)
   \      0x338   0x9800             LDR      R0,[SP, #+0]
   \      0x33A   0x4906             LDR      R1,??Mem_PoolCreate_1+0xC
   \      0x33C   0x6008             STR      R0,[R1, #+0]
   1523                  }
   1524          
   1525                  if (pmem_seg_next != (MEM_POOL *)0) {                       /* Update next mem seg  link.                       */
   \                     ??Mem_PoolCreate_43: (+1)
   \      0x33E   0x2C00             CMP      R4,#+0
   \      0x340   0xD01C             BEQ      ??Mem_PoolCreate_44
   1526                      pmem_seg_next->SegPrevPtr = pmem_pool;
   \      0x342   0x9800             LDR      R0,[SP, #+0]
   \      0x344   0x60A0             STR      R0,[R4, #+8]
   \      0x346   0xE019             B        ??Mem_PoolCreate_44
   \                     ??Mem_PoolCreate_1:
   \      0x348   0x0000'2792        DC32     0x2792
   \      0x34C   0x0000'2793        DC32     0x2793
   \      0x350   0x0000'2794        DC32     0x2794
   \      0x354   0x....'....        DC32     Mem_PoolTbl
   \      0x358   0x0000'27E7        DC32     0x27e7
   \      0x35C   0x....'....        DC32     Mem_PoolHeap
   1527                  }
   1528          
   1529              } else {                                                        /* Add mem pool into mem seg.                       */
   1530                                                                              /* Update cur  mem pool links.                      */
   1531                  pmem_pool_next         = pmem_seg->PoolNextPtr;
   \                     ??Mem_PoolCreate_41: (+1)
   \      0x360   0x9801             LDR      R0,[SP, #+4]
   \      0x362   0x6940             LDR      R0,[R0, #+20]
   1532                  pmem_pool->PoolPrevPtr = pmem_seg;
   \      0x364   0x9901             LDR      R1,[SP, #+4]
   \      0x366   0x9A00             LDR      R2,[SP, #+0]
   \      0x368   0x6111             STR      R1,[R2, #+16]
   1533                  pmem_pool->PoolNextPtr = pmem_pool_next;
   \      0x36A   0x9900             LDR      R1,[SP, #+0]
   \      0x36C   0x6148             STR      R0,[R1, #+20]
   1534          
   1535                  pmem_seg->PoolNextPtr  = pmem_pool;                         /* Update prev mem pool link.                       */
   \      0x36E   0x9900             LDR      R1,[SP, #+0]
   \      0x370   0x9A01             LDR      R2,[SP, #+4]
   \      0x372   0x6151             STR      R1,[R2, #+20]
   1536          
   1537                  if (pmem_pool_next != (MEM_POOL *)0) {                      /* Update next mem pool link.                       */
   \      0x374   0x2800             CMP      R0,#+0
   \      0x376   0xD001             BEQ      ??Mem_PoolCreate_44
   1538                      pmem_pool_next->PoolPrevPtr = pmem_pool;
   \      0x378   0x9900             LDR      R1,[SP, #+0]
   \      0x37A   0x6101             STR      R1,[R0, #+16]
   1539                  }
   1540              }
   1541          
   1542          
   1543          
   1544                                                                              /* ----------------- CFG MEM POOL ----------------- */
   1545              pmem_pool->Type          = (LIB_MEM_TYPE    ) LIB_MEM_TYPE_POOL;
   \                     ??Mem_PoolCreate_44: (+1)
   \      0x37C   0x....             LDR      R0,??DataTable8  ;; 0x4c4f4f50
   \      0x37E   0x9900             LDR      R1,[SP, #+0]
   \      0x380   0x6008             STR      R0,[R1, #+0]
   1546              pmem_pool->SegHeadPtr    = (MEM_POOL       *) pmem_seg;
   \      0x382   0x9801             LDR      R0,[SP, #+4]
   \      0x384   0x9900             LDR      R1,[SP, #+0]
   \      0x386   0x6048             STR      R0,[R1, #+4]
   1547              pmem_pool->PoolAddrStart = (void           *) pmem_addr_pool;
   \      0x388   0x9807             LDR      R0,[SP, #+28]
   \      0x38A   0x9900             LDR      R1,[SP, #+0]
   \      0x38C   0x6188             STR      R0,[R1, #+24]
   1548              pmem_pool->PoolAddrEnd   = (void           *)(pmem_addr_pool + size_tot_pool - 1);
   \      0x38E   0x9807             LDR      R0,[SP, #+28]
   \      0x390   0x1980             ADDS     R0,R0,R6
   \      0x392   0x1E40             SUBS     R0,R0,#+1
   \      0x394   0x9900             LDR      R1,[SP, #+0]
   \      0x396   0x61C8             STR      R0,[R1, #+28]
   1549              pmem_pool->PoolPtrs      = (void          **) ppool_ptr;
   \      0x398   0x9809             LDR      R0,[SP, #+36]
   \      0x39A   0x9900             LDR      R1,[SP, #+0]
   \      0x39C   0x6208             STR      R0,[R1, #+32]
   1550              pmem_pool->PoolSize      = (CPU_SIZE_T      ) size_tot_pool;
   \      0x39E   0x9800             LDR      R0,[SP, #+0]
   \      0x3A0   0x6286             STR      R6,[R0, #+40]
   1551              pmem_pool->BlkAlign      = (CPU_SIZE_T      ) blk_align;
   \      0x3A2   0x9813             LDR      R0,[SP, #+76]
   \      0x3A4   0x9900             LDR      R1,[SP, #+0]
   \      0x3A6   0x6348             STR      R0,[R1, #+52]
   1552              pmem_pool->BlkSize       = (CPU_SIZE_T      ) blk_size;
   \      0x3A8   0x9812             LDR      R0,[SP, #+72]
   \      0x3AA   0x9900             LDR      R1,[SP, #+0]
   \      0x3AC   0x6308             STR      R0,[R1, #+48]
   1553              pmem_pool->BlkNbr        = (MEM_POOL_BLK_QTY) blk_nbr;
   \      0x3AE   0x9802             LDR      R0,[SP, #+8]
   \      0x3B0   0x9900             LDR      R1,[SP, #+0]
   \      0x3B2   0x62C8             STR      R0,[R1, #+44]
   1554              pmem_pool->BlkIx         = (MEM_POOL_IX     ) blk_nbr;
   \      0x3B4   0x9802             LDR      R0,[SP, #+8]
   \      0x3B6   0x9900             LDR      R1,[SP, #+0]
   \      0x3B8   0x6248             STR      R0,[R1, #+36]
   1555          
   1556          
   1557              CPU_CRITICAL_EXIT();
   \      0x3BA   0x0038             MOVS     R0,R7
   \      0x3BC   0x....'....        BL       CPU_SR_Restore
   1558          
   1559             *perr = LIB_MEM_ERR_NONE;
   \      0x3C0   0x....             LDR      R0,??DataTable9  ;; 0x2710
   \      0x3C2   0x8028             STRH     R0,[R5, #+0]
   1560          }
   \                     ??Mem_PoolCreate_4: (+1)
   \      0x3C4   0xB00D             ADD      SP,SP,#+52
   \      0x3C6   0xBDF0             POP      {R4-R7,PC}       ;; return
   1561          #endif
   1562          
   1563          
   1564          /*$PAGE*/
   1565          /*
   1566          *********************************************************************************************************
   1567          *                                      Mem_PoolBlkGetNbrAvail()
   1568          *
   1569          * Description : Get memory pools remaining number of blocks available to allocate.
   1570          *
   1571          * Argument(s) : pmem_pool   Pointer to a memory pool structure.
   1572          *
   1573          *               perr        Pointer to variable that will receive the return error code from this function :
   1574          *
   1575          *                               LIB_MEM_ERR_NONE                Memory pool available number of blocks
   1576          *                                                                   successfully returned.
   1577          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
   1578          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
   1579          *
   1580          * Return(s)   : Remaining memory pool blocks (see Note #1), if NO error(s).
   1581          *
   1582          *               0,                                          otherwise.
   1583          *
   1584          * Caller(s)   : Application.
   1585          *
   1586          * Note(s)     : (1) (a) Mem_PoolBlkGetNbrAvail() ONLY supports non-heap memory pools.
   1587          *                   (b) Mem_HeapGetSizeRem()/Mem_SegGetSizeRem() should be used for heap memory pool/segment.
   1588          *
   1589          *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1590          *********************************************************************************************************
   1591          */
   1592          /*$PAGE*/
   1593          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1594          MEM_POOL_BLK_QTY  Mem_PoolBlkGetNbrAvail (MEM_POOL  *pmem_pool,
   1595                                                    LIB_ERR   *perr)
   1596          {
   \                     Mem_PoolBlkGetNbrAvail: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1597              MEM_POOL_BLK_QTY  nbr_blk_rem;
   1598              CPU_SR_ALLOC();
   \        0x6   0x2000             MOVS     R0,#+0
   1599          
   1600          
   1601          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1602                                                                          /* --------------- VALIDATE RTN ERR PTR --------------- */
   1603              if (perr == (LIB_ERR *)0) {
   \        0x8   0x2D00             CMP      R5,#+0
   \        0xA   0xD101             BNE      ??Mem_PoolBlkGetNbrAvail_0
   1604                  CPU_SW_EXCEPTION(0u);
   \        0xC   0x....'....        BL       CPU_SW_Exception
   1605              }
   1606                                                                          /* ---------------- VALIDATE MEM POOL ----------------- */
   1607              if (pmem_pool == (MEM_POOL *)0) {                           /* Validate mem ptr.                                    */
   \                     ??Mem_PoolBlkGetNbrAvail_0: (+1)
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD103             BNE      ??Mem_PoolBlkGetNbrAvail_1
   1608                 *perr =  LIB_MEM_ERR_NULL_PTR;
   \       0x14   0x....             LDR      R0,??DataTable9_1  ;; 0x2711
   \       0x16   0x8028             STRH     R0,[R5, #+0]
   1609                  return (0u);
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xE011             B        ??Mem_PoolBlkGetNbrAvail_2
   1610              }
   1611          #endif
   1612          
   1613              CPU_CRITICAL_ENTER();
   \                     ??Mem_PoolBlkGetNbrAvail_1: (+1)
   \       0x1C   0x....'....        BL       CPU_SR_Save
   1614          
   1615          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1616              switch (pmem_pool->Type) {                                  /* Validate mem pool type.                              */
   \       0x20   0x6821             LDR      R1,[R4, #+0]
   \       0x22   0x....             LDR      R2,??DataTable8  ;; 0x4c4f4f50
   \       0x24   0x4291             CMP      R1,R2
   \       0x26   0xD106             BNE      ??Mem_PoolBlkGetNbrAvail_3
   1617                  case LIB_MEM_TYPE_POOL:
   1618                       break;
   1619          
   1620          
   1621                  case LIB_MEM_TYPE_NONE:
   1622                  case LIB_MEM_TYPE_HEAP:
   1623                  default:
   1624                       CPU_CRITICAL_EXIT();
   1625                      *perr =  LIB_MEM_ERR_INVALID_POOL;
   1626                       return (0u);                                       /* Prevent 'break NOT reachable' compiler warning.      */
   1627              }
   1628          #endif
   1629          
   1630                                                                          /* --------- GET REM'ING MEM POOL NBR BLK(S) ---------- */
   1631              nbr_blk_rem = pmem_pool->BlkIx;
   \       0x28   0x6A64             LDR      R4,[R4, #+36]
   1632          
   1633              CPU_CRITICAL_EXIT();
   \       0x2A   0x....'....        BL       CPU_SR_Restore
   1634          
   1635          
   1636             *perr =  LIB_MEM_ERR_NONE;
   \       0x2E   0x....             LDR      R0,??DataTable9  ;; 0x2710
   \       0x30   0x8028             STRH     R0,[R5, #+0]
   1637          
   1638              return (nbr_blk_rem);
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0xE004             B        ??Mem_PoolBlkGetNbrAvail_2
   \                     ??Mem_PoolBlkGetNbrAvail_3: (+1)
   \       0x36   0x....'....        BL       CPU_SR_Restore
   \       0x3A   0x....             LDR      R0,??DataTable9_2  ;; 0x2788
   \       0x3C   0x8028             STRH     R0,[R5, #+0]
   \       0x3E   0x2000             MOVS     R0,#+0
   \                     ??Mem_PoolBlkGetNbrAvail_2: (+1)
   \       0x40   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1639          }
   1640          #endif
   1641          
   1642          
   1643          /*$PAGE*/
   1644          /*
   1645          *********************************************************************************************************
   1646          *                                          Mem_PoolBlkGet()
   1647          *
   1648          * Description : Get a memory block from memory pool.
   1649          *
   1650          * Argument(s) : pmem_pool   Pointer to  memory pool to get memory block from.
   1651          *
   1652          *               size        Size of requested memory (in octets).
   1653          *
   1654          *               perr        Pointer to variable that will receive the return error code from this function :
   1655          *
   1656          *                               LIB_MEM_ERR_NONE                   Memory block successfully returned.
   1657          *                               LIB_MEM_ERR_POOL_EMPTY          NO memory blocks available in memory pool.
   1658          *
   1659          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
   1660          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
   1661          *                               LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid memory pool block size requested.
   1662          *                               LIB_MEM_ERR_INVALID_BLK_IX      Invalid memory pool block index.
   1663          *
   1664          * Return(s)   : Pointer to memory block, if NO error(s).
   1665          *
   1666          *               Pointer to NULL,         otherwise.
   1667          *
   1668          * Caller(s)   : Application.
   1669          *
   1670          * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1671          *********************************************************************************************************
   1672          */
   1673          /*$PAGE*/
   1674          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1675          void  *Mem_PoolBlkGet (MEM_POOL    *pmem_pool,
   1676                                 CPU_SIZE_T   size,
   1677                                 LIB_ERR     *perr)
   1678          {
   \                     Mem_PoolBlkGet: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   1679              void  *pmem_blk;
   1680              CPU_SR_ALLOC();
   \        0x8   0x2000             MOVS     R0,#+0
   1681          
   1682          
   1683          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   1684              if (perr == (LIB_ERR *)0) {
   \        0xA   0x2E00             CMP      R6,#+0
   \        0xC   0xD101             BNE      ??Mem_PoolBlkGet_0
   1685                  CPU_SW_EXCEPTION((void *)0);
   \        0xE   0x....'....        BL       CPU_SW_Exception
   1686              }
   1687          #endif
   1688          
   1689                                                                              /* ------------ VALIDATE MEM POOL GET ------------- */
   1690          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1691              if (pmem_pool == (MEM_POOL *)0) {                               /* Validate mem ptr.                                */
   \                     ??Mem_PoolBlkGet_0: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD103             BNE      ??Mem_PoolBlkGet_1
   1692                 *perr = LIB_MEM_ERR_NULL_PTR;
   \       0x16   0x....             LDR      R0,??DataTable9_1  ;; 0x2711
   \       0x18   0x8030             STRH     R0,[R6, #+0]
   1693                  return ((void *)0);
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xE03B             B        ??Mem_PoolBlkGet_2
   1694              }
   1695          
   1696              if (size < 1) {                                                 /* Validate req'd size as non-NULL.                 */
   \                     ??Mem_PoolBlkGet_1: (+1)
   \       0x1E   0x2D00             CMP      R5,#+0
   \       0x20   0xD103             BNE      ??Mem_PoolBlkGet_3
   1697                 *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
   \       0x22   0x....             LDR      R0,??DataTable9_3  ;; 0x2793
   \       0x24   0x8030             STRH     R0,[R6, #+0]
   1698                  return ((void *)0);
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xE035             B        ??Mem_PoolBlkGet_2
   1699              }
   1700          #endif
   1701          
   1702              CPU_CRITICAL_ENTER();
   \                     ??Mem_PoolBlkGet_3: (+1)
   \       0x2A   0x....'....        BL       CPU_SR_Save
   1703          
   1704          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1705              if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
   \       0x2E   0x6821             LDR      R1,[R4, #+0]
   \       0x30   0x....             LDR      R2,??DataTable8  ;; 0x4c4f4f50
   \       0x32   0x4291             CMP      R1,R2
   \       0x34   0xD005             BEQ      ??Mem_PoolBlkGet_4
   1706                  CPU_CRITICAL_EXIT();
   \       0x36   0x....'....        BL       CPU_SR_Restore
   1707                 *perr = LIB_MEM_ERR_INVALID_POOL;
   \       0x3A   0x....             LDR      R0,??DataTable9_2  ;; 0x2788
   \       0x3C   0x8030             STRH     R0,[R6, #+0]
   1708                  return ((void *)0);
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xE029             B        ??Mem_PoolBlkGet_2
   1709              }
   1710          
   1711              if (size > pmem_pool->BlkSize) {                                /* Validate req'd size <= mem pool blk size.        */
   \                     ??Mem_PoolBlkGet_4: (+1)
   \       0x42   0x6B21             LDR      R1,[R4, #+48]
   \       0x44   0x42A9             CMP      R1,R5
   \       0x46   0xD205             BCS      ??Mem_PoolBlkGet_5
   1712                  CPU_CRITICAL_EXIT();
   \       0x48   0x....'....        BL       CPU_SR_Restore
   1713                 *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
   \       0x4C   0x....             LDR      R0,??DataTable9_3  ;; 0x2793
   \       0x4E   0x8030             STRH     R0,[R6, #+0]
   1714                  return ((void *)0);
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xE020             B        ??Mem_PoolBlkGet_2
   1715              }
   1716          #endif
   1717          
   1718             (void)&size;                                                     /* Prevent possible 'variable unused' warning.      */
   \                     ??Mem_PoolBlkGet_5: (+1)
   \       0x54   0x4669             MOV      R1,SP
   1719          
   1720              if (pmem_pool->BlkIx < 1) {                                     /* Validate mem pool as NOT empty.                  */
   \       0x56   0x6A61             LDR      R1,[R4, #+36]
   \       0x58   0x2900             CMP      R1,#+0
   \       0x5A   0xD105             BNE      ??Mem_PoolBlkGet_6
   1721                  CPU_CRITICAL_EXIT();
   \       0x5C   0x....'....        BL       CPU_SR_Restore
   1722                 *perr = LIB_MEM_ERR_POOL_EMPTY;
   \       0x60   0x....             LDR      R0,??DataTable9_4  ;; 0x27de
   \       0x62   0x8030             STRH     R0,[R6, #+0]
   1723                  return ((void *)0);
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xE016             B        ??Mem_PoolBlkGet_2
   1724              }
   1725          
   1726              if (pmem_pool->BlkIx > pmem_pool->BlkNbr) {                     /* Validate mem pool ix NOT corrupt.                */
   \                     ??Mem_PoolBlkGet_6: (+1)
   \       0x68   0x6AE1             LDR      R1,[R4, #+44]
   \       0x6A   0x6A62             LDR      R2,[R4, #+36]
   \       0x6C   0x4291             CMP      R1,R2
   \       0x6E   0xD205             BCS      ??Mem_PoolBlkGet_7
   1727                  CPU_CRITICAL_EXIT();
   \       0x70   0x....'....        BL       CPU_SR_Restore
   1728                 *perr = LIB_MEM_ERR_INVALID_BLK_IX;
   \       0x74   0x....             LDR      R0,??DataTable9_5  ;; 0x2795
   \       0x76   0x8030             STRH     R0,[R6, #+0]
   1729                  return ((void *)0);
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0xE00C             B        ??Mem_PoolBlkGet_2
   1730              }
   1731          
   1732                                                                              /* ------------ GET MEM BLK FROM POOL ------------- */
   1733              pmem_pool->BlkIx--;
   \                     ??Mem_PoolBlkGet_7: (+1)
   \       0x7C   0x6A61             LDR      R1,[R4, #+36]
   \       0x7E   0x1E49             SUBS     R1,R1,#+1
   \       0x80   0x6261             STR      R1,[R4, #+36]
   1734              pmem_blk = pmem_pool->PoolPtrs[pmem_pool->BlkIx];
   \       0x82   0x6A21             LDR      R1,[R4, #+32]
   \       0x84   0x6A62             LDR      R2,[R4, #+36]
   \       0x86   0x2304             MOVS     R3,#+4
   \       0x88   0x435A             MULS     R2,R3,R2
   \       0x8A   0x588C             LDR      R4,[R1, R2]
   1735          
   1736              CPU_CRITICAL_EXIT();
   \       0x8C   0x....'....        BL       CPU_SR_Restore
   1737          
   1738             *perr =  LIB_MEM_ERR_NONE;
   \       0x90   0x....             LDR      R0,??DataTable10  ;; 0x2710
   \       0x92   0x8030             STRH     R0,[R6, #+0]
   1739          
   1740              return (pmem_blk);
   \       0x94   0x0020             MOVS     R0,R4
   \                     ??Mem_PoolBlkGet_2: (+1)
   \       0x96   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1741          }
   1742          #endif
   1743          
   1744          
   1745          /*$PAGE*/
   1746          /*
   1747          *********************************************************************************************************
   1748          *                                      Mem_PoolBlkGetUsedAtIx()
   1749          *
   1750          * Description : Get a used memory block from memory pool, by index.
   1751          *
   1752          * Argument(s) : pmem_pool   Pointer to memory pool to get memory block from.
   1753          *
   1754          *               used_ix     Index of the used memory block to get.
   1755          *
   1756          *               perr        Pointer to variable that will receive the return error code from this function :
   1757          *
   1758          *                               LIB_MEM_ERR_NONE                    Memory block successfully returned.
   1759          *                               LIB_MEM_ERR_POOL_FULL           All memory blocks available in memory pool.
   1760          *
   1761          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
   1762          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
   1763          *                               LIB_MEM_ERR_INVALID_BLK_IX      Invalid memory pool block index.
   1764          *
   1765          * Return(s)   : Pointer to memory block, if NO error(s).
   1766          *
   1767          *               Pointer to NULL,         otherwise.
   1768          *
   1769          * Caller(s)   : Application.
   1770          *
   1771          * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1772          *
   1773          *               (2) The returned index can be altered when Mem_PoolBlkFree() is called. This index must
   1774          *                   only be used in conjunction with Mem_PoolBlkGetUsedAtIx() if holding a proper
   1775          *                   lock to avoid the index to be modified.
   1776          *********************************************************************************************************
   1777          */
   1778          /*$PAGE*/
   1779          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1780          void  *Mem_PoolBlkGetUsedAtIx (MEM_POOL          *pmem_pool,
   1781                                         MEM_POOL_IX        used_ix,
   1782                                         LIB_ERR           *perr)
   1783          {
   \                     Mem_PoolBlkGetUsedAtIx: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   1784              MEM_POOL_IX   blk_ix;
   1785              void         *pmem_blk;
   1786              CPU_SR_ALLOC();
   \        0x8   0x2000             MOVS     R0,#+0
   1787          
   1788          
   1789          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   1790              if (perr == (LIB_ERR *)0) {
   \        0xA   0x2E00             CMP      R6,#+0
   \        0xC   0xD101             BNE      ??Mem_PoolBlkGetUsedAtIx_0
   1791                  CPU_SW_EXCEPTION((void *)0);
   \        0xE   0x....'....        BL       CPU_SW_Exception
   1792              }
   1793          #endif
   1794          
   1795                                                                              /* ------------ VALIDATE MEM POOL GET ------------- */
   1796          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1797              if (pmem_pool == (MEM_POOL *)0) {                               /* Validate mem ptr.                                */
   \                     ??Mem_PoolBlkGetUsedAtIx_0: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD103             BNE      ??Mem_PoolBlkGetUsedAtIx_1
   1798                 *perr = LIB_MEM_ERR_NULL_PTR;
   \       0x16   0x....             LDR      R0,??DataTable9_1  ;; 0x2711
   \       0x18   0x8030             STRH     R0,[R6, #+0]
   1799                  return ((void *)0);
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xE033             B        ??Mem_PoolBlkGetUsedAtIx_2
   1800              }
   1801          #endif
   1802          
   1803              CPU_CRITICAL_ENTER();
   \                     ??Mem_PoolBlkGetUsedAtIx_1: (+1)
   \       0x1E   0x....'....        BL       CPU_SR_Save
   1804          
   1805          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1806              if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x....             LDR      R2,??DataTable8  ;; 0x4c4f4f50
   \       0x26   0x4291             CMP      R1,R2
   \       0x28   0xD005             BEQ      ??Mem_PoolBlkGetUsedAtIx_3
   1807                  CPU_CRITICAL_EXIT();
   \       0x2A   0x....'....        BL       CPU_SR_Restore
   1808                 *perr = LIB_MEM_ERR_INVALID_POOL;
   \       0x2E   0x....             LDR      R0,??DataTable9_2  ;; 0x2788
   \       0x30   0x8030             STRH     R0,[R6, #+0]
   1809                  return ((void *)0);
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xE027             B        ??Mem_PoolBlkGetUsedAtIx_2
   1810              }
   1811          #endif
   1812          
   1813              if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool as NOT full.                   */
   \                     ??Mem_PoolBlkGetUsedAtIx_3: (+1)
   \       0x36   0x6A61             LDR      R1,[R4, #+36]
   \       0x38   0x6AE2             LDR      R2,[R4, #+44]
   \       0x3A   0x4291             CMP      R1,R2
   \       0x3C   0xD305             BCC      ??Mem_PoolBlkGetUsedAtIx_4
   1814                  CPU_CRITICAL_EXIT();
   \       0x3E   0x....'....        BL       CPU_SR_Restore
   1815                 *perr = LIB_MEM_ERR_POOL_FULL;
   \       0x42   0x....             LDR      R0,??DataTable10_1  ;; 0x27dd
   \       0x44   0x8030             STRH     R0,[R6, #+0]
   1816                  return ((void *)0);
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0xE01D             B        ??Mem_PoolBlkGetUsedAtIx_2
   1817              }
   1818          
   1819              blk_ix = pmem_pool->BlkNbr - used_ix - 1u;
   \                     ??Mem_PoolBlkGetUsedAtIx_4: (+1)
   \       0x4A   0x6AE1             LDR      R1,[R4, #+44]
   \       0x4C   0x1B49             SUBS     R1,R1,R5
   \       0x4E   0x1E49             SUBS     R1,R1,#+1
   1820          
   1821              if (blk_ix >= pmem_pool->BlkNbr) {                              /* Validate ix range.                               */
   \       0x50   0x6AE2             LDR      R2,[R4, #+44]
   \       0x52   0x4291             CMP      R1,R2
   \       0x54   0xD305             BCC      ??Mem_PoolBlkGetUsedAtIx_5
   1822                  CPU_CRITICAL_EXIT();
   \       0x56   0x....'....        BL       CPU_SR_Restore
   1823                 *perr = LIB_MEM_ERR_INVALID_BLK_IX;
   \       0x5A   0x....             LDR      R0,??DataTable9_5  ;; 0x2795
   \       0x5C   0x8030             STRH     R0,[R6, #+0]
   1824                  return ((void *)0);
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xE011             B        ??Mem_PoolBlkGetUsedAtIx_2
   1825              }
   1826          
   1827              if (blk_ix < pmem_pool->BlkIx) {
   \                     ??Mem_PoolBlkGetUsedAtIx_5: (+1)
   \       0x62   0x6A62             LDR      R2,[R4, #+36]
   \       0x64   0x4291             CMP      R1,R2
   \       0x66   0xD205             BCS      ??Mem_PoolBlkGetUsedAtIx_6
   1828                  CPU_CRITICAL_EXIT();
   \       0x68   0x....'....        BL       CPU_SR_Restore
   1829                 *perr = LIB_MEM_ERR_INVALID_BLK_IX;
   \       0x6C   0x....             LDR      R0,??DataTable9_5  ;; 0x2795
   \       0x6E   0x8030             STRH     R0,[R6, #+0]
   1830                  return ((void *)0);
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0xE008             B        ??Mem_PoolBlkGetUsedAtIx_2
   1831              }
   1832                                                                              /* ------------ GET MEM BLK FROM POOL ------------- */
   1833              pmem_blk = pmem_pool->PoolPtrs[blk_ix];
   \                     ??Mem_PoolBlkGetUsedAtIx_6: (+1)
   \       0x74   0x6A22             LDR      R2,[R4, #+32]
   \       0x76   0x2304             MOVS     R3,#+4
   \       0x78   0x4359             MULS     R1,R3,R1
   \       0x7A   0x5854             LDR      R4,[R2, R1]
   1834          
   1835              CPU_CRITICAL_EXIT();
   \       0x7C   0x....'....        BL       CPU_SR_Restore
   1836          
   1837             *perr =  LIB_MEM_ERR_NONE;
   \       0x80   0x....             LDR      R0,??DataTable10  ;; 0x2710
   \       0x82   0x8030             STRH     R0,[R6, #+0]
   1838          
   1839              return (pmem_blk);
   \       0x84   0x0020             MOVS     R0,R4
   \                     ??Mem_PoolBlkGetUsedAtIx_2: (+1)
   \       0x86   0xBD70             POP      {R4-R6,PC}       ;; return
   1840          }
   1841          #endif
   1842          
   1843          
   1844          /*$PAGE*/
   1845          /*
   1846          *********************************************************************************************************
   1847          *                                          Mem_PoolBlkFree()
   1848          *
   1849          * Description : Free a memory block to memory pool.
   1850          *
   1851          * Argument(s) : pmem_pool   Pointer to memory pool to free memory block.
   1852          *
   1853          *               pmem_blk    Pointer to memory block address to free.
   1854          *
   1855          *               perr        Pointer to variable that will receive the return error code from this function :
   1856          *
   1857          *                               LIB_MEM_ERR_NONE                            Memory block successfully freed.
   1858          *                               LIB_MEM_ERR_POOL_FULL                   ALL memory blocks already available in
   1859          *                                                                           memory pool.
   1860          *
   1861          *                               LIB_MEM_ERR_NULL_PTR                    Argument 'pmem_pool'/'pmem_blk' passed
   1862          *                                                                           a NULL pointer.
   1863          *                               LIB_MEM_ERR_INVALID_POOL                Invalid memory pool  type.
   1864          *                               LIB_MEM_ERR_INVALID_BLK_ADDR            Invalid memory block address.
   1865          *                               LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL            Memory block address already
   1866          *                                                                            in memory pool.
   1867          *
   1868          * Return(s)   : none.
   1869          *
   1870          * Caller(s)   : Application.
   1871          *
   1872          * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1873          *********************************************************************************************************
   1874          */
   1875          /*$PAGE*/
   1876          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1877          void  Mem_PoolBlkFree (MEM_POOL  *pmem_pool,
   1878                                 void      *pmem_blk,
   1879                                 LIB_ERR   *perr)
   1880          {
   \                     Mem_PoolBlkFree: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   1881              void         *p_addr;
   1882              CPU_BOOLEAN   addr_valid;
   1883              MEM_POOL_IX   i;
   1884              CPU_SR_ALLOC();
   \        0x8   0x2000             MOVS     R0,#+0
   1885          
   1886          
   1887          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   1888              if (perr == (LIB_ERR *)0) {
   \        0xA   0x2E00             CMP      R6,#+0
   \        0xC   0xD101             BNE      ??Mem_PoolBlkFree_0
   1889                  CPU_SW_EXCEPTION(;);
   \        0xE   0x....'....        BL       CPU_SW_Exception
   1890              }
   1891          #endif
   1892          
   1893                                                                              /* ------------ VALIDATE MEM POOL FREE ------------ */
   1894          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Validate mem ptrs.                               */
   1895              if (pmem_pool == (MEM_POOL *)0) {
   \                     ??Mem_PoolBlkFree_0: (+1)
   \       0x12   0x2C00             CMP      R4,#+0
   \       0x14   0xD102             BNE      ??Mem_PoolBlkFree_1
   1896                 *perr = LIB_MEM_ERR_NULL_PTR;
   \       0x16   0x....             LDR      R0,??DataTable9_1  ;; 0x2711
   \       0x18   0x8030             STRH     R0,[R6, #+0]
   1897                  return;
   \       0x1A   0xE068             B        ??Mem_PoolBlkFree_2
   1898              }
   \                     ??Mem_PoolBlkFree_1: (+1)
   \       0x1C   0x002F             MOVS     R7,R5
   1899          
   1900              if (pmem_blk == (void *)0) {
   \       0x1E   0x2F00             CMP      R7,#+0
   \       0x20   0xD102             BNE      ??Mem_PoolBlkFree_3
   1901                 *perr = LIB_MEM_ERR_NULL_PTR;
   \       0x22   0x....             LDR      R0,??DataTable9_1  ;; 0x2711
   \       0x24   0x8030             STRH     R0,[R6, #+0]
   1902                  return;
   \       0x26   0xE062             B        ??Mem_PoolBlkFree_2
   1903              }
   1904          #endif
   1905          
   1906              CPU_CRITICAL_ENTER();
   \                     ??Mem_PoolBlkFree_3: (+1)
   \       0x28   0x....'....        BL       CPU_SR_Save
   \       0x2C   0x0005             MOVS     R5,R0
   1907          
   1908          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1909              if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x....             LDR      R1,??DataTable10_2  ;; 0x4c4f4f50
   \       0x32   0x4288             CMP      R0,R1
   \       0x34   0xD005             BEQ      ??Mem_PoolBlkFree_4
   1910                  CPU_CRITICAL_EXIT();
   \       0x36   0x0028             MOVS     R0,R5
   \       0x38   0x....'....        BL       CPU_SR_Restore
   1911                 *perr = LIB_MEM_ERR_INVALID_POOL;
   \       0x3C   0x....             LDR      R0,??DataTable9_2  ;; 0x2788
   \       0x3E   0x8030             STRH     R0,[R6, #+0]
   1912                  return;
   \       0x40   0xE055             B        ??Mem_PoolBlkFree_2
   1913              }
   1914          
   1915              addr_valid = Mem_PoolBlkIsValidAddr(pmem_pool, pmem_blk);       /* Validate mem blk as valid pool blk addr.         */
   \                     ??Mem_PoolBlkFree_4: (+1)
   \       0x42   0x0039             MOVS     R1,R7
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0x....'....        BL       Mem_PoolBlkIsValidAddr
   1916              if (addr_valid != DEF_OK) {
   \       0x4A   0xB2C0             UXTB     R0,R0
   \       0x4C   0x2801             CMP      R0,#+1
   \       0x4E   0xD005             BEQ      ??Mem_PoolBlkFree_5
   1917                  CPU_CRITICAL_EXIT();
   \       0x50   0x0028             MOVS     R0,R5
   \       0x52   0x....'....        BL       CPU_SR_Restore
   1918                 *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
   \       0x56   0x....             LDR      R0,??DataTable10_3  ;; 0x2797
   \       0x58   0x8030             STRH     R0,[R6, #+0]
   1919                  return;
   \       0x5A   0xE048             B        ??Mem_PoolBlkFree_2
   1920              }
   1921          
   1922              for (i = 0u; i < pmem_pool->BlkIx; i++) {                       /* Validate mem blk  NOT already in pool.           */
   \                     ??Mem_PoolBlkFree_5: (+1)
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0x0001             MOVS     R1,R0
   \       0x60   0xE000             B        ??Mem_PoolBlkFree_6
   \                     ??Mem_PoolBlkFree_7: (+1)
   \       0x62   0x1C49             ADDS     R1,R1,#+1
   \                     ??Mem_PoolBlkFree_6: (+1)
   \       0x64   0x6A62             LDR      R2,[R4, #+36]
   \       0x66   0x4291             CMP      R1,R2
   \       0x68   0xD20B             BCS      ??Mem_PoolBlkFree_8
   1923                  if (pmem_blk == pmem_pool->PoolPtrs[i]) {
   \       0x6A   0x6A22             LDR      R2,[R4, #+32]
   \       0x6C   0x2304             MOVS     R3,#+4
   \       0x6E   0x434B             MULS     R3,R1,R3
   \       0x70   0x58D2             LDR      R2,[R2, R3]
   \       0x72   0x4297             CMP      R7,R2
   \       0x74   0xD1F5             BNE      ??Mem_PoolBlkFree_7
   1924                      CPU_CRITICAL_EXIT();
   \       0x76   0x0028             MOVS     R0,R5
   \       0x78   0x....'....        BL       CPU_SR_Restore
   1925                     *perr = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
   \       0x7C   0x....             LDR      R0,??DataTable10_4  ;; 0x2798
   \       0x7E   0x8030             STRH     R0,[R6, #+0]
   1926                      return;
   \       0x80   0xE035             B        ??Mem_PoolBlkFree_2
   1927                  }
   1928              }
   1929          #endif
   1930          
   1931              if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool NOT already full.              */
   \                     ??Mem_PoolBlkFree_8: (+1)
   \       0x82   0x6A61             LDR      R1,[R4, #+36]
   \       0x84   0x6AE2             LDR      R2,[R4, #+44]
   \       0x86   0x4291             CMP      R1,R2
   \       0x88   0xD305             BCC      ??Mem_PoolBlkFree_9
   1932                  CPU_CRITICAL_EXIT();
   \       0x8A   0x0028             MOVS     R0,R5
   \       0x8C   0x....'....        BL       CPU_SR_Restore
   1933                 *perr = LIB_MEM_ERR_POOL_FULL;
   \       0x90   0x....             LDR      R0,??DataTable10_1  ;; 0x27dd
   \       0x92   0x8030             STRH     R0,[R6, #+0]
   1934                  return;
   \       0x94   0xE02B             B        ??Mem_PoolBlkFree_2
   1935              }
   1936          
   1937                                                                              /* ------------- FREE MEM BLK TO POOL ------------- */
   1938              addr_valid = DEF_NO;
   1939              for (i = pmem_pool->BlkIx; i < pmem_pool->BlkNbr; i++) {        /* Find ix of mem blk to free.                      */
   \                     ??Mem_PoolBlkFree_9: (+1)
   \       0x96   0x6A61             LDR      R1,[R4, #+36]
   \       0x98   0xE000             B        ??Mem_PoolBlkFree_10
   \                     ??Mem_PoolBlkFree_11: (+1)
   \       0x9A   0x1C49             ADDS     R1,R1,#+1
   \                     ??Mem_PoolBlkFree_10: (+1)
   \       0x9C   0x6AE2             LDR      R2,[R4, #+44]
   \       0x9E   0x4291             CMP      R1,R2
   \       0xA0   0xD206             BCS      ??Mem_PoolBlkFree_12
   1940                  p_addr = pmem_pool->PoolPtrs[i];
   \       0xA2   0x6A22             LDR      R2,[R4, #+32]
   \       0xA4   0x2304             MOVS     R3,#+4
   \       0xA6   0x434B             MULS     R3,R1,R3
   \       0xA8   0x58D2             LDR      R2,[R2, R3]
   1941                  if (p_addr == pmem_blk) {
   \       0xAA   0x42BA             CMP      R2,R7
   \       0xAC   0xD1F5             BNE      ??Mem_PoolBlkFree_11
   1942                      addr_valid = DEF_YES;
   \       0xAE   0x2001             MOVS     R0,#+1
   1943                      break;
   1944                  }
   1945              }
   1946                                                                              /* Swap addr of mem blk to free in tbl.             */
   1947              if (addr_valid == DEF_YES) {
   \                     ??Mem_PoolBlkFree_12: (+1)
   \       0xB0   0xB2C0             UXTB     R0,R0
   \       0xB2   0x2801             CMP      R0,#+1
   \       0xB4   0xD116             BNE      ??Mem_PoolBlkFree_13
   1948                  pmem_pool->PoolPtrs[i] = pmem_pool->PoolPtrs[pmem_pool->BlkIx];
   \       0xB6   0x6A20             LDR      R0,[R4, #+32]
   \       0xB8   0x6A62             LDR      R2,[R4, #+36]
   \       0xBA   0x2304             MOVS     R3,#+4
   \       0xBC   0x435A             MULS     R2,R3,R2
   \       0xBE   0x5880             LDR      R0,[R0, R2]
   \       0xC0   0x6A22             LDR      R2,[R4, #+32]
   \       0xC2   0x2304             MOVS     R3,#+4
   \       0xC4   0x4359             MULS     R1,R3,R1
   \       0xC6   0x5050             STR      R0,[R2, R1]
   1949              } else {
   1950          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1951                  CPU_CRITICAL_EXIT();
   1952                 *perr = LIB_MEM_ERR_INVALID_POOL;
   1953                  return;
   1954          #endif
   1955              }
   1956          
   1957                                                                              /* Free mem blk.                                    */
   1958              pmem_pool->PoolPtrs[pmem_pool->BlkIx] = pmem_blk;
   \       0xC8   0x6A20             LDR      R0,[R4, #+32]
   \       0xCA   0x6A61             LDR      R1,[R4, #+36]
   \       0xCC   0x2204             MOVS     R2,#+4
   \       0xCE   0x4351             MULS     R1,R2,R1
   \       0xD0   0x5047             STR      R7,[R0, R1]
   1959              pmem_pool->BlkIx++;
   \       0xD2   0x6A60             LDR      R0,[R4, #+36]
   \       0xD4   0x1C40             ADDS     R0,R0,#+1
   \       0xD6   0x6260             STR      R0,[R4, #+36]
   1960          
   1961              CPU_CRITICAL_EXIT();
   \       0xD8   0x0028             MOVS     R0,R5
   \       0xDA   0x....'....        BL       CPU_SR_Restore
   1962          
   1963             *perr = LIB_MEM_ERR_NONE;
   \       0xDE   0x....             LDR      R0,??DataTable9  ;; 0x2710
   \       0xE0   0x8030             STRH     R0,[R6, #+0]
   1964          }
   \       0xE2   0xE004             B        ??Mem_PoolBlkFree_2
   \                     ??Mem_PoolBlkFree_13: (+1)
   \       0xE4   0x0028             MOVS     R0,R5
   \       0xE6   0x....'....        BL       CPU_SR_Restore
   \       0xEA   0x....             LDR      R0,??DataTable9_2  ;; 0x2788
   \       0xEC   0x8030             STRH     R0,[R6, #+0]
   \                     ??Mem_PoolBlkFree_2: (+1)
   \       0xEE   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1965          #endif
   1966          
   1967          
   1968          /*$PAGE*/
   1969          /*
   1970          *********************************************************************************************************
   1971          *                                          Mem_PoolBlkIxGet()
   1972          *
   1973          * Description : Get temporary index of a memory block in a memory pool.
   1974          *
   1975          * Argument(s) : pmem_pool   Pointer to memory pool.
   1976          *
   1977          *               pmem_blk    Pointer to memory block to get index for.
   1978          *
   1979          *               perr        Pointer to variable that will receive the return error code from this function :
   1980          *
   1981          *                               LIB_MEM_ERR_NONE                        Memory block successfully freed.
   1982          *                               LIB_MEM_ERR_POOL_FULL                   ALL memory blocks already available in
   1983          *                                                                           memory pool.
   1984          *
   1985          *                               LIB_MEM_ERR_NULL_PTR                    Argument 'pmem_pool'/'pmem_blk' passed
   1986          *                                                                           a NULL pointer.
   1987          *                               LIB_MEM_ERR_INVALID_POOL                Invalid memory pool  type.
   1988          *                               LIB_MEM_ERR_INVALID_BLK_ADDR            Invalid memory block address.
   1989          *                               LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL            Memory block address already
   1990          *                                                                            in memory pool.
   1991          *
   1992          * Return(s)   : Index of the memory block.
   1993          *
   1994          * Caller(s)   : Application.
   1995          *
   1996          * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1997          *
   1998          *               (2) The returned index can be altered when Mem_PoolBlkFree() is called. This index must
   1999          *                   only be used in conjunction with Mem_PoolBlkGetUsedAtIx() if holding a proper
   2000          *                   lock to avoid the index to be modified.
   2001          *********************************************************************************************************
   2002          */
   2003          /*$PAGE*/
   2004          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   2005          MEM_POOL_IX  Mem_PoolBlkIxGet (MEM_POOL  *pmem_pool,
   2006                                         void      *pmem_blk,
   2007                                         LIB_ERR   *perr)
   2008          {
   \                     Mem_PoolBlkIxGet: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0017             MOVS     R7,R2
   2009              void         *p_addr;
   2010              CPU_BOOLEAN   addr_valid;
   2011              MEM_POOL_IX   i;
   2012              MEM_POOL_IX   pool_ix;
   2013              MEM_POOL_IX   invalid_ix;
   2014              CPU_SR_ALLOC();
   \        0x8   0x2000             MOVS     R0,#+0
   2015          
   2016          
   2017              invalid_ix = DEF_GET_U_MAX_VAL(MEM_POOL_IX);
   \        0xA   0x2500             MOVS     R5,#+0
   \        0xC   0x43ED             MVNS     R5,R5            ;; #-1
   2018          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   2019              if (perr == (LIB_ERR *)0) {
   \        0xE   0x2F00             CMP      R7,#+0
   \       0x10   0xD101             BNE      ??Mem_PoolBlkIxGet_0
   2020                  CPU_SW_EXCEPTION(invalid_ix);
   \       0x12   0x....'....        BL       CPU_SW_Exception
   2021              }
   2022          #endif
   2023          
   2024                                                                              /* ------------ VALIDATE MEM POOL FREE ------------ */
   2025          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Validate mem ptrs.                               */
   2026              if (pmem_pool == (MEM_POOL *)0) {
   \                     ??Mem_PoolBlkIxGet_0: (+1)
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD103             BNE      ??Mem_PoolBlkIxGet_1
   2027                 *perr = LIB_MEM_ERR_NULL_PTR;
   \       0x1A   0x....             LDR      R0,??DataTable10_5  ;; 0x2711
   \       0x1C   0x8038             STRH     R0,[R7, #+0]
   2028                  return (invalid_ix);
   \       0x1E   0x0028             MOVS     R0,R5
   \       0x20   0xE066             B        ??Mem_PoolBlkIxGet_2
   2029              }
   \                     ??Mem_PoolBlkIxGet_1: (+1)
   \       0x22   0x9600             STR      R6,[SP, #+0]
   2030          
   2031              if (pmem_blk == (void *)0) {
   \       0x24   0x9800             LDR      R0,[SP, #+0]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD103             BNE      ??Mem_PoolBlkIxGet_3
   2032                 *perr = LIB_MEM_ERR_NULL_PTR;
   \       0x2A   0x....             LDR      R0,??DataTable10_5  ;; 0x2711
   \       0x2C   0x8038             STRH     R0,[R7, #+0]
   2033                  return (invalid_ix);
   \       0x2E   0x0028             MOVS     R0,R5
   \       0x30   0xE05E             B        ??Mem_PoolBlkIxGet_2
   2034              }
   2035          #endif
   2036          
   2037              CPU_CRITICAL_ENTER();
   \                     ??Mem_PoolBlkIxGet_3: (+1)
   \       0x32   0x....'....        BL       CPU_SR_Save
   \       0x36   0x0006             MOVS     R6,R0
   2038          
   2039          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2040              if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x....             LDR      R1,??DataTable10_2  ;; 0x4c4f4f50
   \       0x3C   0x4288             CMP      R0,R1
   \       0x3E   0xD006             BEQ      ??Mem_PoolBlkIxGet_4
   2041                  CPU_CRITICAL_EXIT();
   \       0x40   0x0030             MOVS     R0,R6
   \       0x42   0x....'....        BL       CPU_SR_Restore
   2042                 *perr = LIB_MEM_ERR_INVALID_POOL;
   \       0x46   0x....             LDR      R0,??DataTable10_6  ;; 0x2788
   \       0x48   0x8038             STRH     R0,[R7, #+0]
   2043                  return(invalid_ix);
   \       0x4A   0x0028             MOVS     R0,R5
   \       0x4C   0xE050             B        ??Mem_PoolBlkIxGet_2
   2044              }
   2045          
   2046              addr_valid = Mem_PoolBlkIsValidAddr(pmem_pool, pmem_blk);       /* Validate mem blk as valid pool blk addr.         */
   \                     ??Mem_PoolBlkIxGet_4: (+1)
   \       0x4E   0x9900             LDR      R1,[SP, #+0]
   \       0x50   0x0020             MOVS     R0,R4
   \       0x52   0x....'....        BL       Mem_PoolBlkIsValidAddr
   2047              if (addr_valid != DEF_OK) {
   \       0x56   0xB2C0             UXTB     R0,R0
   \       0x58   0x2801             CMP      R0,#+1
   \       0x5A   0xD006             BEQ      ??Mem_PoolBlkIxGet_5
   2048                  CPU_CRITICAL_EXIT();
   \       0x5C   0x0030             MOVS     R0,R6
   \       0x5E   0x....'....        BL       CPU_SR_Restore
   2049                 *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
   \       0x62   0x....             LDR      R0,??DataTable10_3  ;; 0x2797
   \       0x64   0x8038             STRH     R0,[R7, #+0]
   2050                  return (invalid_ix);
   \       0x66   0x0028             MOVS     R0,R5
   \       0x68   0xE042             B        ??Mem_PoolBlkIxGet_2
   2051              }
   2052          
   2053              for (i = 0u; i < pmem_pool->BlkIx; i++) {                       /* Validate mem blk  NOT already in pool.           */
   \                     ??Mem_PoolBlkIxGet_5: (+1)
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0x0001             MOVS     R1,R0
   \       0x6E   0xE000             B        ??Mem_PoolBlkIxGet_6
   \                     ??Mem_PoolBlkIxGet_7: (+1)
   \       0x70   0x1C49             ADDS     R1,R1,#+1
   \                     ??Mem_PoolBlkIxGet_6: (+1)
   \       0x72   0x6A62             LDR      R2,[R4, #+36]
   \       0x74   0x4291             CMP      R1,R2
   \       0x76   0xD20F             BCS      ??Mem_PoolBlkIxGet_8
   2054                  if (pmem_blk == pmem_pool->PoolPtrs[i]) {
   \       0x78   0x9B00             LDR      R3,[SP, #+0]
   \       0x7A   0x469C             MOV      R12,R3
   \       0x7C   0x6A23             LDR      R3,[R4, #+32]
   \       0x7E   0x2204             MOVS     R2,#+4
   \       0x80   0x434A             MULS     R2,R1,R2
   \       0x82   0x589A             LDR      R2,[R3, R2]
   \       0x84   0x4663             MOV      R3,R12
   \       0x86   0x4293             CMP      R3,R2
   \       0x88   0xD1F2             BNE      ??Mem_PoolBlkIxGet_7
   2055                      CPU_CRITICAL_EXIT();
   \       0x8A   0x0030             MOVS     R0,R6
   \       0x8C   0x....'....        BL       CPU_SR_Restore
   2056                     *perr = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
   \       0x90   0x....             LDR      R0,??DataTable10_4  ;; 0x2798
   \       0x92   0x8038             STRH     R0,[R7, #+0]
   2057                      return (invalid_ix);
   \       0x94   0x0028             MOVS     R0,R5
   \       0x96   0xE02B             B        ??Mem_PoolBlkIxGet_2
   2058                  }
   2059              }
   2060          #endif
   2061          
   2062              if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool NOT full.                      */
   \                     ??Mem_PoolBlkIxGet_8: (+1)
   \       0x98   0x6A61             LDR      R1,[R4, #+36]
   \       0x9A   0x6AE2             LDR      R2,[R4, #+44]
   \       0x9C   0x4291             CMP      R1,R2
   \       0x9E   0xD306             BCC      ??Mem_PoolBlkIxGet_9
   2063                  CPU_CRITICAL_EXIT();
   \       0xA0   0x0030             MOVS     R0,R6
   \       0xA2   0x....'....        BL       CPU_SR_Restore
   2064                 *perr = LIB_MEM_ERR_POOL_FULL;
   \       0xA6   0x....             LDR      R0,??DataTable10_1  ;; 0x27dd
   \       0xA8   0x8038             STRH     R0,[R7, #+0]
   2065                  return (invalid_ix);
   \       0xAA   0x0028             MOVS     R0,R5
   \       0xAC   0xE020             B        ??Mem_PoolBlkIxGet_2
   2066              }
   2067          
   2068              addr_valid = DEF_NO;
   2069              for (i = pmem_pool->BlkIx; i < pmem_pool->BlkNbr; i++) {        /* Find ix of mem blk.                              */
   \                     ??Mem_PoolBlkIxGet_9: (+1)
   \       0xAE   0x6A61             LDR      R1,[R4, #+36]
   \       0xB0   0xE000             B        ??Mem_PoolBlkIxGet_10
   \                     ??Mem_PoolBlkIxGet_11: (+1)
   \       0xB2   0x1C49             ADDS     R1,R1,#+1
   \                     ??Mem_PoolBlkIxGet_10: (+1)
   \       0xB4   0x6AE2             LDR      R2,[R4, #+44]
   \       0xB6   0x4291             CMP      R1,R2
   \       0xB8   0xD207             BCS      ??Mem_PoolBlkIxGet_12
   2070                  p_addr = pmem_pool->PoolPtrs[i];
   \       0xBA   0x6A22             LDR      R2,[R4, #+32]
   \       0xBC   0x2304             MOVS     R3,#+4
   \       0xBE   0x434B             MULS     R3,R1,R3
   \       0xC0   0x58D2             LDR      R2,[R2, R3]
   2071                  if (p_addr == pmem_blk) {
   \       0xC2   0x9B00             LDR      R3,[SP, #+0]
   \       0xC4   0x429A             CMP      R2,R3
   \       0xC6   0xD1F4             BNE      ??Mem_PoolBlkIxGet_11
   2072                      addr_valid = DEF_YES;
   \       0xC8   0x2001             MOVS     R0,#+1
   2073                      break;
   2074                  }
   2075              }
   2076                                                                              /* Return ix of mem blk in tbl.                     */
   2077              if (addr_valid == DEF_YES) {
   \                     ??Mem_PoolBlkIxGet_12: (+1)
   \       0xCA   0xB2C0             UXTB     R0,R0
   \       0xCC   0x2801             CMP      R0,#+1
   \       0xCE   0xD109             BNE      ??Mem_PoolBlkIxGet_13
   2078                  pool_ix = pmem_pool->BlkNbr - 1 - i;
   \       0xD0   0x6AE0             LDR      R0,[R4, #+44]
   \       0xD2   0x1E40             SUBS     R0,R0,#+1
   \       0xD4   0x1A44             SUBS     R4,R0,R1
   2079                  CPU_CRITICAL_EXIT();
   \       0xD6   0x0030             MOVS     R0,R6
   \       0xD8   0x....'....        BL       CPU_SR_Restore
   2080                 *perr = LIB_MEM_ERR_NONE;
   \       0xDC   0x....             LDR      R0,??DataTable10  ;; 0x2710
   \       0xDE   0x8038             STRH     R0,[R7, #+0]
   2081                  return (pool_ix);
   \       0xE0   0x0020             MOVS     R0,R4
   \       0xE2   0xE005             B        ??Mem_PoolBlkIxGet_2
   2082              } else {
   2083                  CPU_CRITICAL_EXIT();
   \                     ??Mem_PoolBlkIxGet_13: (+1)
   \       0xE4   0x0030             MOVS     R0,R6
   \       0xE6   0x....'....        BL       CPU_SR_Restore
   2084                 *perr = LIB_MEM_ERR_INVALID_POOL;
   \       0xEA   0x....             LDR      R0,??DataTable10_6  ;; 0x2788
   \       0xEC   0x8038             STRH     R0,[R7, #+0]
   2085                  return (invalid_ix);
   \       0xEE   0x0028             MOVS     R0,R5
   \                     ??Mem_PoolBlkIxGet_2: (+1)
   \       0xF0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2086              }
   2087          
   2088          }
   2089          #endif
   2090          
   2091          
   2092          /*$PAGE*/
   2093          /*
   2094          *********************************************************************************************************
   2095          *********************************************************************************************************
   2096          *                                           LOCAL FUNCTIONS
   2097          *********************************************************************************************************
   2098          *********************************************************************************************************
   2099          */
   2100          
   2101          /*
   2102          *********************************************************************************************************
   2103          *                                      Mem_PoolBlkIsValidAddr()
   2104          *
   2105          * Description : Calculates if a given memory block address is valid for the memory pool.
   2106          *
   2107          * Argument(s) : pmem_pool   Pointer to memory pool structure to validate memory block address.
   2108          *               ---------   Argument validated in Mem_PoolBlkFree().
   2109          *
   2110          *               pmem_blk    Pointer to memory block address to validate.
   2111          *               --------    Argument validated in Mem_PoolBlkFree().
   2112          *
   2113          * Return(s)   : DEF_YES, if valid memory pool block address.
   2114          *
   2115          *               DEF_NO,  otherwise.
   2116          *
   2117          * Caller(s)   : Mem_PoolBlkFree().
   2118          *
   2119          * Note(s)     : none.
   2120          *********************************************************************************************************
   2121          */
   2122          
   2123          #if ((LIB_MEM_CFG_ALLOC_EN       == DEF_ENABLED) && \
   2124               (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED))

   \                                 In section .text, align 2, keep-with-next
   2125          static  CPU_BOOLEAN  Mem_PoolBlkIsValidAddr (MEM_POOL  *pmem_pool,
   2126                                                       void      *pmem_blk)
   2127          {
   \                     Mem_PoolBlkIsValidAddr: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
   \        0x4   0x000C             MOVS     R4,R1
   2128              CPU_INT08U   *ppool_addr_first;
   2129              void         *ppool_addr_start;
   2130              void         *ppool_addr_end;
   2131              CPU_SIZE_T    align_offset;
   2132              CPU_SIZE_T    blk_align;
   2133              CPU_SIZE_T    blk_align_offset;
   2134              CPU_SIZE_T    blk_size;
   2135              CPU_SIZE_T    mem_align;
   2136              CPU_SIZE_T    mem_align_offset;
   2137              CPU_SIZE_T    mem_diff;
   2138              CPU_BOOLEAN   addr_valid;
   2139          
   2140          
   2141              ppool_addr_start = pmem_pool->PoolAddrStart;
   \        0x6   0x69B8             LDR      R0,[R7, #+24]
   \        0x8   0x9000             STR      R0,[SP, #+0]
   2142              ppool_addr_end   = pmem_pool->PoolAddrEnd;
   \        0xA   0x69F8             LDR      R0,[R7, #+28]
   2143          
   2144              if ((pmem_blk < ppool_addr_start) ||
   2145                  (pmem_blk > ppool_addr_end)) {
   \        0xC   0x9900             LDR      R1,[SP, #+0]
   \        0xE   0x428C             CMP      R4,R1
   \       0x10   0xD301             BCC      ??Mem_PoolBlkIsValidAddr_0
   \       0x12   0x42A0             CMP      R0,R4
   \       0x14   0xD201             BCS      ??Mem_PoolBlkIsValidAddr_1
   2146                  return (DEF_NO);
   \                     ??Mem_PoolBlkIsValidAddr_0: (+1)
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xE01F             B        ??Mem_PoolBlkIsValidAddr_2
   2147              }
   2148          
   2149              blk_align      = (CPU_SIZE_T)pmem_pool->BlkAlign;
   \                     ??Mem_PoolBlkIsValidAddr_1: (+1)
   \       0x1A   0x6B7D             LDR      R5,[R7, #+52]
   2150              align_offset   = (CPU_SIZE_T)((CPU_ADDR)ppool_addr_start % blk_align);
   \       0x1C   0x9800             LDR      R0,[SP, #+0]
   \       0x1E   0x0029             MOVS     R1,R5
   \       0x20   0x....'....        BL       __aeabi_uidivmod
   2151              if (align_offset != 0u) {
   \       0x24   0x2900             CMP      R1,#+0
   \       0x26   0xD001             BEQ      ??Mem_PoolBlkIsValidAddr_3
   2152                  mem_align_offset = blk_align - align_offset;
   \       0x28   0x1A6E             SUBS     R6,R5,R1
   \       0x2A   0xE000             B        ??Mem_PoolBlkIsValidAddr_4
   2153              } else {
   2154                  mem_align_offset = 0u;
   \                     ??Mem_PoolBlkIsValidAddr_3: (+1)
   \       0x2C   0x2600             MOVS     R6,#+0
   2155              }
   2156          
   2157              blk_size     = pmem_pool->BlkSize;
   \                     ??Mem_PoolBlkIsValidAddr_4: (+1)
   \       0x2E   0x6B3F             LDR      R7,[R7, #+48]
   2158              align_offset = blk_size % blk_align;
   \       0x30   0x0038             MOVS     R0,R7
   \       0x32   0x0029             MOVS     R1,R5
   \       0x34   0x....'....        BL       __aeabi_uidivmod
   2159              if (align_offset != 0u) {
   \       0x38   0x2900             CMP      R1,#+0
   \       0x3A   0xD001             BEQ      ??Mem_PoolBlkIsValidAddr_5
   2160                  blk_align_offset = blk_align - align_offset;
   \       0x3C   0x1A69             SUBS     R1,R5,R1
   \       0x3E   0xE000             B        ??Mem_PoolBlkIsValidAddr_6
   2161              } else {
   2162                  blk_align_offset = 0u;
   \                     ??Mem_PoolBlkIsValidAddr_5: (+1)
   \       0x40   0x2100             MOVS     R1,#+0
   2163              }
   2164          
   2165              ppool_addr_first = (CPU_INT08U *)((CPU_INT08U *)ppool_addr_start + mem_align_offset);
   \                     ??Mem_PoolBlkIsValidAddr_6: (+1)
   \       0x42   0x9800             LDR      R0,[SP, #+0]
   \       0x44   0x1980             ADDS     R0,R0,R6
   2166              mem_diff         = (CPU_SIZE_T  )((CPU_INT08U *)pmem_blk         - ppool_addr_first);
   \       0x46   0x1A20             SUBS     R0,R4,R0
   2167              mem_align        = (CPU_SIZE_T  )(              blk_size         + blk_align_offset);
   \       0x48   0x1879             ADDS     R1,R7,R1
   2168          
   2169              addr_valid       = ((mem_diff % mem_align) == 0u) ? DEF_YES : DEF_NO;
   \       0x4A   0x....'....        BL       __aeabi_uidivmod
   \       0x4E   0x2900             CMP      R1,#+0
   \       0x50   0xD101             BNE      ??Mem_PoolBlkIsValidAddr_7
   \       0x52   0x2001             MOVS     R0,#+1
   \       0x54   0xE000             B        ??Mem_PoolBlkIsValidAddr_8
   \                     ??Mem_PoolBlkIsValidAddr_7: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   2170          
   2171              return (addr_valid);
   \                     ??Mem_PoolBlkIsValidAddr_8: (+1)
   \       0x58   0xB2C0             UXTB     R0,R0
   \                     ??Mem_PoolBlkIsValidAddr_2: (+1)
   \       0x5A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2172          }
   2173          #endif
   2174          
   2175          
   2176          /*$PAGE*/
   2177          /*
   2178          *********************************************************************************************************
   2179          *                                        Mem_SegCalcTotSize()
   2180          *
   2181          * Description : (1) Calculates total memory segment size for number of blocks with specific size & alignment :
   2182          *
   2183          *
   2184          *                       -----                     ======================  ---
   2185          *                         ^       Mem Addr  --->  |  /  /  /  /  /  /  |   ^
   2186          *                         |    (see Note #1a)     | /  /  /  /  /  /  /|   |    Mem Align Offset
   2187          *                         |                       |/  /  /  /  /  /  / |   |  (see Notes #1e & #2a)
   2188          *                         |                       |  /  /  /  /  /  /  |   v
   2189          *                         |                       ======================  ---
   2190          *                         |                       |                    |   ^
   2191          *                         |                       |                    |   |
   2192          *                         |                       |     Mem Blk #1     |   |        Blk Size
   2193          *                         |                       |                    |   |     (see Note #1c)
   2194          *                         |                       |                    |   v
   2195          *                         |                       ----------------------  ---
   2196          *                         |                       |  /  /  /  /  /  /  |   ^
   2197          *                         |                       | /  /  /  /  /  /  /|   |    Blk Align Offset
   2198          *                         |                       |/  /  /  /  /  /  / |   |  (see Notes #1f & #2b)
   2199          *                         |                       |  /  /  /  /  /  /  |   v
   2200          *                         |                       ======================  ---
   2201          *                                                 |         .          |
   2202          *                     Total Size                  |         .          |
   2203          *                   (see Note #2c)                |         .          |
   2204          *                                                 ======================  ---
   2205          *                         |                       |                    |   ^
   2206          *                         |                       |                    |   |
   2207          *                         |                       |   Mem Blk #N - 1   |   |        Blk Size
   2208          *                         |                       |                    |   |     (see Note #1c)
   2209          *                         |                       |                    |   v
   2210          *                         |                       ----------------------  ---
   2211          *                         |                       |  /  /  /  /  /  /  |   ^
   2212          *                         |                       | /  /  /  /  /  /  /|   |    Blk Align Offset
   2213          *                         |                       |/  /  /  /  /  /  / |   |  (see Notes #1f & #2b)
   2214          *                         |                       |  /  /  /  /  /  /  |   v
   2215          *                         |                       ======================  ---
   2216          *                         |                       |                    |   ^
   2217          *                         |                       |                    |   |
   2218          *                         |                       |     Mem Blk #N     |   |        Blk Size
   2219          *                         |                       |                    |   |     (see Note #1c)
   2220          *                         v                       |                    |   v
   2221          *                       -----                     ======================  ---
   2222          *
   2223          *               where
   2224          *
   2225          *                   (a) Mem Addr            Memory address of the beginning of the memory block ('pmem_addr')
   2226          *
   2227          *                   (b) N                   Number of memory blocks to allocate ('blk_nbr')
   2228          *
   2229          *                   (c) Blk Size            Size   of memory block  to allocate ('blk_size')
   2230          *
   2231          *                   (d) Align               Required block memory alignment     ('blk_align')
   2232          *
   2233          *                   (e) Mem Align Offset    Offset required to align first memory block
   2234          *
   2235          *                   (f) Blk Align Offset    Offset required to align every memory block
   2236          *
   2237          *
   2238          *               (2) The total size is calculated based on the following equations :
   2239          *
   2240          *                                            { (1) Align - (Mem Addr % Align) , if memory address is not aligned
   2241          *                   (a) Mem Align Offset  =  {
   2242          *                                            { (2) 0                          , if memory address is     aligned
   2243          *
   2244          *
   2245          *                                            { (1) Align - (Size     % Align) , if memory block   is not aligned
   2246          *                   (b) Blk Align Offset  =  {
   2247          *                                            { (2) 0                          , if memory block   is     aligned
   2248          *
   2249          *
   2250          *                   (c) Total Size        =   Mem Align Offset
   2251          *                                         + ((Blk Size + Blk Align Offset) * (N - 1))
   2252          *                                         +   Blk Size
   2253          *
   2254          *
   2255          * Argument(s) : pmem_addr   Memory address of the beginning of the memory block.
   2256          *
   2257          *               blk_nbr     Number of memory blocks to allocate.
   2258          *               -------     Argument checked in Mem_HeapAlloc(),
   2259          *                                               Mem_PoolCreate().
   2260          *
   2261          *               blk_size    Size   of memory block  to allocate.
   2262          *               --------    Argument checked in Mem_HeapAlloc(),
   2263          *                                               Mem_PoolCreate().
   2264          *
   2265          *               blk_align   Required block word-boundary memory alignment (in octets).
   2266          *               ---------   Argument checked in Mem_HeapAlloc(),
   2267          *                                               Mem_PoolCreate().
   2268          *
   2269          * Return(s)   : Total size of memory segment used to allocate the number of blocks, if NO error(s).
   2270          *
   2271          *               0,                                                                  otherwise.
   2272          *$PAGE*
   2273          * Caller(s)   : Mem_HeapAlloc(),
   2274          *               Mem_PoolCreate().
   2275          *
   2276          * Note(s)     : none.
   2277          *********************************************************************************************************
   2278          */
   2279          
   2280          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   2281          static  CPU_SIZE_T  Mem_SegCalcTotSize (void              *pmem_addr,
   2282                                                  MEM_POOL_BLK_QTY   blk_nbr,
   2283                                                  CPU_SIZE_T         blk_size,
   2284                                                  CPU_SIZE_T         blk_align)
   2285          {
   \                     Mem_SegCalcTotSize: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x000C             MOVS     R4,R1
   \        0x4   0x0015             MOVS     R5,R2
   \        0x6   0x001E             MOVS     R6,R3
   2286          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2287              CPU_SIZE_T  blk_size_mem_aligned;
   2288              CPU_SIZE_T  blk_size_aligned;
   2289              CPU_SIZE_T  blk_size_aligned_nbr;
   2290              CPU_SIZE_T  blk_size_tot;
   2291          #endif
   2292              CPU_SIZE_T  align_offset;
   2293              CPU_SIZE_T  mem_align_offset;
   2294              CPU_SIZE_T  blk_align_offset;
   2295              CPU_SIZE_T  size_tot;
   2296          
   2297                                                                              /* Calc mem align (see Note #2a).                   */
   2298              align_offset = (CPU_ADDR)pmem_addr % blk_align;
   \        0x8   0x0031             MOVS     R1,R6
   \        0xA   0x....'....        BL       __aeabi_uidivmod
   2299              if (align_offset != 0u) {
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD001             BEQ      ??Mem_SegCalcTotSize_0
   2300                  mem_align_offset = blk_align - align_offset;
   \       0x12   0x1A77             SUBS     R7,R6,R1
   \       0x14   0xE000             B        ??Mem_SegCalcTotSize_1
   2301              } else {
   2302                  mem_align_offset = 0u;
   \                     ??Mem_SegCalcTotSize_0: (+1)
   \       0x16   0x2700             MOVS     R7,#+0
   2303              }
   2304                                                                              /* Calc blk align (see Note #2b).                   */
   2305              align_offset = blk_size % blk_align;
   \                     ??Mem_SegCalcTotSize_1: (+1)
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0x0031             MOVS     R1,R6
   \       0x1C   0x....'....        BL       __aeabi_uidivmod
   2306              if (align_offset != 0u) {
   \       0x20   0x2900             CMP      R1,#+0
   \       0x22   0xD001             BEQ      ??Mem_SegCalcTotSize_2
   2307                  blk_align_offset = blk_align - align_offset;
   \       0x24   0x1A71             SUBS     R1,R6,R1
   \       0x26   0xE000             B        ??Mem_SegCalcTotSize_3
   2308              } else {
   2309                  blk_align_offset = 0u;
   \                     ??Mem_SegCalcTotSize_2: (+1)
   \       0x28   0x2100             MOVS     R1,#+0
   2310              }
   2311                                                                              /* Calc tot size  (see Note #2c).                   */
   2312              size_tot = mem_align_offset + ((blk_size + blk_align_offset) * ((CPU_SIZE_T)blk_nbr - 1)) + blk_size;
   \                     ??Mem_SegCalcTotSize_3: (+1)
   \       0x2A   0x1868             ADDS     R0,R5,R1
   \       0x2C   0x1E62             SUBS     R2,R4,#+1
   \       0x2E   0x4350             MULS     R0,R2,R0
   \       0x30   0x1838             ADDS     R0,R7,R0
   \       0x32   0x1940             ADDS     R0,R0,R5
   2313          
   2314          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Chk ovf of tot size = A + [(B + C) * D] + E      */
   2315              blk_size_mem_aligned = mem_align_offset + blk_size;             /* Chk ovf of A + E :                               */
   \       0x34   0x197A             ADDS     R2,R7,R5
   2316              if ((blk_size_mem_aligned < mem_align_offset) ||
   2317                  (blk_size_mem_aligned < blk_size)) {
   \       0x36   0x42BA             CMP      R2,R7
   \       0x38   0xD301             BCC      ??Mem_SegCalcTotSize_4
   \       0x3A   0x42AA             CMP      R2,R5
   \       0x3C   0xD201             BCS      ??Mem_SegCalcTotSize_5
   2318                  return (0u);
   \                     ??Mem_SegCalcTotSize_4: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xE021             B        ??Mem_SegCalcTotSize_6
   2319              }
   2320          
   2321              if (blk_nbr > 1) {
   \                     ??Mem_SegCalcTotSize_5: (+1)
   \       0x42   0x2C02             CMP      R4,#+2
   \       0x44   0xD31F             BCC      ??Mem_SegCalcTotSize_7
   2322                  blk_size_aligned = blk_size + blk_align_offset;
   \       0x46   0x186B             ADDS     R3,R5,R1
   2323                  if ((blk_size_aligned < blk_align_offset) ||                /* Chk ovf of      (B + C) :                        */
   2324                      (blk_size_aligned < blk_size)) {
   \       0x48   0x428B             CMP      R3,R1
   \       0x4A   0xD301             BCC      ??Mem_SegCalcTotSize_8
   \       0x4C   0x42AB             CMP      R3,R5
   \       0x4E   0xD201             BCS      ??Mem_SegCalcTotSize_9
   2325                      return (0u);
   \                     ??Mem_SegCalcTotSize_8: (+1)
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xE018             B        ??Mem_SegCalcTotSize_6
   2326                  }
   2327          
   2328                  blk_size_aligned_nbr = blk_size_aligned * ((CPU_SIZE_T)blk_nbr - 1);
   \                     ??Mem_SegCalcTotSize_9: (+1)
   \       0x54   0x1E64             SUBS     R4,R4,#+1
   \       0x56   0x435C             MULS     R4,R3,R4
   2329                  if ((blk_size_aligned_nbr < blk_size_aligned) ||            /* Chk ovf of     [(B + C) * D] :                   */
   2330                      (blk_size_aligned_nbr < blk_align_offset) ||
   2331                      (blk_size_aligned_nbr < blk_size)) {
   \       0x58   0x429C             CMP      R4,R3
   \       0x5A   0xD303             BCC      ??Mem_SegCalcTotSize_10
   \       0x5C   0x428C             CMP      R4,R1
   \       0x5E   0xD301             BCC      ??Mem_SegCalcTotSize_10
   \       0x60   0x42AC             CMP      R4,R5
   \       0x62   0xD201             BCS      ??Mem_SegCalcTotSize_11
   2332                      return (0u);
   \                     ??Mem_SegCalcTotSize_10: (+1)
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xE00E             B        ??Mem_SegCalcTotSize_6
   2333                  }
   2334          
   2335                  blk_size_tot = blk_size_aligned_nbr + blk_size;
   \                     ??Mem_SegCalcTotSize_11: (+1)
   \       0x68   0x1961             ADDS     R1,R4,R5
   2336                  if ((blk_size_tot < blk_size_aligned_nbr) ||                /* Chk ovf of     [(B + C) * D] + E :               */
   2337                      (blk_size_tot < blk_size)) {
   \       0x6A   0x42A1             CMP      R1,R4
   \       0x6C   0xD301             BCC      ??Mem_SegCalcTotSize_12
   \       0x6E   0x42A9             CMP      R1,R5
   \       0x70   0xD201             BCS      ??Mem_SegCalcTotSize_13
   2338                      return (0u);
   \                     ??Mem_SegCalcTotSize_12: (+1)
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0xE007             B        ??Mem_SegCalcTotSize_6
   2339                  }
   2340          
   2341                  if ((size_tot < blk_size_mem_aligned) ||                    /* Chk ovf of A + [(B + C) * D] + E :               */
   2342                      (size_tot < blk_size_aligned_nbr) ||
   2343                      (size_tot < blk_size_tot)) {
   \                     ??Mem_SegCalcTotSize_13: (+1)
   \       0x76   0x4290             CMP      R0,R2
   \       0x78   0xD303             BCC      ??Mem_SegCalcTotSize_14
   \       0x7A   0x42A0             CMP      R0,R4
   \       0x7C   0xD301             BCC      ??Mem_SegCalcTotSize_14
   \       0x7E   0x4288             CMP      R0,R1
   \       0x80   0xD201             BCS      ??Mem_SegCalcTotSize_7
   2344                      return (0u);
   \                     ??Mem_SegCalcTotSize_14: (+1)
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0xE7FF             B        ??Mem_SegCalcTotSize_6
   2345                  }
   2346              }
   2347          #endif
   2348          
   2349              return (size_tot);
   \                     ??Mem_SegCalcTotSize_7: (+1)
   \                     ??Mem_SegCalcTotSize_6: (+1)
   \       0x86   0xBDF0             POP      {R4-R7,PC}       ;; return
   2350          }
   2351          #endif
   2352          
   2353          
   2354          /*$PAGE*/
   2355          /*
   2356          *********************************************************************************************************
   2357          *                                           Mem_SegAlloc()
   2358          *
   2359          * Description : Allocates memory from specific segment.
   2360          *
   2361          * Argument(s) : pmem_pool   Pointer to memory pool structure containing segment information.
   2362          *               ---------   Argument validated in Mem_HeapAlloc(),
   2363          *                                                 Mem_PoolCreate().
   2364          *
   2365          *               size        Size of memory to allocate.
   2366          *               ----        Argument validated in Mem_HeapAlloc(),
   2367          *                                                 Mem_PoolCreate().
   2368          *
   2369          *               align       Required starting word-boundary memory alignment (in octets).
   2370          *               -----       Argument validated in Mem_HeapAlloc(),
   2371          *                                                 Mem_PoolCreate().
   2372          *
   2373          * Return(s)   : Pointer to allocated memory, if NO error(s).
   2374          *
   2375          *               Pointer to NULL,             otherwise.
   2376          *
   2377          * Caller(s)   : Mem_HeapAlloc(),
   2378          *               Mem_PoolCreate().
   2379          *
   2380          * Note(s)     : (1) Allocated memory from the specific segment is NEVER freed after allocation.
   2381          *
   2382          *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   2383          *
   2384          *                   (a) However, this function is already called within critical sections.
   2385          *********************************************************************************************************
   2386          */
   2387          
   2388          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   2389          static  void  *Mem_SegAlloc (MEM_POOL    *pmem_pool,
   2390                                       CPU_SIZE_T   size,
   2391                                       CPU_SIZE_T   align)
   2392          {
   \                     Mem_SegAlloc: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   2393              CPU_INT08U  *pmem_addr;
   2394              CPU_INT08U  *pmem_addr_next;
   2395              CPU_SIZE_T   mem_align;
   2396              CPU_SIZE_T   align_offset;
   2397              CPU_SIZE_T   size_tot;
   2398          
   2399          
   2400              pmem_addr = (CPU_INT08U *)pmem_pool->SegAddrNextAvail;
   \        0x8   0x6BE7             LDR      R7,[R4, #+60]
   2401          
   2402              mem_align = (CPU_SIZE_T)((CPU_ADDR)pmem_addr % align);          /* Calc mem align.                                  */
   \        0xA   0x0038             MOVS     R0,R7
   \        0xC   0x0031             MOVS     R1,R6
   \        0xE   0x....'....        BL       __aeabi_uidivmod
   2403          
   2404              if (mem_align != 0u) {
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD001             BEQ      ??Mem_SegAlloc_0
   2405                  align_offset = align - mem_align;
   \       0x16   0x1A70             SUBS     R0,R6,R1
   \       0x18   0xE000             B        ??Mem_SegAlloc_1
   2406              } else {
   2407                  align_offset = 0u;
   \                     ??Mem_SegAlloc_0: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   2408              }
   2409          
   2410              size_tot = align_offset + size;
   \                     ??Mem_SegAlloc_1: (+1)
   \       0x1C   0x1941             ADDS     R1,R0,R5
   2411              if (size_tot > pmem_pool->SegSizeRem) {                         /* If insufficient mem seg size rem, ...            */
   \       0x1E   0x6C62             LDR      R2,[R4, #+68]
   \       0x20   0x428A             CMP      R2,R1
   \       0x22   0xD201             BCS      ??Mem_SegAlloc_2
   2412                  return ((void *)0);                                         /* ... rtn NULL.                                    */
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xE00F             B        ??Mem_SegAlloc_3
   2413              }
   2414          
   2415          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2416              if ((size_tot < align_offset) ||                                /* If size ovf, ...                                 */
   2417                  (size_tot < size)) {
   \                     ??Mem_SegAlloc_2: (+1)
   \       0x28   0x4281             CMP      R1,R0
   \       0x2A   0xD301             BCC      ??Mem_SegAlloc_4
   \       0x2C   0x42A9             CMP      R1,R5
   \       0x2E   0xD201             BCS      ??Mem_SegAlloc_5
   2418                  return ((void *)0);                                         /* ... rtn NULL.                                    */
   \                     ??Mem_SegAlloc_4: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xE009             B        ??Mem_SegAlloc_3
   2419              }
   2420          #endif
   2421          
   2422              pmem_addr_next = pmem_addr + size_tot;
   \                     ??Mem_SegAlloc_5: (+1)
   \       0x34   0x187A             ADDS     R2,R7,R1
   2423          
   2424          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2425              if (pmem_addr_next < pmem_addr) {                               /* If addr ovf, ...                                 */
   \       0x36   0x42BA             CMP      R2,R7
   \       0x38   0xD201             BCS      ??Mem_SegAlloc_6
   2426                  return ((void *)0);                                         /* ... rtn NULL.                                    */
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xE004             B        ??Mem_SegAlloc_3
   2427              }
   2428          #endif
   2429          
   2430              pmem_addr += align_offset;                                      /* Align mem addr.                                  */
   \                     ??Mem_SegAlloc_6: (+1)
   \       0x3E   0x1838             ADDS     R0,R7,R0
   2431          
   2432              pmem_pool->SegAddrNextAvail  = (void     *)pmem_addr_next;      /* Adv next avail addr.                             */
   \       0x40   0x63E2             STR      R2,[R4, #+60]
   2433              pmem_pool->SegSizeRem       -= (CPU_SIZE_T)size_tot;            /* Adj rem mem seg size.                            */
   \       0x42   0x6C62             LDR      R2,[R4, #+68]
   \       0x44   0x1A51             SUBS     R1,R2,R1
   \       0x46   0x6461             STR      R1,[R4, #+68]
   2434          
   2435              return ((void *)pmem_addr);
   \                     ??Mem_SegAlloc_3: (+1)
   \       0x48   0xBDF0             POP      {R4-R7,PC}       ;; return
   2436          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \        0x0   0x....'....        DC32     Mem_PoolHeap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \        0x0   0x5041'4548        DC32     0x50414548

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \        0x0   0x....'....        DC32     Mem_Heap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_3:
   \        0x0   0x....'....        DC32     Mem_PoolTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x0000'2774        DC32     0x2774

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x0000'2775        DC32     0x2775

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x....'....        DC32     Mem_PoolHeap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \        0x0   0x0000'27E3        DC32     0x27e3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \        0x0   0x0000'27E2        DC32     0x27e2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \        0x0   0x0000'2710        DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \        0x0   0x0000'2711        DC32     0x2711

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \        0x0   0x4C4F'4F50        DC32     0x4c4f4f50

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \        0x0   0x5041'4548        DC32     0x50414548

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \        0x0   0x0000'2788        DC32     0x2788

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \        0x0   0x454E'4F4E        DC32     0x454e4f4e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x0000'27E3        DC32     0x27e3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x0000'27E2        DC32     0x27e2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x0000'2797        DC32     0x2797

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x0000'277F        DC32     0x277f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x0000'27D9        DC32     0x27d9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x0000'27D8        DC32     0x27d8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x4C4F'4F50        DC32     0x4c4f4f50

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x0000'2710        DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x0000'2711        DC32     0x2711

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x0000'2788        DC32     0x2788

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \        0x0   0x0000'2793        DC32     0x2793

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \        0x0   0x0000'27DE        DC32     0x27de

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \        0x0   0x0000'2795        DC32     0x2795

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x0000'2710        DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x0000'27DD        DC32     0x27dd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0x4C4F'4F50        DC32     0x4c4f4f50

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \        0x0   0x0000'2797        DC32     0x2797

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \        0x0   0x0000'2798        DC32     0x2798

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \        0x0   0x0000'2711        DC32     0x2711

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \        0x0   0x0000'2788        DC32     0x2788
   2437          #endif
   2438          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Mem_Clr
         8   -> Mem_Set
      20   Mem_Cmp
      12   Mem_Copy
      40   Mem_HeapAlloc
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> CPU_SW_Exception
        40   -> Mem_SegAlloc
        40   -> Mem_SegCalcTotSize
       8   Mem_HeapGetSizeRem
         8   -> Mem_SegGetSizeRem
       0   Mem_Init
      16   Mem_Move
        16   -> Mem_Copy
      24   Mem_PoolBlkFree
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> CPU_SW_Exception
        24   -> Mem_PoolBlkIsValidAddr
      24   Mem_PoolBlkGet
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> CPU_SW_Exception
      16   Mem_PoolBlkGetNbrAvail
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> CPU_SW_Exception
      16   Mem_PoolBlkGetUsedAtIx
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> CPU_SW_Exception
      24   Mem_PoolBlkIsValidAddr
        24 __aeabi_uidivmod
      24   Mem_PoolBlkIxGet
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> CPU_SW_Exception
        24   -> Mem_PoolBlkIsValidAddr
      16   Mem_PoolClr
        16   -> CPU_SW_Exception
      72   Mem_PoolCreate
        72   -> CPU_SR_Restore
        72   -> CPU_SR_Save
        72   -> CPU_SW_Exception
        72   -> Mem_PoolClr
        72   -> Mem_SegAlloc
        72   -> Mem_SegCalcTotSize
      20   Mem_SegAlloc
        20 __aeabi_uidivmod
      20   Mem_SegCalcTotSize
        20 __aeabi_uidivmod
      24   Mem_SegGetSizeRem
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> CPU_SW_Exception
        24 __aeabi_uidivmod
      12   Mem_Set


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       4  ??DataTable0_3
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       4  ??DataTable5
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable8
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
      12  Mem_Clr
     176  Mem_Cmp
     110  Mem_Copy
   1'024  Mem_Heap
     198  Mem_HeapAlloc
      14  Mem_HeapGetSizeRem
      52  Mem_Init
     148  Mem_Move
     240  Mem_PoolBlkFree
     152  Mem_PoolBlkGet
      66  Mem_PoolBlkGetNbrAvail
     136  Mem_PoolBlkGetUsedAtIx
      92  Mem_PoolBlkIsValidAddr
     242  Mem_PoolBlkIxGet
      70  Mem_PoolClr
     968  Mem_PoolCreate
      72  Mem_PoolHeap
       4  Mem_PoolTbl
      74  Mem_SegAlloc
     136  Mem_SegCalcTotSize
     126  Mem_SegGetSizeRem
      84  Mem_Set

 
 1'100 bytes in section .bss
 3'236 bytes in section .text
 
 3'236 bytes of CODE memory
 1'100 bytes of DATA memory

Errors: none
Warnings: none
