###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.4.261/W32 for ARM         10/Jan/2021  16:10:13
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Source\APP\ADXL345.c
#    Command line                 =
#        -f C:\Users\macanlin\AppData\Local\Temp\EWCDCC.tmp
#        ("C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Source\APP\ADXL345.c" -D USE_STDPERIPH_DRIVER -D STM32F072 -lC
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\List" -o
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        C:\rj\IAR\arm\inc\c\DLib_Config_Normal.h -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\BSP\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\FWLib\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\CMSIS\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\OS_Cfg\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-CPU\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-LIB\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uCOS-III\Ports\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uCOS-III\Source\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\APP\inc\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\FWLib\\" -I
#        "C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\..\Source\System\uC-LIB\\" -Ol -I
#        C:\rj\IAR\arm\CMSIS\Core\Include\\ -I
#        C:\rj\IAR\arm\CMSIS\DSP\Include\\)
#    Locale                       =  C
#    List file                    =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\List\ADXL345.lst
#    Object file                  =
#        C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345
#        -1-9\Project\Debug\Obj\ADXL345.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

C:\Users\macanlin\Desktop\GD_modbus\Weight_F3_CarV1.1.5_ADXL345 -1-9\Source\APP\ADXL345.c
      1          /**@file        ADXL345.c
      2          * @brief        读写ADXL345驱动程序
      3          * @details      ADXL345读取或写入寄存器数据
      4          * @author      马灿林
      5          * @date         2020-12-26
      6          * @version      V1.0.0
      7          * @copyright    2020-2030,深圳市信为科技发展有限公司
      8          **********************************************************************************
      9          * @par 修改日志:
     10          * <table>
     11          * <tr><th>Date        <th>Version  <th>Author    <th>Description
     12          * <tr><td>2020/12/26  <td>1.0.0    <td>马灿林    <td>创建初始版本
     13          * </table>
     14          *
     15          **********************************************************************************
     16          */
     17          #include "ADXL345.h"
     18          

   \                                 In section .bss, align 4
     19          unsigned char	ADXL345_BUF[12];                         //接收数据缓存区   
   \                     ADXL345_BUF:
   \        0x0                      DS8 12
     20          
     21          //设置数据线的输入输出模式

   \                                 In section .text, align 2, keep-with-next
     22          void iic_sda_mode(GPIOMode_TypeDef mode)
     23          {
   \                     iic_sda_mode: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
     24          	GPIO_InitTypeDef GPIO_InitStruct;
     25          	
     26          	GPIO_InitStruct.GPIO_Mode = mode;
   \        0x2   0x4669             MOV      R1,SP
   \        0x4   0x7108             STRB     R0,[R1, #+4]
     27          	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;//速度
   \        0x6   0x2003             MOVS     R0,#+3
   \        0x8   0x7148             STRB     R0,[R1, #+5]
     28          	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_8;//PB8
   \        0xA   0x2080             MOVS     R0,#+128
   \        0xC   0x0040             LSLS     R0,R0,#+1        ;; #+256
   \        0xE   0x9000             STR      R0,[SP, #+0]
     29          	GPIO_Init(GPIOB,&GPIO_InitStruct);
   \       0x10   0x4669             MOV      R1,SP
   \       0x12   0x....             LDR      R0,??DataTable8  ;; 0x48000400
   \       0x14   0x....'....        BL       GPIO_Init
     30          }
   \       0x18   0xBD07             POP      {R0-R2,PC}       ;; return
     31          
     32          //初始化IIC

   \                                 In section .text, align 2, keep-with-next
     33          void ADXL345_IIC_Init(void)
     34          {
   \                     ADXL345_IIC_Init: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
     35              GPIO_InitTypeDef GPIO_InitStructure;
     36              //RCC->APB2ENR|=1<<4;
     37            RCC_APB2PeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x2080             MOVS     R0,#+128
   \        0x6   0x02C0             LSLS     R0,R0,#+11       ;; #+262144
   \        0x8   0x....'....        BL       RCC_APB2PeriphClockCmd
     38              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9;
   \        0xC   0x20C0             MOVS     R0,#+192
   \        0xE   0x0080             LSLS     R0,R0,#+2        ;; #+768
   \       0x10   0x9000             STR      R0,[SP, #+0]
     39              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   \       0x12   0x4668             MOV      R0,SP
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0x7101             STRB     R1,[R0, #+4]
     40              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0x18   0x2103             MOVS     R1,#+3
   \       0x1A   0x7141             STRB     R1,[R0, #+5]
     41              GPIO_Init(GPIOB, &GPIO_InitStructure);
   \       0x1C   0x....             LDR      R4,??DataTable8  ;; 0x48000400
   \       0x1E   0x4669             MOV      R1,SP
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x....'....        BL       GPIO_Init
     42              Set_SCL;
   \       0x26   0x2180             MOVS     R1,#+128
   \       0x28   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0x....'....        BL       GPIO_SetBits
     43              Set_SDA;
   \       0x30   0x2180             MOVS     R1,#+128
   \       0x32   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x....'....        BL       GPIO_SetBits
     44          }
   \       0x3A   0xBD13             POP      {R0,R1,R4,PC}    ;; return
     45          
     46          

   \                                 In section .text, align 2, keep-with-next
     47          void Delay5us()
     48          {
   \                     Delay5us: (+1)
   \        0x0   0xB500             PUSH     {LR}
     49               uint8_t cnt = 5 * 8;
   \        0x2   0x2028             MOVS     R0,#+40
     50              //cnt = cnt * 2;
     51              while (cnt--);
   \                     ??Delay5us_0: (+1)
   \        0x4   0x0001             MOVS     R1,R0
   \        0x6   0x1E48             SUBS     R0,R1,#+1
   \        0x8   0xB2C9             UXTB     R1,R1
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD1FA             BNE      ??Delay5us_0
     52          }
   \        0xE   0xBD00             POP      {PC}             ;; return
     53          
     54          

   \                                 In section .text, align 2, keep-with-next
     55          void Delay5ms()
     56          {
   \                     Delay5ms: (+1)
   \        0x0   0xB500             PUSH     {LR}
     57          	uint32_t cnt = 5* 7500;
   \        0x2   0x....             LDR      R0,??DataTable8_1  ;; 0x927c
     58              //cnt = cnt * 650;
     59          
     60              while (cnt--);
   \                     ??Delay5ms_0: (+1)
   \        0x4   0x0001             MOVS     R1,R0
   \        0x6   0x1E48             SUBS     R0,R1,#+1
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xD1FB             BNE      ??Delay5ms_0
     61          }
   \        0xC   0xBD00             POP      {PC}             ;; return
     62          
     63          //起始信号

   \                                 In section .text, align 2, keep-with-next
     64          void iic_start(void)
     65          {
   \                     iic_start: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
     66          	//数据线设置为输出
     67          	iic_sda_mode(GPIO_Mode_OUT);
   \        0x2   0x2001             MOVS     R0,#+1
   \        0x4   0x....'....        BL       iic_sda_mode
     68          	
     69          	//总线空闲
     70          	Set_SCL;
   \        0x8   0x....             LDR      R5,??DataTable8  ;; 0x48000400
   \        0xA   0x2680             MOVS     R6,#+128
   \        0xC   0x00B6             LSLS     R6,R6,#+2        ;; #+512
   \        0xE   0x0031             MOVS     R1,R6
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0x....'....        BL       GPIO_SetBits
     71          	//SCL = 1;
     72          	Set_SDA;
   \       0x16   0x2480             MOVS     R4,#+128
   \       0x18   0x0064             LSLS     R4,R4,#+1        ;; #+256
   \       0x1A   0x0021             MOVS     R1,R4
   \       0x1C   0x0028             MOVS     R0,R5
   \       0x1E   0x....'....        BL       GPIO_SetBits
     73          	//SDA_OUT = 1;
     74          	Delay5us();
   \       0x22   0x....'....        BL       Delay5us
     75          	
     76          	//拉低数据线
     77          	Reset_SDA;
   \       0x26   0x0021             MOVS     R1,R4
   \       0x28   0x0028             MOVS     R0,R5
   \       0x2A   0x....'....        BL       GPIO_ResetBits
     78          	//SDA_OUT = 0;
     79          	Delay5us();
   \       0x2E   0x....'....        BL       Delay5us
     80          	
     81          	//SCL拉低钳住总线
     82          	Reset_SCL;
   \       0x32   0x0031             MOVS     R1,R6
   \       0x34   0x0028             MOVS     R0,R5
   \       0x36   0x....'....        BL       GPIO_ResetBits
     83          	//SCL = 0;
     84          }
   \       0x3A   0xBD70             POP      {R4-R6,PC}       ;; return
     85          
     86          //停止信号

   \                                 In section .text, align 2, keep-with-next
     87          void iic_stop(void)
     88          {
   \                     iic_stop: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
     89          	//数据线设置为输出
     90          	iic_sda_mode(GPIO_Mode_OUT);
   \        0x2   0x2001             MOVS     R0,#+1
   \        0x4   0x....'....        BL       iic_sda_mode
     91          	
     92          	//SCL拉低钳住总线
     93          	Reset_SCL;
   \        0x8   0x....             LDR      R4,??DataTable8  ;; 0x48000400
   \        0xA   0x2680             MOVS     R6,#+128
   \        0xC   0x00B6             LSLS     R6,R6,#+2        ;; #+512
   \        0xE   0x0031             MOVS     R1,R6
   \       0x10   0x0020             MOVS     R0,R4
   \       0x12   0x....'....        BL       GPIO_ResetBits
     94          	//SCL = 0;
     95          	Reset_SDA;
   \       0x16   0x2580             MOVS     R5,#+128
   \       0x18   0x006D             LSLS     R5,R5,#+1        ;; #+256
   \       0x1A   0x0029             MOVS     R1,R5
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x....'....        BL       GPIO_ResetBits
     96          	//SDA_OUT = 0;
     97          	Delay5us();
   \       0x22   0x....'....        BL       Delay5us
     98          	
     99          	//拉高时钟线
    100          	Set_SCL;
   \       0x26   0x0031             MOVS     R1,R6
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0x....'....        BL       GPIO_SetBits
    101          	//SCL = 1;
    102          	Delay5us();
   \       0x2E   0x....'....        BL       Delay5us
    103          	
    104          	//数据线由低向高跳变
    105          	Set_SDA;
   \       0x32   0x0029             MOVS     R1,R5
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x....'....        BL       GPIO_SetBits
    106          	//SDA_OUT = 1;
    107          }
   \       0x3A   0xBD70             POP      {R4-R6,PC}       ;; return
    108          
    109          //等待ACK 1-无效 0-有效

   \                                 In section .text, align 2, keep-with-next
    110          u8 iic_wait_ack(void)
    111          {
   \                     iic_wait_ack: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    112          	u8 ack = 0;
   \        0x2   0x2500             MOVS     R5,#+0
   \        0x4   0x0028             MOVS     R0,R5
    113          	
    114          	//数据线设置为输入
    115          	iic_sda_mode(GPIO_Mode_IN);
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x....'....        BL       iic_sda_mode
    116          	
    117          	//拉高时钟线,让从设备可以控制数据线
    118          	Set_SCL;
   \        0xC   0x....             LDR      R4,??DataTable8  ;; 0x48000400
   \        0xE   0x2680             MOVS     R6,#+128
   \       0x10   0x00B6             LSLS     R6,R6,#+2        ;; #+512
   \       0x12   0x0031             MOVS     R1,R6
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0x....'....        BL       GPIO_SetBits
    119          	//SCL = 1;
    120          	Delay5us();
   \       0x1A   0x....'....        BL       Delay5us
    121          	
    122          	//获取数据线的电平
    123          	if(DataBit_SDA){//无效应答
   \       0x1E   0x2180             MOVS     R1,#+128
   \       0x20   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x....'....        BL       GPIO_ReadInputDataBit
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD003             BEQ      ??iic_wait_ack_0
    124          		ack = 1;
   \       0x2C   0x2501             MOVS     R5,#+1
    125          		iic_stop();
   \       0x2E   0x....'....        BL       iic_stop
   \       0x32   0xE7FF             B        ??iic_wait_ack_1
    126          	}
    127          	else{
    128          		ack = 0;
    129          	}
    130          	
    131          	//SCL拉低钳住总线
    132          	Reset_SCL;
   \                     ??iic_wait_ack_0: (+1)
   \                     ??iic_wait_ack_1: (+1)
   \       0x34   0x0031             MOVS     R1,R6
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0x....'....        BL       GPIO_ResetBits
    133          	//SCL = 0;
    134          	Delay5us();
   \       0x3C   0x....'....        BL       Delay5us
    135          	
    136          	return ack;
   \       0x40   0x0028             MOVS     R0,R5
   \       0x42   0xB2C0             UXTB     R0,R0
   \       0x44   0xBD70             POP      {R4-R6,PC}       ;; return
    137          }
    138          
    139          //产生有效/无效应答 1-无效 0-有效

   \                                 In section .text, align 2, keep-with-next
    140          void iic_ack(u8 ack)
    141          {
   \                     iic_ack: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    142          	//数据线设置为输出
    143          	iic_sda_mode(GPIO_Mode_OUT);
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x....'....        BL       iic_sda_mode
    144          	Reset_SCL;
   \        0xA   0x....             LDR      R5,??DataTable8  ;; 0x48000400
   \        0xC   0x2680             MOVS     R6,#+128
   \        0xE   0x00B6             LSLS     R6,R6,#+2        ;; #+512
   \       0x10   0x0031             MOVS     R1,R6
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0x....'....        BL       GPIO_ResetBits
    145          	//SCL = 0;
    146          	Delay5us();
   \       0x18   0x....'....        BL       Delay5us
    147          	
    148          	//发送ACK/NACK
    149          	if(ack)
   \       0x1C   0xB2E4             UXTB     R4,R4
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD005             BEQ      ??iic_ack_0
    150          		Set_SDA;
   \       0x22   0x2180             MOVS     R1,#+128
   \       0x24   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \       0x26   0x0028             MOVS     R0,R5
   \       0x28   0x....'....        BL       GPIO_SetBits
   \       0x2C   0xE004             B        ??iic_ack_1
    151          		//SDA_OUT = 1;//无效应答
    152          	else
    153          		Reset_SDA;
   \                     ??iic_ack_0: (+1)
   \       0x2E   0x2180             MOVS     R1,#+128
   \       0x30   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \       0x32   0x0028             MOVS     R0,R5
   \       0x34   0x....'....        BL       GPIO_ResetBits
    154          		//SDA_OUT = 0;//有效应答
    155          	
    156          	Delay5us();
   \                     ??iic_ack_1: (+1)
   \       0x38   0x....'....        BL       Delay5us
    157          	Set_SCL;
   \       0x3C   0x0031             MOVS     R1,R6
   \       0x3E   0x0028             MOVS     R0,R5
   \       0x40   0x....'....        BL       GPIO_SetBits
    158          	//SCL = 1;
    159          	//保持数据稳定
    160          	Delay5us();
   \       0x44   0x....'....        BL       Delay5us
    161          	//SCL拉低钳住总线
    162          	Set_SCL;
   \       0x48   0x0031             MOVS     R1,R6
   \       0x4A   0x0028             MOVS     R0,R5
   \       0x4C   0x....'....        BL       GPIO_SetBits
    163          	//SCL = 0;
    164          }
   \       0x50   0xBD70             POP      {R4-R6,PC}       ;; return
    165          
    166          //发送一个字节

   \                                 In section .text, align 2, keep-with-next
    167          void iic_send_byte(u8 txd)
    168          {
   \                     iic_send_byte: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0007             MOVS     R7,R0
    169          	u8 i;
    170          	//数据线设置为输出
    171          	iic_sda_mode(GPIO_Mode_OUT);
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x....'....        BL       iic_sda_mode
    172          	
    173          	Reset_SCL;
   \        0xA   0x....             LDR      R4,??DataTable8  ;; 0x48000400
   \        0xC   0x2680             MOVS     R6,#+128
   \        0xE   0x00B6             LSLS     R6,R6,#+2        ;; #+512
   \       0x10   0x0031             MOVS     R1,R6
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0x....'....        BL       GPIO_ResetBits
    174          	//SCL = 0;
    175          	Delay5us();
   \       0x18   0x....'....        BL       Delay5us
    176          	
    177          	for(i=0;i<8;i++){
   \       0x1C   0x2500             MOVS     R5,#+0
   \       0x1E   0xE021             B        ??iic_send_byte_0
    178          		if(txd&1<<(7-i))
    179          			Set_SDA;
    180          		//SDA_OUT = 1;
    181          		else
    182          			Reset_SDA;
   \                     ??iic_send_byte_1: (+1)
   \       0x20   0x2180             MOVS     R1,#+128
   \       0x22   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x....'....        BL       GPIO_ResetBits
   \       0x2A   0xE00C             B        ??iic_send_byte_2
   \                     ??iic_send_byte_3: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0x2107             MOVS     R1,#+7
   \       0x30   0x1B49             SUBS     R1,R1,R5
   \       0x32   0x4088             LSLS     R0,R0,R1
   \       0x34   0x0039             MOVS     R1,R7
   \       0x36   0xB2C9             UXTB     R1,R1
   \       0x38   0x4201             TST      R1,R0
   \       0x3A   0xD0F1             BEQ      ??iic_send_byte_1
   \       0x3C   0x2180             MOVS     R1,#+128
   \       0x3E   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \       0x40   0x0020             MOVS     R0,R4
   \       0x42   0x....'....        BL       GPIO_SetBits
    183          			//SDA_OUT = 0;
    184          		
    185          		Delay5us();
   \                     ??iic_send_byte_2: (+1)
   \       0x46   0x....'....        BL       Delay5us
    186          		//拉高时钟线
    187          		Set_SCL;
   \       0x4A   0x0031             MOVS     R1,R6
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0x....'....        BL       GPIO_SetBits
    188          		//SCL = 1;
    189          		Delay5us();
   \       0x52   0x....'....        BL       Delay5us
    190          		
    191          		Reset_SCL;
   \       0x56   0x0031             MOVS     R1,R6
   \       0x58   0x0020             MOVS     R0,R4
   \       0x5A   0x....'....        BL       GPIO_ResetBits
    192          		//SCL = 0;
    193          		Delay5us();
   \       0x5E   0x....'....        BL       Delay5us
    194          	}
   \       0x62   0x1C6D             ADDS     R5,R5,#+1
   \                     ??iic_send_byte_0: (+1)
   \       0x64   0x0028             MOVS     R0,R5
   \       0x66   0xB2C0             UXTB     R0,R0
   \       0x68   0x2808             CMP      R0,#+8
   \       0x6A   0xDBDF             BLT      ??iic_send_byte_3
    195          	iic_wait_ack();
   \                     ??iic_send_byte_4: (+1)
   \       0x6C   0x....'....        BL       iic_wait_ack
    196          }
   \       0x70   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    197          
    198          //接收一个字节

   \                                 In section .text, align 2, keep-with-next
    199          u8 iic_read_byte(void)
    200          {
   \                     iic_read_byte: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    201          	 u8 i;
    202              u8 dat = 0;
   \        0x2   0x2500             MOVS     R5,#+0
   \        0x4   0x002C             MOVS     R4,R5
    203          	iic_sda_mode(GPIO_Mode_IN);
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x....'....        BL       iic_sda_mode
    204              Set_SDA;                  //使能内部上拉,准备读取数据,
   \        0xC   0x....             LDR      R7,??DataTable8  ;; 0x48000400
   \        0xE   0x2180             MOVS     R1,#+128
   \       0x10   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \       0x12   0x0038             MOVS     R0,R7
   \       0x14   0x....'....        BL       GPIO_SetBits
    205              for (i=0; i<8; i++)         //8位计数器
   \       0x18   0xE016             B        ??iic_read_byte_0
    206              {
    207                  dat <<= 1;
   \                     ??iic_read_byte_1: (+1)
   \       0x1A   0x0064             LSLS     R4,R4,#+1
    208                  Set_SCL ;              //拉高时钟线
   \       0x1C   0x2680             MOVS     R6,#+128
   \       0x1E   0x00B6             LSLS     R6,R6,#+2        ;; #+512
   \       0x20   0x0031             MOVS     R1,R6
   \       0x22   0x0038             MOVS     R0,R7
   \       0x24   0x....'....        BL       GPIO_SetBits
    209                  Delay5us();             //延时
   \       0x28   0x....'....        BL       Delay5us
    210                  dat |= DataBit_SDA;             //读数据               
   \       0x2C   0x2180             MOVS     R1,#+128
   \       0x2E   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \       0x30   0x0038             MOVS     R0,R7
   \       0x32   0x....'....        BL       GPIO_ReadInputDataBit
   \       0x36   0x4320             ORRS     R0,R0,R4
   \       0x38   0x0004             MOVS     R4,R0
    211                 Reset_SCL;                //拉低时钟线
   \       0x3A   0x0031             MOVS     R1,R6
   \       0x3C   0x0038             MOVS     R0,R7
   \       0x3E   0x....'....        BL       GPIO_ResetBits
    212                  Delay5us();             //延时
   \       0x42   0x....'....        BL       Delay5us
    213              }
   \       0x46   0x1C6D             ADDS     R5,R5,#+1
   \                     ??iic_read_byte_0: (+1)
   \       0x48   0x0028             MOVS     R0,R5
   \       0x4A   0xB2C0             UXTB     R0,R0
   \       0x4C   0x2808             CMP      R0,#+8
   \       0x4E   0xDBE4             BLT      ??iic_read_byte_1
    214              return dat;
   \       0x50   0x0020             MOVS     R0,R4
   \       0x52   0xB2C0             UXTB     R0,R0
   \       0x54   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    215          
    216          }
    217          
    218          //******单字节写入*******************************************
    219          

   \                                 In section .text, align 2, keep-with-next
    220          void Single_Write_ADXL345(uint8_t REG_Address,uint8_t REG_data)
    221          {
   \                     Single_Write_ADXL345: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    222              iic_start();                  //起始信号
   \        0x6   0x....'....        BL       iic_start
    223              iic_send_byte(SlaveAddress);   //发送设备地址+写信号
   \        0xA   0x20A6             MOVS     R0,#+166
   \        0xC   0x....'....        BL       iic_send_byte
    224              iic_send_byte(REG_Address);    //内部寄存器地址，请参考中文pdf22页 
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0xB2C0             UXTB     R0,R0
   \       0x14   0x....'....        BL       iic_send_byte
    225              iic_send_byte(REG_data);       //内部寄存器数据，请参考中文pdf22页 
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0x....'....        BL       iic_send_byte
    226              iic_stop();                   //发送停止信号
   \       0x20   0x....'....        BL       iic_stop
    227          }
   \       0x24   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    228          
    229          //********单字节读取*****************************************

   \                                 In section .text, align 2, keep-with-next
    230          uint8_t Single_Read_ADXL345(uint8_t REG_Address)
    231          {  
   \                     Single_Read_ADXL345: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    232          	uint8_t REG_data;
    233              iic_start();                           		//起始信号
   \        0x4   0x....'....        BL       iic_start
    234              iic_send_byte(SlaveAddress);           //发送设备地址+写信号
   \        0x8   0x20A6             MOVS     R0,#+166
   \        0xA   0x....'....        BL       iic_send_byte
    235              iic_send_byte(REG_Address);            //发送存储单元地址，从0开始	
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0x....'....        BL       iic_send_byte
    236              iic_start();                        	  //起始信号
   \       0x16   0x....'....        BL       iic_start
    237              iic_send_byte(SlaveAddress+1);         //发送设备地址+读信号
   \       0x1A   0x20A7             MOVS     R0,#+167
   \       0x1C   0x....'....        BL       iic_send_byte
    238              REG_data=iic_read_byte();              //读出寄存器数据
   \       0x20   0x....'....        BL       iic_read_byte
   \       0x24   0x0004             MOVS     R4,R0
    239          	iic_ack(1);   
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0x....'....        BL       iic_ack
    240          	iic_stop();                           //停止信号
   \       0x2C   0x....'....        BL       iic_stop
    241              return REG_data; 
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0xB2C0             UXTB     R0,R0
   \       0x34   0xBD10             POP      {R4,PC}          ;; return
    242          }
    243          
    244          /**@brief    得到角度
    245          //x,y,z:x,y,z方向的重力加速度分量(不需要单位,直接数值即可)
    246          //dir:要获得的角度.0,与Z轴的角度;1,与X轴的角度;2,与Y轴的角度.
    247          //返回值:角度值.单位1°.
    248          */
    249          

   \                                 In section .text, align 2, keep-with-next
    250          void ADXL345_Get_Angle(u8 *buf)
    251          {
   \                     ADXL345_Get_Angle: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    252              float temp;
    253              float res=0;
   \        0x4   0x2000             MOVS     R0,#+0
    254              static short x,y,z;
    255              static short x1,y1,z1;
    256            //  x=(short)((buf[1]<<8)+buf[0]); 	    
    257             // y=(short)((buf[3]<<8)+buf[2]); 	    
    258            //  z=(short)((buf[5]<<8)+buf[4]); 
    259              x=(short)(((u16)buf[1]<<8)+buf[0]); 	    
   \        0x6   0x7860             LDRB     R0,[R4, #+1]
   \        0x8   0x0200             LSLS     R0,R0,#+8
   \        0xA   0x7821             LDRB     R1,[R4, #+0]
   \        0xC   0x1840             ADDS     R0,R0,R1
   \        0xE   0x....             LDR      R1,??DataTable11
   \       0x10   0x8008             STRH     R0,[R1, #+0]
    260              y=(short)(((u16)buf[3]<<8)+buf[2]); 	    
   \       0x12   0x78E0             LDRB     R0,[R4, #+3]
   \       0x14   0x0200             LSLS     R0,R0,#+8
   \       0x16   0x78A1             LDRB     R1,[R4, #+2]
   \       0x18   0x1840             ADDS     R0,R0,R1
   \       0x1A   0x....             LDR      R1,??DataTable11_1
   \       0x1C   0x8008             STRH     R0,[R1, #+0]
    261              z=(short)(((u16)buf[5]<<8)+buf[4]); 
   \       0x1E   0x....             LDR      R5,??DataTable11_2
   \       0x20   0x7960             LDRB     R0,[R4, #+5]
   \       0x22   0x0200             LSLS     R0,R0,#+8
   \       0x24   0x7921             LDRB     R1,[R4, #+4]
   \       0x26   0x1840             ADDS     R0,R0,R1
   \       0x28   0x8028             STRH     R0,[R5, #+0]
    262          	
    263              //与自然Z轴的角度
    264              temp=sqrt((x*x+y*y))/z;
   \       0x2A   0x....             LDR      R0,??DataTable11
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x5E40             LDRSH    R0,[R0, R1]
   \       0x30   0x....             LDR      R1,??DataTable11
   \       0x32   0x2200             MOVS     R2,#+0
   \       0x34   0x5E89             LDRSH    R1,[R1, R2]
   \       0x36   0x4348             MULS     R0,R1,R0
   \       0x38   0x....             LDR      R1,??DataTable11_1
   \       0x3A   0x2200             MOVS     R2,#+0
   \       0x3C   0x5E89             LDRSH    R1,[R1, R2]
   \       0x3E   0x....             LDR      R2,??DataTable11_1
   \       0x40   0x2300             MOVS     R3,#+0
   \       0x42   0x5ED2             LDRSH    R2,[R2, R3]
   \       0x44   0x4351             MULS     R1,R2,R1
   \       0x46   0x1840             ADDS     R0,R0,R1
   \       0x48   0x....'....        BL       __aeabi_i2d
   \       0x4C   0x....'....        BL       sqrt
   \       0x50   0x0006             MOVS     R6,R0
   \       0x52   0x000F             MOVS     R7,R1
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x5E28             LDRSH    R0,[R5, R0]
   \       0x58   0x....'....        BL       __aeabi_i2d
   \       0x5C   0x0002             MOVS     R2,R0
   \       0x5E   0x000B             MOVS     R3,R1
   \       0x60   0x0030             MOVS     R0,R6
   \       0x62   0x0039             MOVS     R1,R7
   \       0x64   0x....'....        BL       __aeabi_ddiv
   \       0x68   0x....'....        BL       __aeabi_d2f
    265              res=atan(temp);
   \       0x6C   0x....'....        BL       __aeabi_f2d
   \       0x70   0x....'....        BL       atan
   \       0x74   0x....'....        BL       __aeabi_d2f
   \       0x78   0x0001             MOVS     R1,R0
    266              z1 = res*180/3.14;
                        ^
Warning[Pa093]: implicit conversion from floating point to integer
   \       0x7A   0x....             LDR      R7,??DataTable11_3
   \       0x7C   0x....             LDR      R0,??DataTable11_4  ;; 0x43340000
   \       0x7E   0x....'....        BL       __aeabi_fmul
   \       0x82   0x....'....        BL       __aeabi_f2d
   \       0x86   0x....             ADR      R2,??DataTable11_7
   \       0x88   0xCA0C             LDM      R2,{R2,R3}
   \       0x8A   0x....'....        BL       __aeabi_ddiv
   \       0x8E   0x....'....        BL       __aeabi_d2iz
   \       0x92   0x8038             STRH     R0,[R7, #+0]
    267              
    268           			
    269              //与自然X轴的角度
    270              temp=x/sqrt((y*y+z*z));
   \       0x94   0x....             LDR      R0,??DataTable11
   \       0x96   0x2100             MOVS     R1,#+0
   \       0x98   0x5E40             LDRSH    R0,[R0, R1]
   \       0x9A   0x....'....        BL       __aeabi_i2d
   \       0x9E   0x9000             STR      R0,[SP, #+0]
   \       0xA0   0x9101             STR      R1,[SP, #+4]
   \       0xA2   0x....             LDR      R0,??DataTable11_1
   \       0xA4   0x2100             MOVS     R1,#+0
   \       0xA6   0x5E40             LDRSH    R0,[R0, R1]
   \       0xA8   0x....             LDR      R1,??DataTable11_1
   \       0xAA   0x2200             MOVS     R2,#+0
   \       0xAC   0x5E89             LDRSH    R1,[R1, R2]
   \       0xAE   0x4348             MULS     R0,R1,R0
   \       0xB0   0x2100             MOVS     R1,#+0
   \       0xB2   0x5E69             LDRSH    R1,[R5, R1]
   \       0xB4   0x2200             MOVS     R2,#+0
   \       0xB6   0x5EAA             LDRSH    R2,[R5, R2]
   \       0xB8   0x4351             MULS     R1,R2,R1
   \       0xBA   0x1840             ADDS     R0,R0,R1
   \       0xBC   0x....'....        BL       __aeabi_i2d
   \       0xC0   0x....'....        BL       sqrt
   \       0xC4   0x0002             MOVS     R2,R0
   \       0xC6   0x000B             MOVS     R3,R1
   \       0xC8   0x9800             LDR      R0,[SP, #+0]
   \       0xCA   0x9901             LDR      R1,[SP, #+4]
   \       0xCC   0x....'....        BL       __aeabi_ddiv
   \       0xD0   0x....'....        BL       __aeabi_d2f
    271              res=atan(temp);
   \       0xD4   0x....'....        BL       __aeabi_f2d
   \       0xD8   0x....'....        BL       atan
   \       0xDC   0x....'....        BL       __aeabi_d2f
    272              x1 = res*180/3.14;
                        ^
Warning[Pa093]: implicit conversion from floating point to integer
   \       0xE0   0x....             LDR      R6,??DataTable11_5
   \       0xE2   0x....             LDR      R1,??DataTable11_4  ;; 0x43340000
   \       0xE4   0x....'....        BL       __aeabi_fmul
   \       0xE8   0x....'....        BL       __aeabi_f2d
   \       0xEC   0x....             ADR      R2,??DataTable11_7
   \       0xEE   0xCA0C             LDM      R2,{R2,R3}
   \       0xF0   0x....'....        BL       __aeabi_ddiv
   \       0xF4   0x....'....        BL       __aeabi_d2iz
   \       0xF8   0x8030             STRH     R0,[R6, #+0]
    273           		
    274              //与自然Y轴的角度
    275              temp=y/sqrt((x*x+z*z));
   \       0xFA   0x....             LDR      R0,??DataTable11_1
   \       0xFC   0x2100             MOVS     R1,#+0
   \       0xFE   0x5E40             LDRSH    R0,[R0, R1]
   \      0x100   0x....'....        BL       __aeabi_i2d
   \      0x104   0x9000             STR      R0,[SP, #+0]
   \      0x106   0x9101             STR      R1,[SP, #+4]
   \      0x108   0x....             LDR      R0,??DataTable11
   \      0x10A   0x2100             MOVS     R1,#+0
   \      0x10C   0x5E42             LDRSH    R2,[R0, R1]
   \      0x10E   0x....             LDR      R0,??DataTable11
   \      0x110   0x2100             MOVS     R1,#+0
   \      0x112   0x5E40             LDRSH    R0,[R0, R1]
   \      0x114   0x4342             MULS     R2,R0,R2
   \      0x116   0x0010             MOVS     R0,R2
   \      0x118   0x2100             MOVS     R1,#+0
   \      0x11A   0x5E69             LDRSH    R1,[R5, R1]
   \      0x11C   0x2200             MOVS     R2,#+0
   \      0x11E   0x5EAA             LDRSH    R2,[R5, R2]
   \      0x120   0x4351             MULS     R1,R2,R1
   \      0x122   0x1840             ADDS     R0,R0,R1
   \      0x124   0x....'....        BL       __aeabi_i2d
   \      0x128   0x....'....        BL       sqrt
   \      0x12C   0x0002             MOVS     R2,R0
   \      0x12E   0x000B             MOVS     R3,R1
   \      0x130   0x9800             LDR      R0,[SP, #+0]
   \      0x132   0x9901             LDR      R1,[SP, #+4]
   \      0x134   0x....'....        BL       __aeabi_ddiv
   \      0x138   0x....'....        BL       __aeabi_d2f
    276              res=atan(temp);
   \      0x13C   0x....'....        BL       __aeabi_f2d
   \      0x140   0x....'....        BL       atan
   \      0x144   0x....'....        BL       __aeabi_d2f
    277              y1 = res*180/3.14;
                        ^
Warning[Pa093]: implicit conversion from floating point to integer
   \      0x148   0x....             LDR      R5,??DataTable11_6
   \      0x14A   0x....             LDR      R1,??DataTable11_4  ;; 0x43340000
   \      0x14C   0x....'....        BL       __aeabi_fmul
   \      0x150   0x....'....        BL       __aeabi_f2d
   \      0x154   0x....             ADR      R2,??DataTable11_7
   \      0x156   0xCA0C             LDM      R2,{R2,R3}
   \      0x158   0x....'....        BL       __aeabi_ddiv
   \      0x15C   0x....'....        BL       __aeabi_d2iz
   \      0x160   0x8028             STRH     R0,[R5, #+0]
    278            
    279              if(x1 <= 0)
   \      0x162   0x2000             MOVS     R0,#+0
   \      0x164   0x5E30             LDRSH    R0,[R6, R0]
   \      0x166   0x2801             CMP      R0,#+1
   \      0x168   0xDA08             BGE      ??ADXL345_Get_Angle_0
    280              {
    281                  x1 = -x1;
   \      0x16A   0x2000             MOVS     R0,#+0
   \      0x16C   0x5E30             LDRSH    R0,[R6, R0]
   \      0x16E   0x4241             RSBS     R1,R0,#+0
   \      0x170   0x8031             STRH     R1,[R6, #+0]
    282                  buf[6] = 0;
   \      0x172   0x2000             MOVS     R0,#+0
   \      0x174   0x71A0             STRB     R0,[R4, #+6]
    283                  buf[7] = x1;
   \      0x176   0x8830             LDRH     R0,[R6, #+0]
   \      0x178   0x71E0             STRB     R0,[R4, #+7]
   \      0x17A   0xE003             B        ??ADXL345_Get_Angle_1
    284              }
    285              else
    286              {
    287                  buf[6] = 1;
   \                     ??ADXL345_Get_Angle_0: (+1)
   \      0x17C   0x2001             MOVS     R0,#+1
   \      0x17E   0x71A0             STRB     R0,[R4, #+6]
    288                  buf[7] = x1;
   \      0x180   0x8830             LDRH     R0,[R6, #+0]
   \      0x182   0x71E0             STRB     R0,[R4, #+7]
    289              }
    290              
    291              if(y1 <= 0)
   \                     ??ADXL345_Get_Angle_1: (+1)
   \      0x184   0x2000             MOVS     R0,#+0
   \      0x186   0x5E28             LDRSH    R0,[R5, R0]
   \      0x188   0x2801             CMP      R0,#+1
   \      0x18A   0xDA08             BGE      ??ADXL345_Get_Angle_2
    292              {
    293                y1 = -y1;
   \      0x18C   0x2000             MOVS     R0,#+0
   \      0x18E   0x5E28             LDRSH    R0,[R5, R0]
   \      0x190   0x4241             RSBS     R1,R0,#+0
   \      0x192   0x8029             STRH     R1,[R5, #+0]
    294                buf[8] = 0;
   \      0x194   0x2000             MOVS     R0,#+0
   \      0x196   0x7220             STRB     R0,[R4, #+8]
    295                buf[9] = y1;
   \      0x198   0x8828             LDRH     R0,[R5, #+0]
   \      0x19A   0x7260             STRB     R0,[R4, #+9]
   \      0x19C   0xE003             B        ??ADXL345_Get_Angle_3
    296              }
    297              else
    298              {
    299                  buf[8] = 1; 
   \                     ??ADXL345_Get_Angle_2: (+1)
   \      0x19E   0x2001             MOVS     R0,#+1
   \      0x1A0   0x7220             STRB     R0,[R4, #+8]
    300                  buf[9] = y1;
   \      0x1A2   0x8828             LDRH     R0,[R5, #+0]
   \      0x1A4   0x7260             STRB     R0,[R4, #+9]
    301              }
    302              
    303              if(z1 <= 0)
   \                     ??ADXL345_Get_Angle_3: (+1)
   \      0x1A6   0x2000             MOVS     R0,#+0
   \      0x1A8   0x5E38             LDRSH    R0,[R7, R0]
   \      0x1AA   0x2801             CMP      R0,#+1
   \      0x1AC   0xDA08             BGE      ??ADXL345_Get_Angle_4
    304              {
    305                z1 = -z1;
   \      0x1AE   0x2000             MOVS     R0,#+0
   \      0x1B0   0x5E38             LDRSH    R0,[R7, R0]
   \      0x1B2   0x4241             RSBS     R1,R0,#+0
   \      0x1B4   0x8039             STRH     R1,[R7, #+0]
    306                buf[10] = 0;
   \      0x1B6   0x2000             MOVS     R0,#+0
   \      0x1B8   0x72A0             STRB     R0,[R4, #+10]
    307                buf[11] = z1;
   \      0x1BA   0x8838             LDRH     R0,[R7, #+0]
   \      0x1BC   0x72E0             STRB     R0,[R4, #+11]
   \      0x1BE   0xE003             B        ??ADXL345_Get_Angle_5
    308              }
    309              else
    310              {  
    311                 buf[10] = 1;
   \                     ??ADXL345_Get_Angle_4: (+1)
   \      0x1C0   0x2001             MOVS     R0,#+1
   \      0x1C2   0x72A0             STRB     R0,[R4, #+10]
    312                 buf[11] = z1;
   \      0x1C4   0x8838             LDRH     R0,[R7, #+0]
   \      0x1C6   0x72E0             STRB     R0,[R4, #+11]
    313              }
    314               		
    315          }
   \                     ??ADXL345_Get_Angle_5: (+1)
   \      0x1C8   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return

   \                                 In section .bss, align 2
   \                     `ADXL345_Get_Angle::x`:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
   \                     `ADXL345_Get_Angle::y`:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
   \                     `ADXL345_Get_Angle::z`:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
   \                     `ADXL345_Get_Angle::x1`:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
   \                     `ADXL345_Get_Angle::y1`:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
   \                     `ADXL345_Get_Angle::z1`:
   \        0x0                      DS8 2
    316          
    317          
    318          /**@brief       连续读出ADXL345内部加速度数据，地址范围0x32~0x37
    319          */

   \                                 In section .text, align 2, keep-with-next
    320          void Multiple_read_ADXL345(void)
    321          {   
   \                     Multiple_read_ADXL345: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    322          	uint8_t i;
    323              iic_start();                          //起始信号
   \        0x2   0x....'....        BL       iic_start
    324              iic_send_byte(SlaveAddress);           //发送设备地址+写信号
   \        0x6   0x20A6             MOVS     R0,#+166
   \        0x8   0x....'....        BL       iic_send_byte
    325              iic_send_byte(0x32);                   //发送存储单元地址，从0x32开始	
   \        0xC   0x2032             MOVS     R0,#+50
   \        0xE   0x....'....        BL       iic_send_byte
    326              iic_start();                          //起始信号
   \       0x12   0x....'....        BL       iic_start
    327              iic_send_byte(SlaveAddress+1);         //发送设备地址+读信号
   \       0x16   0x20A7             MOVS     R0,#+167
   \       0x18   0x....'....        BL       iic_send_byte
    328              for (i=0; i<6; i++)                      //连续读取6个地址数据，存储中BUF
   \       0x1C   0x2400             MOVS     R4,#+0
   \       0x1E   0xE011             B        ??Multiple_read_ADXL345_0
    329              {
    330                  ADXL345_BUF[i] = iic_read_byte();          //BUF[0]存储0x32地址中的数据
    331          		if (i == 5)
    332                  {
    333                     iic_ack(0);                //最后一个数据需要回NOACK
    334                  }
    335                  else
    336                  {
    337                    iic_ack(1);                //回应ACK
   \                     ??Multiple_read_ADXL345_1: (+1)
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0x....'....        BL       iic_ack
   \       0x26   0xE00C             B        ??Multiple_read_ADXL345_2
    338                 }
   \                     ??Multiple_read_ADXL345_3: (+1)
   \       0x28   0x....'....        BL       iic_read_byte
   \       0x2C   0x....             LDR      R1,??DataTable11_8
   \       0x2E   0x0022             MOVS     R2,R4
   \       0x30   0xB2D2             UXTB     R2,R2
   \       0x32   0x5488             STRB     R0,[R1, R2]
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0xB2C0             UXTB     R0,R0
   \       0x38   0x2805             CMP      R0,#+5
   \       0x3A   0xD1F1             BNE      ??Multiple_read_ADXL345_1
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0x....'....        BL       iic_ack
    339          		
    340             }
   \                     ??Multiple_read_ADXL345_2: (+1)
   \       0x42   0x1C64             ADDS     R4,R4,#+1
   \                     ??Multiple_read_ADXL345_0: (+1)
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0xB2C0             UXTB     R0,R0
   \       0x48   0x2806             CMP      R0,#+6
   \       0x4A   0xDBED             BLT      ??Multiple_read_ADXL345_3
    341              iic_stop();                          //停止信号
   \                     ??Multiple_read_ADXL345_4: (+1)
   \       0x4C   0x....'....        BL       iic_stop
    342              Delay5ms();
   \       0x50   0x....'....        BL       Delay5ms
    343          }
   \       0x54   0xBD10             POP      {R4,PC}          ;; return
    344          

   \                                 In section .text, align 2, keep-with-next
    345          void Multiple_read1_ADXL345(void)
    346          {
   \                     Multiple_read1_ADXL345: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    347              iic_start();                          //起始信号
   \        0x2   0x....'....        BL       iic_start
    348              iic_send_byte(SlaveAddress);           //发送设备地址+写信号
   \        0x6   0x20A6             MOVS     R0,#+166
   \        0x8   0x....'....        BL       iic_send_byte
    349              iic_send_byte(0x32);                   //发送存储单元地址，从0x32开始	
   \        0xC   0x2032             MOVS     R0,#+50
   \        0xE   0x....'....        BL       iic_send_byte
    350              iic_start();                          	//起始信号
   \       0x12   0x....'....        BL       iic_start
    351              iic_send_byte(SlaveAddress+1);         //发送设备地址+读信号
   \       0x16   0x20A7             MOVS     R0,#+167
   \       0x18   0x....'....        BL       iic_send_byte
    352          	ADXL345_BUF[0] = iic_read_byte();       //BUF[0]存储0x32地址中的数据
   \       0x1C   0x....             LDR      R4,??DataTable11_8
   \       0x1E   0x....'....        BL       iic_read_byte
   \       0x22   0x7020             STRB     R0,[R4, #+0]
    353          	iic_ack(1); 
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x....'....        BL       iic_ack
    354          	iic_stop();                          	//停止信号
   \       0x2A   0x....'....        BL       iic_stop
    355              Delay5us(); 
   \       0x2E   0x....'....        BL       Delay5us
    356          	iic_start();                          //起始信号
   \       0x32   0x....'....        BL       iic_start
    357              iic_send_byte(SlaveAddress);           //发送设备地址+写信号
   \       0x36   0x20A6             MOVS     R0,#+166
   \       0x38   0x....'....        BL       iic_send_byte
    358              iic_send_byte(0x33);                   //发送存储单元地址，从0x32开始	
   \       0x3C   0x2033             MOVS     R0,#+51
   \       0x3E   0x....'....        BL       iic_send_byte
    359              iic_start();                          	//起始信号
   \       0x42   0x....'....        BL       iic_start
    360              iic_send_byte(SlaveAddress+1);         //发送设备地址+读信号
   \       0x46   0x20A7             MOVS     R0,#+167
   \       0x48   0x....'....        BL       iic_send_byte
    361          	ADXL345_BUF[1] = iic_read_byte();       //BUF[0]存储0x32地址中的数据
   \       0x4C   0x....'....        BL       iic_read_byte
   \       0x50   0x7060             STRB     R0,[R4, #+1]
    362              //ADXL345_BUF[1] &= 0x01;
    363          	iic_ack(1); 
   \       0x52   0x2001             MOVS     R0,#+1
   \       0x54   0x....'....        BL       iic_ack
    364          	iic_stop();                          	//停止信号
   \       0x58   0x....'....        BL       iic_stop
    365              Delay5us();
   \       0x5C   0x....'....        BL       Delay5us
    366          	iic_start();                          //起始信号
   \       0x60   0x....'....        BL       iic_start
    367              iic_send_byte(SlaveAddress);           //发送设备地址+写信号
   \       0x64   0x20A6             MOVS     R0,#+166
   \       0x66   0x....'....        BL       iic_send_byte
    368              iic_send_byte(0x34);                   //发送存储单元地址，从0x32开始	
   \       0x6A   0x2034             MOVS     R0,#+52
   \       0x6C   0x....'....        BL       iic_send_byte
    369              iic_start();                          	//起始信号
   \       0x70   0x....'....        BL       iic_start
    370              iic_send_byte(SlaveAddress+1);         //发送设备地址+读信号
   \       0x74   0x20A7             MOVS     R0,#+167
   \       0x76   0x....'....        BL       iic_send_byte
    371          	ADXL345_BUF[2] = iic_read_byte();       //BUF[0]存储0x32地址中的数据
   \       0x7A   0x....'....        BL       iic_read_byte
   \       0x7E   0x70A0             STRB     R0,[R4, #+2]
    372          	iic_ack(1); 
   \       0x80   0x2001             MOVS     R0,#+1
   \       0x82   0x....'....        BL       iic_ack
    373          	iic_stop();                          	//停止信号
   \       0x86   0x....'....        BL       iic_stop
    374              Delay5us(); 
   \       0x8A   0x....'....        BL       Delay5us
    375          	iic_start();                          //起始信号
   \       0x8E   0x....'....        BL       iic_start
    376              iic_send_byte(SlaveAddress);           //发送设备地址+写信号
   \       0x92   0x20A6             MOVS     R0,#+166
   \       0x94   0x....'....        BL       iic_send_byte
    377              iic_send_byte(0x35);                   //发送存储单元地址，从0x32开始	
   \       0x98   0x2035             MOVS     R0,#+53
   \       0x9A   0x....'....        BL       iic_send_byte
    378              iic_start();                          	//起始信号
   \       0x9E   0x....'....        BL       iic_start
    379              iic_send_byte(SlaveAddress+1);         //发送设备地址+读信号
   \       0xA2   0x20A7             MOVS     R0,#+167
   \       0xA4   0x....'....        BL       iic_send_byte
    380          	ADXL345_BUF[3] = iic_read_byte();       //BUF[0]存储0x32地址中的数据
   \       0xA8   0x....'....        BL       iic_read_byte
   \       0xAC   0x70E0             STRB     R0,[R4, #+3]
    381            //  ADXL345_BUF[3] &= 0x01;
    382          	iic_ack(1); 
   \       0xAE   0x2001             MOVS     R0,#+1
   \       0xB0   0x....'....        BL       iic_ack
    383          	iic_stop();                          	//停止信号
   \       0xB4   0x....'....        BL       iic_stop
    384              Delay5us(); 
   \       0xB8   0x....'....        BL       Delay5us
    385          	iic_start();                          //起始信号
   \       0xBC   0x....'....        BL       iic_start
    386              iic_send_byte(SlaveAddress);           //发送设备地址+写信号
   \       0xC0   0x20A6             MOVS     R0,#+166
   \       0xC2   0x....'....        BL       iic_send_byte
    387              iic_send_byte(0x36);                   //发送存储单元地址，从0x32开始	
   \       0xC6   0x2036             MOVS     R0,#+54
   \       0xC8   0x....'....        BL       iic_send_byte
    388              iic_start();                          	//起始信号
   \       0xCC   0x....'....        BL       iic_start
    389              iic_send_byte(SlaveAddress+1);         //发送设备地址+读信号
   \       0xD0   0x20A7             MOVS     R0,#+167
   \       0xD2   0x....'....        BL       iic_send_byte
    390          	ADXL345_BUF[4] = iic_read_byte();       //BUF[0]存储0x32地址中的数据
   \       0xD6   0x....'....        BL       iic_read_byte
   \       0xDA   0x7120             STRB     R0,[R4, #+4]
    391          	iic_ack(1); 
   \       0xDC   0x2001             MOVS     R0,#+1
   \       0xDE   0x....'....        BL       iic_ack
    392          	iic_stop();                          	//停止信号
   \       0xE2   0x....'....        BL       iic_stop
    393              Delay5us(); 
   \       0xE6   0x....'....        BL       Delay5us
    394          	iic_start();                          //起始信号
   \       0xEA   0x....'....        BL       iic_start
    395              iic_send_byte(SlaveAddress);           //发送设备地址+写信号
   \       0xEE   0x20A6             MOVS     R0,#+166
   \       0xF0   0x....'....        BL       iic_send_byte
    396              iic_send_byte(0x37);                   //发送存储单元地址，从0x32开始	
   \       0xF4   0x2037             MOVS     R0,#+55
   \       0xF6   0x....'....        BL       iic_send_byte
    397              iic_start();                          	//起始信号
   \       0xFA   0x....'....        BL       iic_start
    398              iic_send_byte(SlaveAddress+1);         //发送设备地址+读信号
   \       0xFE   0x20A7             MOVS     R0,#+167
   \      0x100   0x....'....        BL       iic_send_byte
    399              ADXL345_BUF[5] = iic_read_byte();       //BUF[0]存储0x32地址中的数据
   \      0x104   0x....'....        BL       iic_read_byte
   \      0x108   0x7160             STRB     R0,[R4, #+5]
    400             //ADXL345_BUF[5] &= 0x01;
    401          	iic_ack(1); 
   \      0x10A   0x2001             MOVS     R0,#+1
   \      0x10C   0x....'....        BL       iic_ack
    402          	iic_stop();                          	//停止信号
   \      0x110   0x....'....        BL       iic_stop
    403                  
    404              ADXL345_Get_Angle(ADXL345_BUF);    
   \      0x114   0x0020             MOVS     R0,R4
   \      0x116   0x....'....        BL       ADXL345_Get_Angle
    405           	
    406          }
   \      0x11A   0xBD10             POP      {R4,PC}          ;; return
    407          
    408          /**@brief       ADXL345初始化
    409          */

   \                                 In section .text, align 2, keep-with-next
    410          void Init_ADXL345()
    411          {
   \                     Init_ADXL345: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    412            ADXL345_IIC_Init();
   \        0x2   0x....'....        BL       ADXL345_IIC_Init
    413          /*
    414             Single_Write_ADXL345(0x31,0x0B);   //测量范围,正负16g，13位模式
    415             Single_Write_ADXL345(0x2C,0x0A);   //速率设定为12.5 参考pdf13页
    416             Single_Write_ADXL345(0x2D,0x08);   //选择电源模式   参考pdf24页
    417             Single_Write_ADXL345(0x2E,0x80);   //使能 DATA_READY 中断
    418             Single_Write_ADXL345(0x1E,0x00);   //X 偏移量 根据测试传感器的状态写入pdf29页
    419             Single_Write_ADXL345(0x1F,0x00);   //Y 偏移量 根据测试传感器的状态写入pdf29页
    420             Single_Write_ADXL345(0x20,0x05);   //Z 偏移量 根据测试传感器的状态写入pdf29页*/
    421            Single_Write_ADXL345(0x31,0X2B); //低电平中断输出,13 位全分辨率,输出数据右对齐,16g量程
   \        0x6   0x212B             MOVS     R1,#+43
   \        0x8   0x2031             MOVS     R0,#+49
   \        0xA   0x....'....        BL       Single_Write_ADXL345
    422            Single_Write_ADXL345(0x2C,0x0A); //数据输出速度为100Hz
   \        0xE   0x210A             MOVS     R1,#+10
   \       0x10   0x202C             MOVS     R0,#+44
   \       0x12   0x....'....        BL       Single_Write_ADXL345
    423            Single_Write_ADXL345(0x2D,0x28); //链接使能,测量模式
   \       0x16   0x2128             MOVS     R1,#+40
   \       0x18   0x202D             MOVS     R0,#+45
   \       0x1A   0x....'....        BL       Single_Write_ADXL345
    424            Single_Write_ADXL345(0x2E,0x00); //不使用中断
   \       0x1E   0x2100             MOVS     R1,#+0
   \       0x20   0x202E             MOVS     R0,#+46
   \       0x22   0x....'....        BL       Single_Write_ADXL345
    425            Single_Write_ADXL345(0x1E,0x00);
   \       0x26   0x2100             MOVS     R1,#+0
   \       0x28   0x201E             MOVS     R0,#+30
   \       0x2A   0x....'....        BL       Single_Write_ADXL345
    426            Single_Write_ADXL345(0x1F,0x00);
   \       0x2E   0x2100             MOVS     R1,#+0
   \       0x30   0x201F             MOVS     R0,#+31
   \       0x32   0x....'....        BL       Single_Write_ADXL345
    427            Single_Write_ADXL345(0x20,0x00);
   \       0x36   0x2100             MOVS     R1,#+0
   \       0x38   0x2020             MOVS     R0,#+32
   \       0x3A   0x....'....        BL       Single_Write_ADXL345
    428            
    429          }
   \       0x3E   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x4800'0400        DC32     0x48000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x0000'927C        DC32     0x927c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x....'....        DC32     `ADXL345_Get_Angle::x`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x....'....        DC32     `ADXL345_Get_Angle::y`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \        0x0   0x....'....        DC32     `ADXL345_Get_Angle::z`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \        0x0   0x....'....        DC32     `ADXL345_Get_Angle::z1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \        0x0   0x4334'0000        DC32     0x43340000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \        0x0   0x....'....        DC32     `ADXL345_Get_Angle::x1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \        0x0   0x....'....        DC32     `ADXL345_Get_Angle::y1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \        0x0   0x51EB'851F        DC32     0x51EB851F,0x40091EB8

   \              0x4009'1EB8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \        0x0   0x....'....        DC32     ADXL345_BUF

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   ADXL345_Get_Angle
        32   -> __aeabi_d2f
        32   -> __aeabi_d2iz
        32   -> __aeabi_ddiv
        32   -> __aeabi_f2d
        32   -> __aeabi_fmul
        32   -> __aeabi_i2d
        32   -> atan
        32   -> sqrt
      16   ADXL345_IIC_Init
        16   -> GPIO_Init
        16   -> GPIO_SetBits
        16   -> RCC_APB2PeriphClockCmd
       4   Delay5ms
       4   Delay5us
       8   Init_ADXL345
         8   -> ADXL345_IIC_Init
         8   -> Single_Write_ADXL345
       8   Multiple_read1_ADXL345
         8   -> ADXL345_Get_Angle
         8   -> Delay5us
         8   -> iic_ack
         8   -> iic_read_byte
         8   -> iic_send_byte
         8   -> iic_start
         8   -> iic_stop
       8   Multiple_read_ADXL345
         8   -> Delay5ms
         8   -> iic_ack
         8   -> iic_read_byte
         8   -> iic_send_byte
         8   -> iic_start
         8   -> iic_stop
       8   Single_Read_ADXL345
         8   -> iic_ack
         8   -> iic_read_byte
         8   -> iic_send_byte
         8   -> iic_start
         8   -> iic_stop
      16   Single_Write_ADXL345
        16   -> iic_send_byte
        16   -> iic_start
        16   -> iic_stop
      16   iic_ack
        16   -> Delay5us
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> iic_sda_mode
      24   iic_read_byte
        24   -> Delay5us
        24   -> GPIO_ReadInputDataBit
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> iic_sda_mode
      16   iic_sda_mode
        16   -> GPIO_Init
      24   iic_send_byte
        24   -> Delay5us
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> iic_sda_mode
        24   -> iic_wait_ack
      16   iic_start
        16   -> Delay5us
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> iic_sda_mode
      16   iic_stop
        16   -> Delay5us
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> iic_sda_mode
      16   iic_wait_ack
        16   -> Delay5us
        16   -> GPIO_ReadInputDataBit
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
        16   -> iic_sda_mode
        16   -> iic_stop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       8  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable8
       4  ??DataTable8_1
      12  ADXL345_BUF
     458  ADXL345_Get_Angle
      60  ADXL345_IIC_Init
      14  Delay5ms
      16  Delay5us
      64  Init_ADXL345
     284  Multiple_read1_ADXL345
      86  Multiple_read_ADXL345
      54  Single_Read_ADXL345
      38  Single_Write_ADXL345
      82  iic_ack
      86  iic_read_byte
      26  iic_sda_mode
     114  iic_send_byte
      60  iic_start
      60  iic_stop
      70  iic_wait_ack
       2  x
       2  x1
       2  y
       2  y1
       2  z
       2  z1

 
    24 bytes in section .bss
 1'620 bytes in section .text
 
 1'620 bytes of CODE memory
    24 bytes of DATA memory

Errors: none
Warnings: 3
